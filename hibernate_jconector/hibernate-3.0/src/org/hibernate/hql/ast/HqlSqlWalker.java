// $Id: HqlSqlWalker.java,v 1.81 2005/03/31 16:12:54 steveebersole Exp $
package org.hibernate.hql.ast;

import antlr.ASTFactory;
import antlr.RecognitionException;
import antlr.SemanticException;
import antlr.collections.AST;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.hibernate.QueryException;
import org.hibernate.engine.JoinSequence;
import org.hibernate.engine.SessionFactoryImplementor;
import org.hibernate.hql.QueryTranslator;
import org.hibernate.hql.antlr.HqlSqlBaseWalker;
import org.hibernate.hql.antlr.HqlTokenTypes;
import org.hibernate.hql.antlr.SqlTokenTypes;
import org.hibernate.persister.collection.QueryableCollection;
import org.hibernate.persister.entity.Queryable;
import org.hibernate.persister.entity.SingleTableEntityPersister;
import org.hibernate.sql.JoinFragment;
import org.hibernate.type.AssociationType;
import org.hibernate.type.Type;
import org.hibernate.util.ArrayHelper;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Implements methods used by the HQL->SQL tree transform grammar (a.k.a. the second phase).
 * <ul>
 * <li>Isolates the Hibernate API-specific code from the ANTLR generated code.</li>
 * <li>Handles the SQL framgents generated by the persisters in order to create the SELECT and FROM clauses,
 * taking into account the joins and projections that are implied by the mappings (persister/queryable).</li>
 * <li>Uses SqlASTFactory to create customized AST nodes.</li>
 * </ul>
 *
 * @see SqlASTFactory
 */
public class HqlSqlWalker extends HqlSqlBaseWalker implements ErrorReporter {
	private static Log log = LogFactory.getLog( HqlSqlWalker.class );

	/**
	 * A delegate that handles the Hiberanate meta data model.
	 */
	private SessionFactoryHelper sessionFactoryHelper;

	/**
	 * A delegate that handles literal constants.
	 */
	private LiteralProcessor literalProcessor;

	/**
	 * Handles parser errors.
	 */
	private ParseErrorHandler parseErrorHandler;

	/**
	 * The current context.
	 */
	private FromClause currentFromClause = null;

	/**
	 * The top-level SelectClause.
	 */
	private SelectClause selectClause;

	/**
	 * Generates alias names for tables.
	 */
	private AliasGenerator aliasGenerator = new AliasGenerator();

	/**
	 * The set of unique query spaces (a.k.a. table names).
	 */
	private Set querySpaces = new HashSet();

	/**
	 * A (string->string) map is used to substitute function names and literals.
	 */
	private Map tokenReplacements;

	private QueryTranslatorImpl queryTranslatorImpl;

	/**
	 * The number of parameters encountered so far.
	 */
	private int parameterCount;

	/**
	 * A map of lists which associates named and numbered parameters to a list of occurrences in the query.
	 */
	private Map namedParameters = new HashMap();

	private boolean useThetaStyleImplicitJoins = true;

	/**
	 * The filter collection role, or null if this isn't a filter compilation.
	 */
	private String filterCollectionRole;

	/**
	 * The parser that performed phase 1 - parse the HQL into an HQL tree.
	 */
	private HqlParser hqlParser;

	private ASTPrinter printer;

	/**
	 * The join type for any implied joins.
	 */
	private int impliedJoinType;

	/**
	 * Create a new tree transformer.
	 *
	 * @param qti               Back pointer to the query translator implementation that is using this tree transform.
	 * @param sfi               The session factory implementor where the Hibernate mappings can be found.
	 * @param parser
	 * @param tokenReplacements Registers the token replacement map with the walker.  This map will
	 *                          be used to substitute function names and constants.
	 * @param collectionRole    the role name of the collection used as the basis for the filter, NULL if this
	 */
	public HqlSqlWalker(QueryTranslatorImpl qti,
						SessionFactoryImplementor sfi,
						HqlParser parser,
						Map tokenReplacements,
						String collectionRole) {
		setASTFactory( new SqlASTFactory( this ) );
		// Initialize the error handling delegate.
		this.parseErrorHandler = new ErrorCounter();
		this.queryTranslatorImpl = qti;
		this.sessionFactoryHelper = new SessionFactoryHelper( sfi );
		this.literalProcessor = new LiteralProcessor( this );
		this.tokenReplacements = tokenReplacements;
		this.filterCollectionRole = collectionRole;
		this.hqlParser = parser;
		this.printer = new ASTPrinter( SqlTokenTypes.class );
	}


	protected void prepareFromClauseInputTree(AST fromClauseInput) {
		// Handle fiter compilation.
		// IMPORTANT NOTE: This is modifying the INPUT (HQL) tree, not the output tree!
		if ( isFilter() && !isSubQuery() ) {
			QueryableCollection persister = sessionFactoryHelper.getCollectionPersister( filterCollectionRole );
			Type collectionElementType = persister.getElementType();
			if ( !collectionElementType.isEntityType() ) {
				throw new QueryException( "collection of values in filter: this" );
			}

			String collectionElementEntityName = persister.getElementPersister().getEntityName();
			ASTFactory inputAstFactory = hqlParser.getASTFactory();
			AST fromElement = ASTUtil.create( inputAstFactory, HqlTokenTypes.FILTER_ENTITY, collectionElementEntityName );
			ASTUtil.createSibling( inputAstFactory, HqlTokenTypes.ALIAS, "this", fromElement );
			fromClauseInput.addChild( fromElement );
			// Show the modified AST.
			if ( log.isDebugEnabled() ) {
				log.debug( "prepareFromClauseInputTree() : Filter - Added 'this' as a from element..." );
			}
			queryTranslatorImpl.showHqlAst( hqlParser.getAST() );
		}
	}

	private boolean isFilter() {
		return filterCollectionRole != null;
	}

	public SessionFactoryHelper getSessionFactoryHelper() {
		return sessionFactoryHelper;
	}

	public Map getTokenReplacements() {
		return tokenReplacements;
	}

	public AliasGenerator getAliasGenerator() {
		return aliasGenerator;
	}

	FromClause getCurrentFromClause() {
		return currentFromClause;
	}

	public ParseErrorHandler getParseErrorHandler() {
		return parseErrorHandler;
	}

	public void reportError(RecognitionException e) {
		parseErrorHandler.reportError( e ); // Use the delegate.
	}

	public void reportError(String s) {
		parseErrorHandler.reportError( s ); // Use the delegate.
	}

	public void reportWarning(String s) {
		parseErrorHandler.reportWarning( s );
	}

	/**
	 * Returns the set of unique query spaces (a.k.a.
	 * table names) that occurred in the query.
	 *
	 * @return A set of table names (Strings).
	 */
	Set getQuerySpaces() {
		return querySpaces;
	}

	protected AST createFromElement(String path, AST alias) throws SemanticException {
		FromElement fromElement = currentFromClause.addFromElement( path, alias );
		return fromElement;
	}

	protected AST createFromFilterElement(AST filterEntity, AST alias) throws SemanticException {
		FromElement fromElement = currentFromClause.addFromElement( filterEntity.getText(), alias );
		FromClause fromClause = fromElement.getFromClause();
		QueryableCollection persister = sessionFactoryHelper.getCollectionPersister( filterCollectionRole );
		// Get the names of the columns used to link between the collection
		// owner and the collection elements.
		String[] keyColumnNames = persister.getKeyColumnNames();
		String fkTableAlias = persister.isOneToMany()
				? fromElement.getTableAlias()
				: fromClause.getAliasGenerator().createName( filterCollectionRole );
		JoinSequence join = sessionFactoryHelper.createJoinSequence();
		join.setRoot( persister, fkTableAlias );
		if ( !persister.isOneToMany() ) {
			join.addJoin( ( AssociationType ) persister.getElementType(),
					fromElement.getTableAlias(),
					JoinFragment.INNER_JOIN,
					persister.getElementColumnNames( fkTableAlias ) );
		}
		join.addCondition( fkTableAlias, keyColumnNames, " = ?" );
		fromElement.setJoinSequence( join );
		fromElement.setFilter( true );
		if ( log.isDebugEnabled() ) {
			log.debug( "createFromFilterElement() : processed filter FROM element." );
		}
		return fromElement;
	}

	protected void createFromJoinElement(AST path, AST alias, int joinType, AST fetchNode) throws SemanticException {
		boolean fetch = ( fetchNode != null ) ? true : false;
		// The path AST should be a DotNode, and it should have been evaluated already.
		if ( path.getType() != SqlTokenTypes.DOT ) {
			throw new SemanticException( "Path expected for join!" );
		}
		DotNode dot = ( DotNode ) path;
		int hibernateJoinType = JoinProcessor.toHibernateJoinType( joinType );
		dot.setJoinType( hibernateJoinType );	// Tell the dot node about the join type.
		dot.setFetch( fetch );
		// Generate an explicit join for the root dot node.   The implied joins will be collected and passed up
		// to the root dot node.
		dot.resolve( true, false, alias == null ? null : alias.getText() );
		FromElement elem = dot.getImpliedJoin();
		if ( log.isDebugEnabled() ) {
			log.debug( "createFromJoinElement() : " + getASTPrinter().showAsString( elem, "-- join tree --" ) );
		}
	}

	/**
	 * Sets the current 'FROM' context.
	 *
	 * @param fromNode      The new 'FROM' context.
	 * @param inputFromNode The from node from the input AST.
	 */
	protected void pushFromClause(AST fromNode, AST inputFromNode) {
		FromClause newFromClause = ( FromClause ) fromNode;
		newFromClause.setParentFromClause( currentFromClause );
		currentFromClause = newFromClause;
	}

	/**
	 * Returns to the previous 'FROM' context.
	 */
	private void popFromClause() {
		currentFromClause = currentFromClause.getParentFromClause();
	}

	protected void lookupAlias(AST aliasRef)
			throws SemanticException {
		FromElement alias = currentFromClause.getFromElement( aliasRef.getText() );
		FromReferenceNode aliasRefNode = ( FromReferenceNode ) aliasRef;
		aliasRefNode.setFromElement( alias );
	}

	protected void setImpliedJoinType(int joinType) {
		impliedJoinType = JoinProcessor.toHibernateJoinType( joinType );
	}

	int getImpliedJoinType() {
		return impliedJoinType;
	}

	protected AST lookupProperty(AST dot, boolean root, boolean inSelect) throws SemanticException {
		DotNode dotNode = ( DotNode ) dot;
		FromReferenceNode lhs = dotNode.getLhs();
		AST rhs = lhs.getNextSibling();
		switch ( rhs.getType() ) {
			case SqlTokenTypes.ELEMENTS:
			case SqlTokenTypes.INDICES:
				if ( log.isDebugEnabled() ) {
					log.debug( "lookupProperty() " + dotNode.getPath() + " => " + rhs.getText() + "(" + lhs.getPath() + ")" );
				}
				CollectionFunction f = ( CollectionFunction ) rhs;
				// Re-arrange the tree so that the collection function is the root and the lhs is the path.
				f.setFirstChild( lhs );
				lhs.setNextSibling( null );
				dotNode.setFirstChild( f );
				resolve( lhs );			// Don't forget to resolve the argument!
				f.resolve( inSelect );	// Resolve the collection function now.
				return f;
			default:
				// Resolve everything up to this dot, but don't resolve the rhs yet.
				dotNode.resolveFirstChild();
				return dotNode;
		}
	}

	protected void processQuery(AST select, AST query) throws SemanticException {
		if ( log.isDebugEnabled() ) {
			log.debug( "processQuery() : " + query.toStringTree() );
		}

		try {
			QueryNode qn = ( QueryNode ) query;

			// Was there an explicit select expression?
			boolean explicitSelect = select != null && select.getNumberOfChildren() > 0;

			if ( !explicitSelect ) {
				// No explicit select expression; render the id and properties
				// projection lists for every persister in the from clause into
				// a single 'token node'.
				//TODO: the only reason we need this stuff now is collection filters,
				//      we should get rid of derived select clause completely!
				createSelectClauseFromFromClause( qn );
			}
			else {
				// Use the explicitly declared select expression; determine the
				// return types indicated by each select token
				useSelectClause( select );
			}

			// After that, process the JOINs.
			// Invoke a delegate to do the work, as this is farily complex.
			JoinProcessor joinProcessor = new JoinProcessor( astFactory, queryTranslatorImpl );
			joinProcessor.processJoins( qn );

			// Attach any mapping-defined "ORDER BY" fragments
			Iterator itr = qn.getFromClause().getProjectionList().iterator();
			while ( itr.hasNext() ) {
				final FromElement fromElement = ( FromElement ) itr.next();
//			if ( fromElement.isFetch() && fromElement.isCollectionJoin() ) {
				if ( fromElement.isFetch() && fromElement.getQueryableCollection() != null ) {
					// Does the collection referenced by this FromElement
					// specify an order-by attribute?  If so, attach it to
					// the query's order-by
					if ( fromElement.getQueryableCollection().hasOrdering() ) {
						String orderByFragment = fromElement
								.getQueryableCollection()
								.getSQLOrderByString( fromElement.getCollectionTableAlias() );
						qn.getOrderByClause().addOrderFragment( orderByFragment );
					}
				}
			}
		}
		finally {
			popFromClause();
		}
	}

	protected void postProcessUpdate(AST update) throws SemanticException {
		QueryNode qn = ( QueryNode ) update;

		FromClause fromClause = qn.getFromClause();
		fromClause.resolve();

		// For now, validate that the FROM clause did not reference any
		// form of subclass...
		FromElement fromElement = ( FromElement ) fromClause.getFromElements().get( 0 );
		Queryable persister = fromElement.getQueryable();
		// Make #@%$^#^&# sure no alias is applied to the table name
		fromElement.setText( persister.getTableName() );

		// TODO : need a better way to do these checks
		if ( persister instanceof SingleTableEntityPersister ) {
			SingleTableEntityPersister step = ( SingleTableEntityPersister ) persister;
			new SyntheticAndFactory( getASTFactory() )
					.addDiscriminatorWhereFragment( qn, step, fromElement.getTableAlias() );
		}
		else {
			if ( persister.getMappedSuperclass() != null ) {
				// TODO : add support for spawning potential multiple sql updates for these cases...
				// for now, just error as unsupported...
				throw new QueryException( "Update statements against joined or union subclasses not yet supported!" );
			}
		}
	}

	protected void postProcessDelete(AST delete) throws SemanticException {
		QueryNode qn = ( QueryNode ) delete;

		FromClause fromClause = qn.getFromClause();
		fromClause.resolve();

		// For now, validate that the FROM clause did not reference any
		// form of subclass...
		FromElement fromElement = ( FromElement ) fromClause.getFromElements().get( 0 );
		Queryable persister = fromElement.getQueryable();
		// Make #@%$^#^&# sure no alias is applied to the table name
		fromElement.setText( persister.getTableName() );

		// TODO : need a better way to do these checks
		if ( persister instanceof SingleTableEntityPersister ) {
			SingleTableEntityPersister step = ( SingleTableEntityPersister ) persister;
			new SyntheticAndFactory( getASTFactory() )
					.addDiscriminatorWhereFragment( qn, step, fromElement.getTableAlias() );
		}
		else {
			if ( persister.getMappedSuperclass() != null ) {
				// TODO : add support for spawning potential multiple sql deletes for these cases...
				// for now, just error as unsupported...
				throw new QueryException( "Delete statements against joined or union subclasses not yet supported!" );
			}
		}
	}

	private void useSelectClause(AST select) throws SemanticException {
		selectClause = ( SelectClause ) select;
		selectClause.initializeExplicitSelectClause( currentFromClause );
	}

	private void createSelectClauseFromFromClause(QueryNode qn) throws SemanticException {
		AST select = astFactory.create( SELECT_CLAUSE, "{derived select clause}" );
		AST sibling = qn.getFromClause();
		qn.setFirstChild( select );
		select.setNextSibling( sibling );
		selectClause = ( SelectClause ) select;
		selectClause.initializeDerivedSelectClause( currentFromClause );
		if ( log.isDebugEnabled() ) {
			log.debug( "Derived SELECT clause created." );
		}
	}

	protected void resolve(AST node) throws SemanticException {
		if ( node != null ) {
			// This is called when it's time to fully resolve a path expression.
			ResolvableNode r = ( ResolvableNode ) node;
			if ( isInFunctionCall() ) {
				r.resolveInFunctionCall( false, true );
			}
			else {
				r.resolve( false, true );	// Generate implicit joins, only if necessary.
			}
		}
	}

	protected void resolveSelectExpression(AST node) throws SemanticException {
		// This is called when it's time to fully resolve a path expression.
		int type = node.getType();
		switch ( type ) {
			case DOT:
				DotNode dot = ( DotNode ) node;
				dot.resolveSelectExpression( useThetaStyleImplicitJoins );
				break;
			case ALIAS_REF:
				// Notify the FROM element that it is being referenced by the select.
				FromReferenceNode aliasRefNode = ( FromReferenceNode ) node;
				//aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here?
				aliasRefNode.resolve( false, false ); //TODO: is it kosher to do it here?
				FromElement fromElement = aliasRefNode.getFromElement();
				if ( fromElement != null ) {
					fromElement.setIncludeSubclasses( true );
				}
			default:
				break;
		}
	}

	protected void beforeSelectClause() throws SemanticException {
		// Turn off includeSubclasses on all FromElements.
		FromClause from = getCurrentFromClause();
		List fromElements = from.getFromElements();
		for ( Iterator iterator = fromElements.iterator(); iterator.hasNext(); ) {
			FromElement fromElement = ( FromElement ) iterator.next();
			fromElement.setIncludeSubclasses( false );
		}
	}

	protected void positionalParameter(AST parameter) throws SemanticException {
		if ( namedParameters.size() > 0 ) {
			throw new SemanticException( "" );
		}
	}

	private void addNamedParameter(String name) {
		Integer loc = new Integer( parameterCount++ );
		Object o = namedParameters.get( name );
		if ( o == null ) {
			namedParameters.put( name, loc );
		}
		else if ( o instanceof Integer ) {
			ArrayList list = new ArrayList( 4 );
			list.add( o );
			list.add( loc );
			namedParameters.put( name, list );
		}
		else {
			( ( ArrayList ) o ).add( loc );
		}
	}

	protected void processConstant(AST constant) throws SemanticException {
		literalProcessor.processConstant( constant );  // Use the delegate.
	}

	protected void processBoolean(AST constant) throws SemanticException {
		literalProcessor.processBoolean( constant );  // Use the delegate.
	}

	protected void processIndex(AST indexOp) throws SemanticException {
		IndexNode indexNode = ( IndexNode ) indexOp;
		indexNode.resolve( true, true );
	}

	protected void processFunction(AST functionCall, boolean inSelect) throws SemanticException {
		MethodNode methodNode = ( MethodNode ) functionCall;
		methodNode.resolve( inSelect );
	}

	protected void processConstructor(AST constructor) throws SemanticException {
		ConstructorNode constructorNode = ( ConstructorNode ) constructor;
		constructorNode.prepare();
	}

	protected void namedParameter(AST namedParameter) throws SemanticException {
		addNamedParameter( namedParameter.getText() );
		namedParameter.setText( "?" );	// Named HQL parameters translate into SQL '?' parameters.
	}

	/**
	 * Returns the locations of all occurrences of the named parameter.
	 */
	int[] getNamedParameterLocs(String name) throws QueryException {
		Object o = namedParameters.get( name );
		if ( o == null ) {
			QueryException qe = new QueryException( QueryTranslator.ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR + name );
			qe.setQueryString( queryTranslatorImpl.getQueryString() );
			throw qe;
		}
		if ( o instanceof Integer ) {
			return new int[]{( ( Integer ) o ).intValue()};
		}
		else {
			return ArrayHelper.toIntArray( ( ArrayList ) o );
		}
	}

	void addQuerySpaces(Serializable[] spaces) {
		for ( int i = 0; i < spaces.length; i++ ) {
			querySpaces.add( spaces[i] );
		}
	}

	public Type[] getReturnTypes() {
		return selectClause.getQueryReturnTypes();
	}

	public boolean isSubQuery() {
		return currentFromClause != null ? currentFromClause.isSubQuery() : false;
	}

	public SelectClause getSelectClause() {
		return selectClause;
	}

	public boolean isShallowQuery() {
		return queryTranslatorImpl.isShallowQuery();
	}

	public Map getEnabledFilters() {
		return queryTranslatorImpl.getEnabledFilters();
	}

	LiteralProcessor getLiteralProcessor() {
		return literalProcessor;
	}

	ASTPrinter getASTPrinter() {
		return printer;
	}
}
