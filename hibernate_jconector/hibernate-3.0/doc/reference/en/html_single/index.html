<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HIBERNATE - Relational Persistence for Idiomatic Java</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>HIBERNATE - Relational Persistence for Idiomatic Java</h1></div><div><h2 class="subtitle">Hibernate Reference Documentation</h2></div><div><p class="releaseinfo">3.0</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Quickstart with Tomcat</a></span></dt><dd><dl><dt><span class="sect1"><a href="#quickstart-intro">1.1. Getting started with Hibernate</a></span></dt><dt><span class="sect1"><a href="#quickstart-persistentclass">1.2. First persistent class</a></span></dt><dt><span class="sect1"><a href="#quickstart-mapping">1.3. Mapping the cat</a></span></dt><dt><span class="sect1"><a href="#quickstart-playingwithcats">1.4. Playing with cats</a></span></dt><dt><span class="sect1"><a href="#quickstart-summary">1.5. Finally</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Overview</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Instance states</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. JMX Integration</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. JCA Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Programmatic configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtaining a SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. JDBC connections</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Optional configuration properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Binary Streams</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Second-level and query cache</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.4.5. Transaction strategy configuration</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.4.6. JNDI-bound SessionFactory</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.7. Query Language Substitution</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.8. Hibernate statistics</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Logging</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Implementing a NamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. XML configuration file</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Persistent Classes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. A simple POJO example</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.1. Declare accessors and mutators for persistent fields</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.2. Implement a no-argument constructor</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.3. Provide an identifier property (optional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.4. Prefer non-final classes (optional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementing inheritance</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementing equals() and hashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Dynamic models</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Basic O/R Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Mapping declaration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.4.1. Generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.4.2. Hi/lo algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid">5.1.4.3. UUID algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.4.4. Identity columns and sequences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.4.5. Assigned identifiers</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-select">5.1.4.6. Primary keys assigned by triggers</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.5. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.6. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.7. version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.8. timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.9. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.10. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.11. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.12. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.13. properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.14. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.15. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.16. union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.17. join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.18. key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.19. column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.20. import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.21. any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entities and values</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Custom value types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.3. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.4. Metadata alternatives</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.4.1. Using XDoclet markup</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.4.2. Using JDK 5.0 Annotations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Persistent collections</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Collection mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Collection foreign keys</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Collection elements</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Indexed collections</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Collections of values and many-to-many associations</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. One-to-many associations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Advanced collection mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Sorted collections</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Bidirectional associations</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.3. Ternary associations</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.4. Using an &lt;idbag&gt;</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Collection examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. Association Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Unidirectional associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. one to many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Unidirectional associations with join tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. one to many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. many to many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Bidirectional associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one to many / many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. one to one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Bidirectional associations with join tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one to many / many to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. many to many</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#components">8. Component Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Collections of dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Components as Map indices</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Components as composite identifiers</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Dynamic components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The Three Strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Table per class hierarchy</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass, using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mixing table per class hierarchy with table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Table per concrete class</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class, using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritace-mixingpolymorphism">9.1.7. Mixing implicit polymorphism with other inheritance mappings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. Working with objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Hibernate object states</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Making objects persistent</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Loading an object</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Querying</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Executing queries</a></span></dt><dd><dl><dt><span class="sect3"><a href="#objectstate-querying-executing-iterate">10.4.1.1. Iterating results</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-tuples">10.4.1.2. Queries that return tuples</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-scalar">10.4.1.3. Scalar results</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-parameters">10.4.1.4. Bind parameters</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-pagination">10.4.1.5. Pagination</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-scrolling">10.4.1.6. Scrollable iteration</a></span></dt><dt><span class="sect3"><a href="#objectstate-querying-executing-named">10.4.1.7. Externalizing named queries</a></span></dt></dl></dd><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtering collections</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Criteria queries</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Queries in native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modifying persistent objects</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modifying detached objects</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. Automatic state detection</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Deleting persistent objects</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. Replicating object between two different datastores</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Flushing the Session</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Transitive persistence</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Using metadata</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions And Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Session and transaction scopes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unit of work</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Application transactions</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. Considering object identity</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Common issues</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. Database transaction demarcation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Non-managed environment</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Using JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Exception handling</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Optimistic concurrency control</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Application version checking</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Long session and automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Detached objects and automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Customizing automatic versioning</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic Locking</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. Interceptors and events</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Interceptors</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Event system</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Hibernate declarative security</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Batch processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Batch inserts</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Batch updates</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: The Hibernate Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Case Sensitivity</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. The from clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Associations and joins</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.4. The select clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.5. Aggregate functions</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.6. Polymorphic queries</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.7. The where clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.8. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.9. The order by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.10. The group by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.11. Subqueries</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.12. HQL examples</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.13. Tips &amp; Tricks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Criteria Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Creating a Criteria instance</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Narrowing the result set</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Ordering the results</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Dynamic association fetching</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Example queries</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, aggregation and grouping</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Detached queries and subqueries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. Native SQL</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Creating a native SQL Query</a></span></dt><dt><span class="sect1"><a href="#querysql-aliasreferences">16.2. Alias and property references</a></span></dt><dt><span class="sect1"><a href="#querysql-namedqueries">16.3. Named SQL queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.3.1. Using return-property to explicitly specify column/alias names</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.3.2. Using stored procedures for querying</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-limits-storedprocedures">16.3.2.1. Rules/limitations for using stored procedures</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.4. Custom SQL for create, update and delete</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.5. Custom SQL for loading</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. Filtering data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Hibernate filters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. XML Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Working with XML data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Specifying XML and class mapping together</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Specifying only an XML mapping</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. XML mapping metadata</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipulating XML data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. Improving performance</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Fetching strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.1. Tuning fetch strategies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.2. Single-ended association proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.3. Initializing collections and proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.4. Using batch fetching</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.5. Using lazy property fetching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. The Second Level Cache</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Cache mappings</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Strategy: read only</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Strategy: read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Strategy: nonstrict read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Strategy: transactional</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Managing the caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. The Query Cache</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Understanding Collection performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Taxonomy</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Lists, maps, idbags and sets are the most efficient collections to update</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Bags and lists are the most efficient inverse collections</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. One shot delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Monitoring performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Monitoring a SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Metrics</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Toolset Guide</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Automatic schema generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Customizing the schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Running the tool</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Properties</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Using Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Incremental schema updates</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Using Ant for incremental schema updates</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. Example: Parent/Child</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. A note about collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. Bidirectional one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Cascading lifecycle</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Cascades and unsaved-value</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. Example: Weblog Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Persistent Classes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Hibernate Mappings</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Hibernate Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. Example: Various Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Customer/Order/Product</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Miscellaneous example mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "Typed" one-to-one association</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Composite key example</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.3. Content based discrimination</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.4. Associations on alternate keys</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. Best Practices</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
            Working with object-oriented software and a relational database can be cumbersome
            and time consuming in today's enterprise environments. Hibernate is an object/relational
            mapping tool for Java environments. The term object/relational mapping (ORM) refers to
            the technique of mapping a data representation from an object model to a relational
            data model with a SQL-based schema.
        </p><p>
            Hibernate not only takes care of the mapping from Java classes to
            database tables (and from Java data types to SQL data types), but also provides data
            query and retrieval facilities and can significantly reduce development time otherwise
            spent with manual data handling in SQL and JDBC.
        </p><p>
            Hibernates goal is to relieve the developer from 95 percent of common data persistence
            related programming tasks. Hibernate may not be the best solution for data-centric
            applications that only use stored-procedures to implement the business logic in the
            database, it is most useful with object-oriented domain models and business logic in
            the Java-based middle-tier. However, Hibernate can certainly help you to remove or
            encapsulate vendor-specific SQL code and will help with the common task of result set
            translation from a tabular representation to a graph of objects.
        </p><p>
            If you are new to Hibernate and Object/Relational Mapping or even Java,
            please follow these steps:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Read <a href="#quickstart" title="Chapter&nbsp;1.&nbsp;Quickstart with Tomcat">Chapter&nbsp;1, <i>Quickstart with Tomcat</i></a> for a 30 minute tutorial, using Tomcat.
                </p></li><li><p>
                    Read <a href="#architecture" title="Chapter&nbsp;2.&nbsp;Architecture">Chapter&nbsp;2, <i>Architecture</i></a> to understand the environments where
                    Hibernate can be used.
                </p></li><li><p>
                    Have a look at the <tt class="literal">eg/</tt> directory in the Hibernate
                    distribution, it contains a simple standalone application. Copy your
                    JDBC driver to the <tt class="literal">lib/</tt> directory and edit
                    <tt class="literal">etc/hibernate.properties</tt>, specifying correct values for
                    your database. From a command prompt in the distribution directory,
                    type <tt class="literal">ant eg</tt> (using Ant), or under Windows, type
                    <tt class="literal">build eg</tt>.
                </p></li><li><p>
                    Use this reference documentation as your primary source of information.
                    Consider reading <span class="emphasis"><em>Hibernate in Action</em></span>
                    (http://www.manning.com/bauer) if you need more help with application
                    design or if you prefer a step-by-step tutorial. Also visit
                    http://caveatemptor.hibernate.org and download the example application
                    for Hibernate in Action.
                </p></li><li><p>
					FAQs are answered on the Hibernate website.
				</p></li><li><p>
					Third party demos, examples and tutorials are linked on the Hibernate
					website.
				</p></li><li><p>
                    The Community Area on the Hibernate website is a good source for
                    design patterns and various integration solutions (Tomcat, JBoss,
                    Struts, EJB, etc.).
                </p></li></ol></div><p>
             If you have questions, use the user forum linked on the Hibernate website. We also
             provide a JIRA issue trackings system for bug reports and feature requests. If you
             are interested in the development of Hibernate, join the developer mailing list. If
             you are interested in translating this documentation into your language, contact us
             on the developer mailing list.
         </p><p>
             Commercial development support, production support and training for Hibernate is
             available through JBoss Inc. (see http://www.hibernate.org/SupportTraining/).
             Hibernate is a project of the JBoss Professional Open Source product suite.
         </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Chapter&nbsp;1.&nbsp;Quickstart with Tomcat</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-intro"></a>1.1.&nbsp;Getting started with Hibernate</h2></div></div><div></div></div><p>
            This tutorial explains a setup of Hibernate 3.0 with the Apache Tomcat
            servlet container for a web-based application. Hibernate works
            well in a managed environment with all major J2EE application servers, or
            even in standalone Java applications. The database system used in this
            tutorial is PostgreSQL 7.4, support for other database is only a matter
            of changing the Hibernate SQL dialect configuration and connection
            properties.
        </p><p>
            First, we have to copy all required libraries to the Tomcat installation.
            We use a separate web context (<tt class="literal">webapps/quickstart</tt>) for
            this tutorial, so we've to consider both the global library search path
            (<tt class="literal">TOMCAT/common/lib</tt>) and the classloader at the context level in
            <tt class="literal">webapps/quickstart/WEB-INF/lib</tt> (for JAR files) and
            <tt class="literal">webapps/quickstart/WEB-INF/classes</tt>. We refer to both classloader
            levels as the global classpath and the context classpath.
        </p><p>
            Now, copy the libraries to the two classpaths:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Copy the JDBC driver for the database to the global classpath. This is
                    required for the DBCP connection pool software which comes bundled with Tomcat.
                    Hibernate uses JDBC connections to execute SQL on the database, so you
                    either have to provide pooled JDBC connections or configure Hibernate to
                    use one of the directly supported pools (C3P0, Proxool). For this tutorial,
                    copy the <tt class="literal">pg74jdbc3.jar</tt> library (for PostgreSQL 7.4 and JDK 1.4)
                    to the global classloaders path. If you'd like to use a different database, simply
                    copy its appropriate JDBC driver.
                </p></li><li><p>
					Never copy anything else into the global classloader path in Tomcat, or you
					will get  problems with various tools, including Log4j, commons-logging and
					others. Always use the context classpath for each web application, that is,
					copy libraries to <tt class="literal">WEB-INF/lib</tt> and your own classes and
                    configuration/property files to <tt class="literal">WEB-INF/classes</tt>. Both
                    directories are in the context level classpath by default.
				</p></li><li><p>
                    Hibernate is packaged as a JAR library. The <tt class="literal">hibernate3.jar</tt>
                    file should be copied in the context classpath together with other classes of
                    the application. Hibernate requires some 3rd party libraries at runtime, these
                    come bundled with the Hibernate distribution in the <tt class="literal">lib/</tt>
                    directory; see <a href="#3rdpartylibs" title="Table&nbsp;1.1.&nbsp;&#xA;                Hibernate 3rd party libraries&#xA;            ">Table&nbsp;1.1, &#8220;
                Hibernate 3rd party libraries
            &#8221;</a>. Copy the required 3rd party
                    libraries to the context classpath.
                </p></li></ol></div><div class="table"><a name="3rdpartylibs"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;
                Hibernate 3rd party libraries
            </b></p><table summary="&#xA;                Hibernate 3rd party libraries&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">
                            Library
                        </th><th align="center">
                            Description
                        </th></tr></thead><tbody><tr><td>
                            antlr (required)
                        </td><td>
                            Hibernate uses ANTLR to produce query parsers, this library is
                            also needed at runtime.
                        </td></tr><tr><td>
                            dom4j (required)
                        </td><td>
                            Hibernate uses dom4j to parse XML configuration and XML mapping
                            metadata files.
                        </td></tr><tr><td>
                            CGLIB (required)
                        </td><td>
                            Hibernate uses the code generation library to enhance classes
                            at runtime (in combination with Java reflection).
                        </td></tr><tr><td>
                            Commons Collections, Commons Logging (required)
                        </td><td>
                            Hibernate uses various utility libraries from the Apache Jakarta
                            Commons project.
                        </td></tr><tr><td>
                            EHCache (required)
                        </td><td>
                            Hibernate can use various cache providers for the second-level
                            cache. EHCache is the default cache provider if not changed in
                            the configuration.
                        </td></tr><tr><td>
                            Log4j (optional)
                        </td><td>
                            Hibernate uses the Commons Logging API, which in turn can use
                            Log4j as the underlying logging mechanism. If the Log4j library is
                            available in the context library directory, Commons Logging will use
                            Log4j and the <tt class="literal">log4j.properties</tt> configuration in the
                            context classpath. An example properties file for Log4j is bundled
                            with the Hibernate distribution. So, copy log4j.jar and the configuration
                            file (from <tt class="literal">src/</tt>) to your context classpath if
                            you want to see whats going on behind the scenes.
                        </td></tr><tr><td>
                            Required or not?
                        </td><td>
                            Have a look at the file <tt class="literal">lib/version.properties</tt> in the
                            Hibernate distribution. This is an up-to-date list of 3rd party
                            libraries distributed with Hibernate. You will find all required
                            and optional libraries listed there (note that "buildtime required"
                            here means for Hibernate's build, not your application).
                        </td></tr></tbody></table></div><p>
            We now set up the database connection pooling and sharing in both Tomcat and
            Hibernate. This means Tomcat will provide pooled JDBC connections (using its
            builtin DBCP pooling feature), Hibernate requests theses connections through
            JNDI. Tomcat binds the connection pool to JNDI, we add a resource declaration
            to Tomcats main configuration file, <tt class="literal">TOMCAT/conf/server.xml</tt>:
        </p><pre class="programlisting">&lt;Context path="/quickstart" docBase="quickstart"&gt;
    &lt;Resource name="jdbc/quickstart" scope="Shareable" type="javax.sql.DataSource"/&gt;
    &lt;ResourceParams name="jdbc/quickstart"&gt;
        &lt;parameter&gt;
            &lt;name&gt;factory&lt;/name&gt;
            &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP database connection settings --&gt;
        &lt;parameter&gt;
            &lt;name&gt;url&lt;/name&gt;
            &lt;value&gt;jdbc:postgresql://localhost/quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;driverClassName&lt;/name&gt;&lt;value&gt;org.postgresql.Driver&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;username&lt;/name&gt;
            &lt;value&gt;quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;password&lt;/name&gt;
            &lt;value&gt;secret&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP connection pooling options --&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxWait&lt;/name&gt;
            &lt;value&gt;3000&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxIdle&lt;/name&gt;
            &lt;value&gt;100&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxActive&lt;/name&gt;
            &lt;value&gt;10&lt;/value&gt;
        &lt;/parameter&gt;
    &lt;/ResourceParams&gt;
&lt;/Context&gt;</pre><p>
			The context we configure in this example is named <tt class="literal">quickstart</tt>,
			its base is the <tt class="literal">TOMCAT/webapp/quickstart</tt> directory. To access
			any servlets, call the path <tt class="literal">http://localhost:8080/quickstart</tt>
			in your browser (of course, adding the name of the servlet as mapped in your
			<tt class="literal">web.xml</tt>). You may also go ahead and create a simple servlet
			now that has an empty <tt class="literal">process()</tt> method.
		</p><p>
            Tomcat provides connections now through JNDI at
            <tt class="literal">java:comp/env/jdbc/quickstart</tt>. If you have trouble getting the
            connection pool running, refer to the Tomcat documentation. If you get JDBC driver
            exception messages, try to setup JDBC connection pool without Hibernate first.
            Tomcat &amp; JDBC tutorials are available on the Web.
        </p><p>
            Your next step is to configure Hibernate. Hibernate has to know how it should obtain
            JDBC connections We use Hibernates XML-based configuration. The other approach, using
            a properties file, is equivalent in features, but doesn't offer any advantages. We use
            the XML configuration because it is usually more convenient. The XML configuration file
            is placed in the context classpath (<tt class="literal">WEB-INF/classes</tt>), as
            <tt class="literal">hibernate.cfg.xml</tt>:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;property name="connection.datasource"&gt;java:comp/env/jdbc/quickstart&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.PostgreSQLDialect&lt;/property&gt;

        &lt;!-- Mapping files --&gt;
        &lt;mapping resource="Cat.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
            We turn logging of SQL commands off and tell Hibernate what database SQL
            dialect is used and where to get the JDBC connections (by declaring the JNDI
            address of the Tomcat bound pool). The dialect is a required setting,
            databases differ in their interpretation of the SQL "standard". Hibernate will take
            care of the differences and comes bundled with dialects for all major
            commercial and open source databases.
        </p><p>
            A <tt class="literal">SessionFactory</tt> is Hibernate's concept of a single
            datastore, multiple databases can be used by creating multiple XML
            configuration files and creating multiple <tt class="literal">Configuration</tt>
            and <tt class="literal">SessionFactory</tt> objects in your application.
        </p><p>
            The last element of the <tt class="literal">hibernate.cfg.xml</tt> declares
            <tt class="literal">Cat.hbm.xml</tt> as the name of a Hibernate XML mapping
            file for the persistent class <tt class="literal">Cat</tt>. This file contains
            the metadata for the mapping of the POJO class <tt class="literal">Cat</tt> to
            a datbase table (or tables). We'll come back to that file soon. Let's write
            the POJO class first and then declare the mapping metadata for it.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-persistentclass"></a>1.2.&nbsp;First persistent class</h2></div></div><div></div></div><p>
            Hibernate works best with the Plain Old Java Objects (POJOs, sometimes
            called Plain Ordinary Java Objects) programming model for persistent classes.
            A POJO is much like a JavaBean, with properties of the class accessible via getter
            and setter methods, shielding the internal representation from the publicly
            visible interface (Hibernate can also access fields directly, if needed):
        </p><pre class="programlisting">package org.hibernate.examples.quickstart;

public class Cat {

    private String id;
    private String name;
    private char sex;
    private float weight;

    public Cat() {
    }

    public String getId() {
        return id;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public float getWeight() {
        return weight;
    }

    public void setWeight(float weight) {
        this.weight = weight;
    }

}</pre><p>
            Hibernate is not restricted in its usage of property types, all Java JDK
            types and primitives (like <tt class="literal">String</tt>, <tt class="literal">char</tt>
            and <tt class="literal">Date</tt>) can be mapped, including classes from the Java
            collections framework. You can map them as values, collections of values, or
            associations to other entities. The <tt class="literal">id</tt> is a special property
            that represents the database identifer (primary key) of that class, it is
            highly recommended for entities like a <tt class="literal">Cat</tt>. Hibernate can
            use identifiers only internally, but we would lose some of the flexibility in our
            application architecture.
        </p><p>
            No special interface has to be implemented for persistent classes nor do you have
            to subclass from a special root persistent class. Hibernate also doesn't require
            any build time processing, such as byte-code manipulation, it relies solely on
            Java reflection and runtime class enhancement (through CGLIB). So, without any
            dependency of the POJO class on Hibernate, we can map it to a database table.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-mapping"></a>1.3.&nbsp;Mapping the cat</h2></div></div><div></div></div><p>
            The <tt class="literal">Cat.hbm.xml</tt> mapping file contains the metadata
            required for the object/relational mapping. The metadata includes declaration
            of persistent classes and the mapping of properties (to columns and
            foreign key relationships to other entities) to database tables.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;

    &lt;class name="org.hibernate.examples.quickstart.Cat" table="CAT"&gt;

        &lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by Hibernate with the UUID pattern. --&gt;
        &lt;id name="id" type="string" unsaved-value="null" &gt;
            &lt;column name="CAT_ID" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex"/&gt;
        &lt;/id&gt;

        &lt;!-- A cat has to have a name, but it shouldn' be too long. --&gt;
        &lt;property name="name"&gt;
            &lt;column name="NAME" length="16" not-null="true"/&gt;
        &lt;/property&gt;

        &lt;property name="sex"/&gt;

        &lt;property name="weight"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Every persistent class should have an identifer attribute (actually, only
            classes representing entities, not dependent value-typed classes, which
            are mapped as components of an entity). This property is used to distinguish
            persistent objects: Two cats are equal if
            <tt class="literal">catA.getId().equals(catB.getId())</tt> is true, this concept is
            called <span class="emphasis"><em>database identity</em></span>. Hibernate comes bundled with
            various identifer generators for different scenarios (including native generators
            for database sequences, hi/lo identifier tables, and application assigned
            identifiers). We use the UUID generator (only recommended for testing, as integer
            surrogate keys generated by the database should be prefered) and also specify the
            column <tt class="literal">CAT_ID</tt> of the table <tt class="literal">CAT</tt> for the
            Hibernate generated identifier value (as a primary key of the table).
        </p><p>
            All other properties of <tt class="literal">Cat</tt> are mapped to the same table. In
            the case of the <tt class="literal">name</tt> property, we mapped it with an explicit
            database column declaration. This is especially useful when the database
            schema is automatically generated (as SQL DDL statements) from the mapping
            declaration with Hibernate's <span class="emphasis"><em>SchemaExport</em></span> tool. All other
            properties are mapped using Hibernate's default settings, which is what you
            need most of the time. The table <tt class="literal">CAT</tt> in the database looks
            like this:
        </p><pre class="programlisting"> Column |         Type          | Modifiers
--------+-----------------------+-----------
 cat_id | character(32)         | not null
 name   | character varying(16) | not null
 sex    | character(1)          |
 weight | real                  |
Indexes: cat_pkey primary key btree (cat_id)</pre><p>
			You should now create this table in your database manually, and later read
			<a href="#toolsetguide" title="Chapter&nbsp;20.&nbsp;Toolset Guide">Chapter&nbsp;20, <i>Toolset Guide</i></a> if you want to automate this step with the
			<tt class="literal">hbm2ddl</tt> tool. This tool can create a full SQL DDL, including
            table definition, custom column type constraints, unique constraints and indexes.
    	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-playingwithcats"></a>1.4.&nbsp;Playing with cats</h2></div></div><div></div></div><p>
            We're now ready to start Hibernate's <tt class="literal">Session</tt>. It is the
            <span class="emphasis"><em>persistence manager</em></span>, we use it to store and retrieve
            <tt class="literal">Cat</tt>s to and from the database. But first, we've to get a
            <tt class="literal">Session</tt> (Hibernate's unit-of-work) from the
            <tt class="literal">SessionFactory</tt>:
        </p><pre class="programlisting">SessionFactory sessionFactory =
            new Configuration().configure().buildSessionFactory();</pre><p>
            The call to <tt class="literal">configure()</tt> loads the <tt class="literal">hibernate.cfg.xml</tt>
            configuration file and initializes the <tt class="literal">Configuration</tt> instance.
			You can set other properties (and even change the mapping metadata) by
			accessing the <tt class="literal">Configuration</tt> <span class="emphasis"><em>before</em></span>
			you build the <tt class="literal">SessionFactory</tt> (it is immutable). Where
			do we create the <tt class="literal">SessionFactory</tt> and how can we access
			it in our application?
        </p><p>
			A <tt class="literal">SessionFactory</tt> is usually only build once,
			e.g. at startup with a <span class="emphasis"><em>load-on-startup</em></span> servlet.
            This also means you should not keep it in an instance variable in your
            servlets, but in some other location. Furthermore, we need some kind of
            <span class="emphasis"><em>Singleton</em></span>, so we can access the
            <tt class="literal">SessionFactory</tt> easily in application code. The approach
            shown next solves both problems: startup configuration and easy access to a
            <tt class="literal">SessionFactory</tt>.
		</p><p>
		    We implement a <tt class="literal">HibernateUtil</tt> helper class:
		</p><pre class="programlisting">import org.hibernate.*;
import org.hibernate.cfg.*;

public class HibernateUtil {

    private static Log log = LogFactory.getLog(HibernateUtil.class);

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Create the SessionFactory
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            log.error("Initial SessionFactory creation failed.", ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static final ThreadLocal session = new ThreadLocal();

    public static Session currentSession() {
        Session s = (Session) session.get();
        // Open a new Session, if this Thread has none yet
        if (s == null) {
            s = sessionFactory.openSession();
            session.set(s);
        }
        return s;
    }

    public static void closeSession() {
        Session s = (Session) session.get();
        if (s != null)
            s.close();
        session.set(null);
    }
}</pre><p>
			This class does not only take care of the <tt class="literal">SessionFactory</tt>
			with its static initializer, but also has a <tt class="literal">ThreadLocal</tt>
            variable which holds the <tt class="literal">Session</tt> for the current thread.
            Make sure you understand the Java concept of a thread-local variable before you
			try to use this helper. A more complex and powerful <tt class="literal">HibernateUtil</tt>
            class can be found in <tt class="literal">CaveatEmptor</tt>, http://caveatemptor.hibernate.org/
		</p><p>
            A <tt class="literal">SessionFactory</tt> is threadsafe, many threads can access
            it concurrently and request <tt class="literal">Session</tt>s. A <tt class="literal">Session</tt>
            is a non-threadsafe object that represents a single unit-of-work with the database.
            <tt class="literal">Session</tt>s are opened from a <tt class="literal">SessionFactory</tt> and
            are closed when all work is completed. An example in your servlet's
            <tt class="literal">process()</tt> method might look like this (sans exception handling):
        </p><pre class="programlisting">Session session = HibernateUtil.currentSession();
Transaction tx = session.beginTransaction();

Cat princess = new Cat();
princess.setName("Princess");
princess.setSex('F');
princess.setWeight(7.4f);

session.save(princess);

tx.commit();
HibernateUtil.closeSession();</pre><p>
            In a <tt class="literal">Session</tt>, every database operation occurs inside a
            transaction that isolates the database operations (even read-only operations).
            We use Hibernates <tt class="literal">Transaction</tt> API to abstract from the underlying
            transaction strategy (in our case, JDBC transactions). This allows our code
            to be deployed with container-managed transactions (using JTA) without any changes.
        </p><p>
			Note that you may call <tt class="literal">HibernateUtil.currentSession();</tt>
			as many times as you like, you will always get the current <tt class="literal">Session</tt>
			of this thread. You have to make sure the <tt class="literal">Session</tt> is closed
			after your unit-of-work completes, either in your servlet code or in a servlet filter
			before the HTTP response is send. The nice side effect of the second option is easy
			lazy initialization: the <tt class="literal">Session</tt> is still open when the view is
			rendered, so Hibernate can load unitialized objects while you navigate the current
            object graph.
        </p><p>
            Hibernate has various methods that can be used to retrieve objects from the
            database. The most flexible way is using the Hibernate Query Language (HQL),
            which is an easy to learn and powerful object-oriented extension to SQL:
        </p><pre class="programlisting">Transaction tx = session.beginTransaction();

Query query = session.createQuery("select c from Cat as c where c.sex = :sex");
query.setCharacter("sex", 'F');
for (Iterator it = query.iterate(); it.hasNext();) {
    Cat cat = (Cat) it.next();
    out.println("Female Cat: " + cat.getName() );
}

tx.commit();</pre><p>
            Hibernate also offers an object-oriented <span class="emphasis"><em>query by criteria</em></span> API
            that can be used to formulate type-safe queries. Hibernate of course uses
            <tt class="literal">PreparedStatement</tt>s and parameter binding for all SQL communication
            with the database. You may also use Hibernate's direct SQL query feature or
            get a plain JDBC connection from a <tt class="literal">Session</tt> in rare cases.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-summary"></a>1.5.&nbsp;Finally</h2></div></div><div></div></div><p>
            We only scratched the surface of Hibernate in this small tutorial. Please note that
            we don't include any servlet specific code in our examples. You have to create a
            servlet yourself and insert the Hibernate code as you see fit.
        </p><p>
			Keep in mind that Hibernate, as a data access layer, is tightly integrated into
			your application. Usually, all other layers depent on the persistence mechanism.
			Make sure you understand the implications of this design.
        </p><p>
            For a more complex application example, see http://caveatemptor.hibernate.org/ and
            have a look at other tutorials linked on http://www.hibernate.org/Documentation
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Overview</h2></div></div><div></div></div><p>
            A (very) high-level view of the Hibernate architecture:
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.gif" align="middle"></div><p>
            This diagram shows Hibernate using the database and configuration data to
            provide persistence services (and persistent objects) to the application.
        </p><p>
            We would like to show a more detailed view of the runtime architecture.
            Unfortunately, Hibernate is flexible and supports several approaches. We will
            show the two extremes. The "lite" architecture has the application
            provide its own JDBC connections and manage its own transactions. This approach
            uses a minimal subset of Hibernate's APIs:
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.gif" align="middle"></div><p>
            The "full cream" architecture abstracts the application away from the
            underlying JDBC/JTA APIs and lets Hibernate take care of the details.
        </p><div class="mediaobject" align="center"><img src="../shared/images/full_cream.gif" align="middle"></div><p>
            Heres some definitions of the objects in the diagrams:

            </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<tt class="literal">org.hibernate.SessionFactory</tt>)</span></dt><dd><p>
                            A threadsafe (immutable) cache of compiled mappings for a single database.
                            A factory for <tt class="literal">Session</tt> and a client of
                            <tt class="literal">ConnectionProvider</tt>. Might hold an optional (second-level)
                            cache of data that is reusable between transactions, at a
                            process- or cluster-level.
                        </p></dd><dt><span class="term">Session (<tt class="literal">org.hibernate.Session</tt>)</span></dt><dd><p>
                            A single-threaded, short-lived object representing a conversation between
                            the application and the persistent store. Wraps a JDBC connection. Factory
                            for <tt class="literal">Transaction</tt>. Holds a mandatory (first-level) cache
                            of persistent objects, used when navigating the object graph or looking up
                            objects by identifier.
                        </p></dd><dt><span class="term">Persistent objects and collections</span></dt><dd><p>
                            Short-lived, single threaded objects containing persistent state and business
                            function. These might be ordinary JavaBeans/POJOs, the only special thing about
                            them is that they are currently associated with (exactly one)
                            <tt class="literal">Session</tt>. As soon as the <tt class="literal">Session</tt> is closed,
                            they will be detached and free to use in any application layer (e.g. directly
                            as data transfer objects to and from presentation).
                        </p></dd><dt><span class="term">Transient and detached objects and collections</span></dt><dd><p>
                            Instances of persistent classes that are not currently associated with a
                            <tt class="literal">Session</tt>. They may have been instantiated by
                            the application and not (yet) persisted or they may have been instantiated by a
                            closed <tt class="literal">Session</tt>.
                        </p></dd><dt><span class="term">Transaction (<tt class="literal">org.hibernate.Transaction</tt>)</span></dt><dd><p>
                            (Optional) A single-threaded, short-lived object used by the application to
                            specify atomic units of work. Abstracts application from underlying JDBC,
                            JTA or CORBA transaction. A <tt class="literal">Session</tt> might span several
                            <tt class="literal">Transaction</tt>s in some cases. However, transaction demarcation,
                            either using the underlying API or <tt class="literal">Transaction</tt>, is never
                            optional!
                        </p></dd><dt><span class="term">ConnectionProvider (<tt class="literal">org.hibernate.connection.ConnectionProvider</tt>)</span></dt><dd><p>
                            (Optional) A factory for (and pool of) JDBC connections. Abstracts application from
                            underlying <tt class="literal">Datasource</tt> or <tt class="literal">DriverManager</tt>.
                            Not exposed to application, but can be extended/implemented by the developer.
                        </p></dd><dt><span class="term">TransactionFactory (<tt class="literal">org.hibernate.TransactionFactory</tt>)</span></dt><dd><p>
                            (Optional) A factory for <tt class="literal">Transaction</tt> instances. Not exposed to the
                            application, but can be extended/implemented by the developer.
                        </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>
                            Hibernate offers many optional extension interfaces you can implement to customize
                            the behavior of your persistence layer. See the API documentation for details.
                        </p></dd></dl></div><p>
        </p><p>
            Given a "lite" architecture, the application bypasses the
            <tt class="literal">Transaction</tt>/<tt class="literal">TransactionFactory</tt> and/or
            <tt class="literal">ConnectionProvider</tt> APIs to talk to JTA or JDBC directly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-states"></a>2.2.&nbsp;Instance states</h2></div></div><div></div></div><p>
            An instance of a persistent classes may be in one of three different states,
            which are defined with respect to a <span class="emphasis"><em>persistence context</em></span>.
            The Hibernate <tt class="literal">Session</tt> object is the persistence context:
        </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>
                        The instance is not, and has never been associated with
                        any persistence context. It has no persistent identity
                        (primary key value).
                    </p></dd><dt><span class="term">persistent</span></dt><dd><p>
                        The instance is currently associated with a persistence 
                        context. It has a persistent identity (primary key value)
                        and, perhaps, a corresponding row in the database. For a
                        particular persistence context, Hibernate 
                        <span class="emphasis"><em>guarantees</em></span> that persistent identity
                        is equivalent to Java identity (in-memory location of the
                        object).
                    </p></dd><dt><span class="term">detached</span></dt><dd><p>
                        The instance was once associated with a persistence
                        context, but that context was closed, or the instance
                        was serialized to another process. It has a persistent 
                        identity and, perhaps, a corrsponding row in the database.
                        For detached instances, Hibernate makes no guarantees 
                        about the relationship between persistent identity and
                        Java identity.
                    </p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jmx"></a>2.3.&nbsp;JMX Integration</h2></div></div><div></div></div><p>
            JMX is the J2EE standard for management of Java components. Hibernate may be managed via
            a JMX standard service. We provide an MBean implementation in the distribution,
            <tt class="literal">org.hibernate.jmx.HibernateService</tt>.
        </p><p>
            For an example how to deploy Hibernate as a JMX service on the JBoss Application Server,
            please see the JBoss User Guide. On JBoss AS, you also get these benefits if you deploy
            using JMX:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Session Management:</em></span> The Hibernate <tt class="literal">Session</tt>'s lifecycle
                    can be automatically bound to the scope of a JTA transaction. This means you no
                    longer have to manually open and close the <tt class="literal">Session</tt>, this
                    becomes the job of a JBoss EJB interceptor. You also don't have to worry about
                    transaction demarcation in your code anymore (unless you'd like to write a portable
                    persistence layer of course, use the optional Hibernate <tt class="literal">Transaction</tt>
                    API for this). You call the <tt class="literal">HibernateContext</tt> to access a
                    <tt class="literal">Session</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>HAR deployment:</em></span> Usually you deploy the Hibernate JMX service using a JBoss
                    service deployment descriptor (in an EAR and/or SAR file), it supports all the usual
                    configuration options of a Hibernate <tt class="literal">SessionFactory</tt>. However, you still
                    have to name all your mapping files in the deployment descriptor. If you decide to use
                    the optional HAR deployment, JBoss will automatically detect all mapping files in your
                    HAR file.
                </p></li></ul></div><p>
            Consult the JBoss AS user guide for more information about these options.
        </p><p>
            Another feature available as a JMX service are runtime Hibernate statistics. See
            <a href="#configuration-optional-statistics" title="3.4.8.&nbsp;Hibernate statistics">Section&nbsp;3.4.8, &#8220;Hibernate statistics&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jca"></a>2.4.&nbsp;JCA Support</h2></div></div><div></div></div><p>
            Hibernate may also be configured as a JCA connector. Please see the website for more
            details. Please note that Hibernate JCA support is still considered experimental.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;Configuration</h2></div></div><div></div></div><p>
        Because Hibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and Hibernate is distributed with an example 
        <tt class="literal">hibernate.properties</tt> file in <tt class="literal">etc/</tt> that shows
        the various options. Just put the example file in your classpath and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">org.hibernate.cfg.Configuration</tt>
            represents an entire set of mappings of an application's Java types to an
            SQL database. The <tt class="literal">Configuration</tt> is used to build an
            (immutable) <tt class="literal">SessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by instantiating 
            it directly and specifying XML mapping documents. If the mapping files are
            in the classpath, use <tt class="literal">addResource()</tt>:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to specify the mapped class, and
            let Hibernate find the mapping document for you:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Then Hibernate will look for mapping files named
            <tt class="literal">/org/hibernate/auction/Item.hbm.xml</tt> and
            <tt class="literal">/org/hibernate/auction/Bid.hbm.xml</tt> in the classpath.
            This approach eliminates any hardcoded filenames.
        </p><p>
            A <tt class="literal">Configuration</tt> also allows you to specify configuration
            properties:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>
            This is not the only way to pass configuration properties to Hibernate. 
            The various options include:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">java.util.Properties</tt> to
                    <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Place <tt class="literal">hibernate.properties</tt> in a root directory 
                    of the classpath.
                </p></li><li><p>
                    Set <tt class="literal">System</tt> properties using
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            <tt class="literal">hibernate.properties</tt> is the easiest approach if you
            want to get started quickly.
        </p><p>
            The <tt class="literal">Configuration</tt> is intended as a startup-time object, 
            to be discarded once a <tt class="literal">SessionFactory</tt> is created.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining a SessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, 
            the application must obtain a factory for <tt class="literal">Session</tt> instances. 
            This factory is intended to be shared by all application threads:
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            Hibernate does allow your application to instantiate more than one
            <tt class="literal">SessionFactory</tt>. This is useful if you are using more than 
            one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.3.&nbsp;JDBC connections</h2></div></div><div></div></div><p>
            Usually, you want to have the <tt class="literal">SessionFactory</tt> create and pool JDBC 
            connections for you. If you take this approach, opening a <tt class="literal">Session</tt> 
            is as simple as:
        </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>
            As soon as you do something that requires access to the database, a JDBC connection
            will be obtained from the pool.
        </p><p>
            For this to work, we need to pass some JDBC connection properties to Hibernate.
            All Hibernate property names and semantics are defined on the class 
            <tt class="literal">org.hibernate.cfg.Environment</tt>. We will now describe the most
            important settings for JDBC connection configuration.
        </p><p>
            Hibernate will obtain (and pool) connections using <tt class="literal">java.sql.DriverManager</tt> 
            if you set the following properties:
        </p><div class="table"><a name="d0e850"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Hibernate JDBC Properties</b></p><table summary="Hibernate JDBC Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>jdbc driver class</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>jdbc URL</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div><p>
            Hibernate's own connection pooling algorithm is however quite rudimentary. 
            It is intended to help you get started and is <span class="emphasis"><em>not intended for use 
            in a production system</em></span> or even for performance testing. You should
            use a third party pool for best performance and stability. Just replace the 
            <tt class="literal">hibernate.connection.pool_size</tt> property with connection 
            pool specific settings. This will turn off Hibernate's internal pool. For
            example, you might like to use C3P0.
        </p><p>
            C3P0 is an open source JDBC connection pool distributed along with 
            Hibernate in the <tt class="literal">lib</tt> directory. Hibernate will use its
            <tt class="literal">C3P0ConnectionProvider</tt> for connection pooling if you set 
            <tt class="literal">hibernate.c3p0.*</tt> properties. If you'd like to use Proxool
            refer to the packaged <tt class="literal">hibernate.properties</tt> and the Hibernate
            web site for more information.
        </p><p>
            Here is an example <tt class="literal">hibernate.properties</tt> file for C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            For use inside an application server, you should almost always configure 
            Hibernate to obtain connections from an application server  
            <tt class="literal">Datasource</tt> registered in JNDI. You'll need to set at
            least one of the following properties:
        </p><div class="table"><a name="d0e932"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Hibernate Datasource Properties</b></p><table summary="Hibernate Datasource Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Propery name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>datasource JNDI name</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>class of the JNDI <tt class="literal">InitialContextFactory</tt></em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span> (optional)
                </td></tr></tbody></table></div><p>
            Here's an example <tt class="literal">hibernate.properties</tt> file for an
            application server provided JNDI datasource:
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            JDBC connections obtained from a JNDI datasource will automatically participate
            in the container-managed transactions of the application server.
        </p><p>
            Arbitrary connection properties may be given by prepending
            "<tt class="literal">hibernate.connnection</tt>" to the property name. For example, you
            may specify a <tt class="literal">charSet</tt> using <tt class="literal">hibernate.connection.charSet</tt>.
        </p><p>
            You may define your own plugin strategy for obtaining JDBC connections by implementing the
            interface <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.4.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of Hibernate
            at runtime. All are optional and have reasonable default values.
        </p><p>
        	<span class="emphasis"><em>Warning: some of these properties are "system-level" only.</em></span>
            System-level properties can be set only via <tt class="literal">java -Dproperty=value</tt> or
            <tt class="literal">hibernate.properties</tt>. They may <span class="emphasis"><em>not</em></span> be set by
            the other techniques described above.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties</b></p><table summary="Hibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            The classname of a Hibernate <tt class="literal">Dialect</tt> which 
                            allows Hibernate to generate SQL optimized for a particular
                            relational database.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Write all SQL statements to console.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Qualify unqualified tablenames with the given schema/tablespace
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_catalog</tt></td><td>
                            Qualify unqualified tablenames with the given catalog
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">CATALOG_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            The <tt class="literal">SessionFactory</tt> will be automatically
                            bound to this name in JNDI after it has been created.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and 
                                <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_batch_fetch_size</tt></td><td>
                            Set a default size for Hibernate batch fetching of associations.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values <tt class="literal">4</tt>, <tt class="literal">8</tt>, 
                                <tt class="literal">16</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_entity_mode</tt></td><td>
                            Set a default mode for entity representation for all sessions
                            opened from this <tt class="literal">SessionFactory</tt><p>
                                <tt class="literal">dynamic-map</tt>, <tt class="literal">dom4j</tt>,
                                <tt class="literal">pojo</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.order_updates</tt></td><td>
                            Force Hibernate to order SQL updates by the primary key value
                            of the items being updates. This will result in fewer transaction
                            deadlocks in highly concurrent systems.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.generate_statistics</tt></td><td>
                            If enabled, Hibernate will collect statistics useful for
                            performance tuning.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_identifer_rollback</tt></td><td>
                            If enabled, generated identifier properties will be
                            reset to default values when objects are deleted.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_sql_comments</tt></td><td>
                            If turned on, Hibernate will generate comments inside the SQL, for
                            easier debugging, defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-jdbc-properties"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Hibernate JDBC and Connection Properties</b></p><table summary="Hibernate JDBC and Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            A non-zero value determines the JDBC fetch size (calls
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            A non-zero value enables use of JDBC2 batch updates by Hibernate.
                            <p>
                                <span class="strong">eg.</span>
                                recommended values between <tt class="literal">5</tt> and <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Set this property to <tt class="literal">true</tt> if your JDBC driver returns
                            correct row counts from <tt class="literal">executeBatch()</tt> (it is usually
                            safe to turn this option on). Hibernate will then use batched DML for
                            automatically versioned data. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.factory_class</tt></td><td>
                            Select a custom <tt class="literal">Batcher</tt>. Most applications
                            will not need this configuration property.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.Batcher</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Enables use of JDBC2 scrollable resultsets by Hibernate.
                            This property is only necessary when using user supplied
                            JDBC connections, Hibernate uses connection metadata otherwise.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Use streams when writing/reading <tt class="literal">binary</tt>
                            or <tt class="literal">serializable</tt> types to/from JDBC
                            (system-level property).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Enable use of JDBC3 <tt class="literal">PreparedStatement.getGeneratedKeys()</tt>
                            to retrieve natively generated keys after insert. Requires JDBC3+ driver
                            and JRE1.4+, set to false if your driver has problems with the Hibernate
                            identifier generators. By default, tries to determine the driver capabilites
                            using connection metadata.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">ConnectionProvider</tt> which provides
                            JDBC connections to Hibernate.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Set the JDBC transaction isolation level. Check
                        <tt class="literal">java.sql.Connection</tt> for meaningful values but
                        note that most databases do not support all isolation levels.
                        <p>
                            <span class="strong">eg.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.autocommit</tt></td><td>
                            Enables autocommit for JDBC pooled connections (not recommended).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Pass the JDBC property <tt class="literal">propertyName</tt>
                        to <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Pass the property <tt class="literal">propertyName</tt> to
                            the JNDI <tt class="literal">InitialContextFactory</tt>.
                        </td></tr></tbody></table></div><div class="table"><a name="configuration-cache-properties"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Hibernate Cache Properties</b></p><table summary="Hibernate Cache Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">CacheProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads. This setting is most useful for 
                            clustered caches and, in Hibernate3, is enabled by default for
                            clustered cache implementations.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cachable.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_second_level_cache</tt></td><td>
                            May be used to completely disable the second level cache, which is enabled
                            by default for classes which specify a <tt class="literal">&lt;cache&gt;</tt>
                            mapping.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            The classname of a custom <tt class="literal">QueryCache</tt> interface,
                            defaults to the built-in <tt class="literal">StandardQueryCache</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCache</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_structured_entries</tt></td><td>
                            Forces Hibernate to store data in the second-level cache
                            in a more human-friendly format.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-transaction-properties"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Hibernate Transaction Properties</b></p><table summary="Hibernate Transaction Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionFactory</tt>
                            to use with Hibernate <tt class="literal">Transaction</tt> API
                            (defaults to <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            A JNDI name used by <tt class="literal">JTATransactionFactory</tt> to
                            obtain the JTA <tt class="literal">UserTransaction</tt> from the
                            application server.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionManagerLookup</tt>
                            - required when JVM-level caching is enabled or when using hilo 
                            generator in a JTA environment.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.flush_before_completion</tt></td><td>
                            If enabled, the session will be automatically flushed during the
                            before completion phase of the transaction. (Very useful when
                            using Hibernate with CMT.)
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.auto_close_session</tt></td><td>
                            If enabled, the session will be automatically closed during the
                            before completion phase of the transaction. (Very useful when
                            using Hibernate with CMT.)
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-misc-properties"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;Miscellaneous Properties</b></p><table summary="Miscellaneous Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.query.factory_class</tt></td><td>
                            Chooses the HQL parser implementation.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</tt> or
                                <tt class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Mapping from tokens in Hibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Automatically export schema DDL to the database when the
                            <tt class="literal">SessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema
                            will be dropped when the <tt class="literal">SessionFactory</tt>
                            is closed explicitly.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">update</tt> | <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Enables use of CGLIB instead of runtime reflection (System-level
                            property). Reflection can sometimes be useful when troubleshooting,
                            note that Hibernate always requires CGLIB even if you turn off the
                            optimizer. You can not set this property in <tt class="literal">hibernate.cfg.xml</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.4.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">hibernate.dialect</tt> property to the correct
                <tt class="literal">org.hibernate.dialect.Dialect</tt> subclass for your database. If you
                specify a dialect, Hibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.8.&nbsp;Hibernate SQL Dialects (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">org.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">org.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">org.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">org.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">org.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>MySQL with InnoDB</td><td><tt class="literal">org.hibernate.dialect.MySQLInnoDBDialect</tt></td></tr><tr><td>MySQL with MyISAM</td><td><tt class="literal">org.hibernate.dialect.MySQLMyISAMDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">org.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9i/10g</td><td><tt class="literal">org.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">org.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">org.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">org.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">org.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">org.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">org.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">org.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">org.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">org.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">org.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">org.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">org.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">org.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.4.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> will often increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a whole graph of objects connected
                by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved 
                in a single SQL <tt class="literal">SELECT</tt>.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">hibernate.max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                one-to-one and many-to-one associations which have been mapped with 
                <tt class="literal">fetch="join"</tt>.
            </p><p>
                See <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.4.3.&nbsp;Binary Streams</h3></div></div><div></div></div><p>
                Oracle limits the size of <tt class="literal">byte</tt> arrays that may
                be passed to/from its JDBC driver. If you wish to use large instances of
                <tt class="literal">binary</tt> or <tt class="literal">serializable</tt> type, you should
                enable <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>.
                <span class="emphasis"><em>This is a system-level setting only.</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.4.4.&nbsp;Second-level and query cache</h3></div></div><div></div></div><p>
                The properties prefixed by <tt class="literal">hibernate.cache</tt>
                allow you to use a process or cluster scoped second-level cache system
                with Hibernate. See the <a href="#performance-cache" title="19.2.&nbsp;The Second Level Cache">Section&nbsp;19.2, &#8220;The Second Level Cache&#8221;</a> for
                more details.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.4.5.&nbsp;Transaction strategy configuration</h3></div></div><div></div></div><p>
                If you wish to use the Hibernate <tt class="literal">Transaction</tt> API instead
                of directly calling a particular system transaction API, you must
                specify a factory class for <tt class="literal">Transaction</tt> instances by
                setting the property <tt class="literal">hibernate.transaction.factory_class</tt>.
                The <tt class="literal">Transaction</tt> API hides the underlying transaction
                mechanism and allows Hibernate code to run in managed and non-managed environments.
            </p><p>
                There are two standard (built-in) choices:
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>delegates to database (JDBC) transactions (default)</p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>delegates to JTA (if an existing transaction is underway, the <tt class="literal">Session</tt>
                        performs its work in that context, otherwise a new transaction is started)</p></dd></dl></div><p>
                You may also define your own transaction strategies (for a CORBA transaction service,
                for example).
            </p><p>
                Some features in Hibernate (i.e. the second level cache) require access to the
                JTA <tt class="literal">TransactionManager</tt> in a management environment. You have to
                specify how Hibernate should obtain a reference to the <tt class="literal">TransactionManager</tt>,
                since J2EE does not standardize a single mechanism:
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Table&nbsp;3.9.&nbsp;JTA TransactionManagers</b></p><table summary="JTA TransactionManagers" border="1"><colgroup><col><col></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">org.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.4.6.&nbsp;JNDI-bound <tt class="literal">SessionFactory</tt></h3></div></div><div></div></div><p>
                A JNDI bound Hibernate <tt class="literal">SessionFactory</tt> can simplify the lookup
                of the factory and the creation of new <tt class="literal">Session</tt>s. Note that this
                is not related to a JNDI bound <tt class="literal">Datasource</tt> in a managed environment.
            </p><p>
                If you wish to have the <tt class="literal">SessionFactory</tt> bound to a JNDI namespace, specify
                a name (eg. <tt class="literal">java:hibernate/SessionFactory</tt>) using the property
                <tt class="literal">hibernate.session_factory_name</tt>. If this property is omitted, the 
                <tt class="literal">SessionFactory</tt> will not be bound to JNDI. (This is especially useful in 
                environments with a read-only JNDI default implementation, eg. Tomcat.)
            </p><p>
                When binding the <tt class="literal">SessionFactory</tt> to JNDI, Hibernate will use the values of
                <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt> to instantiate 
                an initial context. If they are not specified, the default <tt class="literal">InitialContext</tt>
                will be used.
            </p><p>
                Hibernate will automatically place the <tt class="literal">SessionFactory</tt> in JNDI after
                you call <tt class="literal">cfg.buildSessionFactory()</tt>. This means you will at least have
                this call in some startup code (or utility class) in your application, unless you use
                JMX deployment with the <tt class="literal">HibernateService</tt>.
            </p><p>
                If you use a JNDI <tt class="literal">SessionFactory</tt>, an EJB or any other class may
                obtain the  <tt class="literal">SessionFactory</tt> using a JNDI lookup. Note that this
                setup is not neccessary if you use the <tt class="literal">HibernateUtil</tt> helper class
                introduced in chapter 1, which acts as a Singleton registry.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.4.7.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new Hibernate query tokens using <tt class="literal">hibernate.query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-statistics"></a>3.4.8.&nbsp;Hibernate statistics</h3></div></div><div></div></div><p>
                If you enable <tt class="literal">hibernate.generate_statistics</tt>, Hibernate will 
                expose a number of metrics that are useful when tuning a running system via
                <tt class="literal">SessionFactory.getStatistics()</tt>. Hibernate can even be configured
                to expose these statistics via JMX. Read the Javadoc of the interfaces in
                <tt class="literal">org.hibernate.stats</tt> for more information.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.5.&nbsp;Logging</h2></div></div><div></div></div><p>
            Hibernate logs various events using Apache commons-logging.
        </p><p>
            The commons-logging service will direct output to either Apache Log4j
            (if you include <tt class="literal">log4j.jar</tt> in your classpath) or
            JDK1.4 logging (if running under JDK1.4 or above). You may download
            Log4j from <tt class="literal">http://jakarta.apache.org</tt>.
            To use Log4j you will need to place a <tt class="literal">log4j.properties</tt>
            file in your classpath, an example properties file is distributed with
            Hibernate in the <tt class="literal">src/</tt> directory.
        </p><p>
            We strongly recommend that you familiarize yourself with Hibernate's log
            messages. A lot of work has been put into making the Hibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. The most interesting log categories are the
            following:
        </p><div class="table"><a name="log-categories"></a><p class="title"><b>Table&nbsp;3.10.&nbsp;Hibernate Log Categories</b></p><table summary="Hibernate Log Categories" border="1"><colgroup><col><col></colgroup><thead><tr><th>Category</th><th>Function</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.SQL</tt></td><td>Log all SQL DML statements as they are executed</td></tr><tr><td><tt class="literal">org.hibernate.type</tt></td><td>Log all JDBC parameters</td></tr><tr><td><tt class="literal">org.hibernate.tool.hbm2ddl</tt></td><td>Log all SQL DDL statements as they are executed</td></tr><tr><td><tt class="literal">org.hibernate.pretty</tt></td><td>
                                Log the state of all entities (max 20 entities) associated
                                with the session at flush time
                            </td></tr><tr><td><tt class="literal">org.hibernate.cache</tt></td><td>Log all second-level cache activity</td></tr><tr><td><tt class="literal">org.hibernate.transaction</tt></td><td>Log transaction related activity</td></tr><tr><td><tt class="literal">org.hibernate.jdbc</tt></td><td>Log all JDBC resource acquisition</td></tr><tr><td><tt class="literal">org.hibernate.secure</tt></td><td>Log all JAAS authorization requests</td></tr><tr><td><tt class="literal">org.hibernate</tt></td><td>
                                Log everything (a lot of information, but very useful for
                                troubleshooting)
                            </td></tr></tbody></table></div><p>
            When developing applications with Hibernate, you should almost always work with
            <tt class="literal">debug</tt> enabled for the category <tt class="literal">org.hibernate.SQL</tt>,
            or, alternatively, the property <tt class="literal">hibernate.show_sql</tt> enabled.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.6.&nbsp;Implementing a <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">org.hibernate.cfg.NamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            Java identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            Hibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.setNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">org.hibernate.cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.7.&nbsp;XML configuration file</h2></div></div><div></div></div><p>
            An alternative approach to configuration is to specify a full configuration in
            a file named <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a
            replacement for the <tt class="literal">hibernate.properties</tt> file or, if both
            are present, to override properties.
        </p><p>
            The XML configuration file is by default expected to be in the root o
            your <tt class="literal">CLASSPATH</tt>. Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache class="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
            As you can see, the advantage of this approach is the externalization of the
            mapping file names to configuration. The <tt class="literal">hibernate.cfg.xml</tt>
            is also more convenient once you have to tune the Hibernate cache. Note that is
            your choice to use either <tt class="literal">hibernate.properties</tt> or
            <tt class="literal">hibernate.cfg.xml</tt>, both are equivalent, except for the above
            mentioned benefits of using the XML syntax.
        </p><p>
           With the XML configuration, starting Hibernate is then as simple as
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapter&nbsp;4.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
        Persistent classes are classes in an application that implement the entities
        of the business problem (e.g. Customer and Order in an E-commerce application).
        Not all instances of a persistent class are considered to be in the persistent 
        state - an instance may instead be transient or detached.
    </p><p>
        Hibernate works best if these classes follow some simple rules, also known
        as the Plain Old Java Object (POJO) programming model. However none of these
        rules are hard requirements. Indeed, Hibernate3 assumes very little about
        the nature of your persistent objects. You may express a domain model in other 
        ways: using trees of <tt class="literal">Map</tt> instances, for example.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-pojo"></a>4.1.&nbsp;A simple POJO example</h2></div></div><div></div></div><p>
            Most Java applications require a persistent class representing felines.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
    	kitten.setMother(this);
	kitten.setLitterId( kittens.size() ); 
        kittens.add(kitten);
    }
}</pre><p>
            There are four main rules to follow here:
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-accessors"></a>4.1.1.&nbsp;Declare accessors and mutators for persistent fields</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> declares accessor methods for all its persistent fields.
                Many other ORM tools directly persist instance variables. We believe 
                it is far better to decouple this implementation detail from the persistence 
                mechanism. Hibernate persists JavaBeans style properties, and recognizes method 
                names of the form <tt class="literal">getFoo</tt>, <tt class="literal">isFoo</tt> and
                <tt class="literal">setFoo</tt>. You may however switch to direct field access for
                particular properties, if needed.
            </p><p>
                Properties need <span class="emphasis"><em>not</em></span> be declared public - Hibernate can
                persist a property with a default, <tt class="literal">protected</tt> or <tt class="literal">
                private</tt> get / set pair.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-constructor"></a>4.1.2.&nbsp;Implement a no-argument constructor</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a no-argument constructor. All
                persistent classes must have a default constructor (which may be non-public) so 
                Hibernate can instantiate them using <tt class="literal">Constructor.newInstance()</tt>.
                We recommend having a constructor with at least <span class="emphasis"><em>package</em></span> 
                visibility for runtime proxy generation in Hibernate.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-identifier"></a>4.1.3.&nbsp;Provide an identifier property (optional)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a property called <tt class="literal">id</tt>. This property 
                maps to the primary key column of a database table. The property might have been called
                anything, and its type might have been any primitive type, any primitive "wrapper" 
                type, <tt class="literal">java.lang.String</tt> or <tt class="literal">java.util.Date</tt>. (If 
                your legacy database table has composite keys, you can even use a user-defined class 
                with properties of these types - see the section on composite identifiers later.)
            </p><p>
                The identifier property is strictly optional. You can leave them off and let Hibernate 
                keep track of object identifiers internally. We do not recommend this, however.
            </p><p>
                In fact, some functionality is available only to classes which declare an
                identifier property:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Transitive reattachment for detached objects (cascade update or cascade
                        merge) - see <a href="#objectstate-transitive" title="10.11.&nbsp;Transitive persistence">Section&nbsp;10.11, &#8220;Transitive persistence&#8221;</a>
                    </p></li><li><p>
                        <tt class="literal">Session.saveOrUpdate()</tt>
                    </p></li><li><p>
                        <tt class="literal">Session.merge()</tt>
                    </p></li></ul></div><p>
                We recommend you declare consistently-named identifier properties on persistent
                classes. We further recommend that you use a nullable (ie. non-primitive) type.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-final"></a>4.1.4.&nbsp;Prefer non-final classes (optional)</h3></div></div><div></div></div><p>
                A central feature of Hibernate, <span class="emphasis"><em>proxies</em></span>, depends upon the
                persistent class being either non-final, or the implementation of an interface
                that declares all public methods.
            </p><p>
                You can persist <tt class="literal">final</tt> classes that do not implement an interface
                with Hibernate, but you won't be able to use proxies for lazy association fetching -
                which will limit your options for performance tuning.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Implementing inheritance</h2></div></div><div></div></div><p>
            A subclass must also observe the first and second rules. It inherits its
            identifier property from the superclass, <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Implementing <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt></h2></div></div><div></div></div><p>
            You have to override the <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            methods if you 
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    intend to put instances of persistent classes in a <tt class="literal">Set</tt>
                    (the recommended way to represent many-valued associations) 
                    <span class="emphasis"><em>and</em></span>
                </p></li><li><p>
                    intend to use reattachment of detached instances
                </p></li></ul></div><p>
            Hibernate guarantees equivalence of persistent identity (database row) and Java identity
            only inside a particular session scope. So as soon as we mix instances retrieved in
            different sessions, we must implement <tt class="literal">equals()</tt> and
            <tt class="literal">hashCode()</tt> if we wish to have meaningful semantics for
            <tt class="literal">Set</tt>s.
        </p><p>
            The most obvious way is to implement <tt class="literal">equals()</tt>/<tt class="literal">hashCode()</tt>
            by comparing the identifier value of both objects. If the value is the same, both must
            be the same database row, they are therefore equal (if both are added to a <tt class="literal">Set</tt>,
            we will only have one element in the <tt class="literal">Set</tt>). Unfortunately, we can't use that
            approach with generated identifiers! Hibernate will only assign identifier values to objects 
            that are persistent, a newly created instance will not have any identifier value! Furthermore,
            if an instance is unsaved and currently in a <tt class="literal">Set</tt>, saving it will assign
            an identifier value to the object. If <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            are based on the identifier value, the hash code would change, breaking the contract of the
            <tt class="literal">Set</tt>. See the Hibernate website for a full discussion of this problem. Note
            that this is not a Hibernate issue, but normal Java semantics of object identity and equality.
        </p><p>
            We recommend  implementing <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            using <span class="emphasis"><em>Business key equality</em></span>. Business key equality means that the
            <tt class="literal">equals()</tt> method compares only the properties that form the business
            key, a key that would identify our instance in the real world (a
            <span class="emphasis"><em>natural</em></span> candidate key):
        </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>
            Note that a business key does not have to be as solid as a database
            primary key candidate (see <a href="#transactions-basics-identity" title="11.1.3.&nbsp;Considering object identity">Section&nbsp;11.1.3, &#8220;Considering object identity&#8221;</a>).
            Immutable or unique properties are usually good
            candidates for a business key.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-dynamicmodels"></a>4.4.&nbsp;Dynamic models</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Note that the following features are currently considered
            experimental and may change in the near future.</em></span>
        </p><p>
            Persistent entities don't necessarily have to be represented as POJO classes
            or as JavaBean objects at runtime. Hibernate also supports dynamic models
            (using <tt class="literal">Map</tt>s of <tt class="literal">Map</tt>s at runtime) and the
            representation of entities as DOM4J trees. With this approach, you don't
            write persistent classes, only mapping files.
        </p><p>
            By default, Hibernate works in normal POJO mode. You may set a default entity
            representation mode for a particular <tt class="literal">SessionFactory</tt> using the
            <tt class="literal">default_entity_mode</tt> configuration option (see
            <a href="#configuration-optional-properties" title="Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties">Table&nbsp;3.3, &#8220;Hibernate Configuration Properties&#8221;</a>.
        </p><p>
            The following examples demonstrates the representation using <tt class="literal">Map</tt>s.
            First, in the mapping file, an <tt class="literal">entity-name</tt> has to be declared
            instead of (or in addition to) a class name:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><p>

            Note that even though associations are declared using target class names,
            the target type of an associations may also be a dynamic entity instead
            of a POJO.
        </p><p>
            After setting the default entity mode to <tt class="literal">dynamic-map</tt>
            for the <tt class="literal">SessionFactory</tt>, we can at runtime work with
            <tt class="literal">Map</tt>s of <tt class="literal">Map</tt>s:
        </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>
            The advantages of a dynamic mapping are quick turnaround time for prototyping
            without the need for entity class implementation. However, you lose compile-time
            type checking and will very likely deal with many exceptions at runtime. Thanks
            to the Hibernate mapping, the database schema can easily be normalized and sound,
            allowing to add a proper domain model implementation on top later on.
        </p><p>
            Entity representation modes can also be set on a per <tt class="literal">Session</tt>
            basis:
        </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>
            Please note that the call to <tt class="literal">getSession()</tt> using an
            <tt class="literal">EntityMode</tt> is on the <tt class="literal">Session</tt> API, not the
            <tt class="literal">SessionFactory</tt>. That way, the new <tt class="literal">Session</tt>
            shares the underlying JDBC connection, transaction, and other context
            information. This means you don't have tocall <tt class="literal">flush()</tt>
            and <tt class="literal">close()</tt> on the secondary <tt class="literal">Session</tt>, and
            also leave the transaction and connection handling to the primary unit of work.
        </p><p>
            More information about the XML representation capabilities can be found
            in <a href="#xml" title="Chapter&nbsp;18.&nbsp;XML Mapping">Chapter&nbsp;18, <i>XML Mapping</i></a>.
        </p></div><p>
        TODO: Document user-extension framework in the property and proxy packages
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapter&nbsp;5.&nbsp;Basic O/R Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;Mapping declaration</h2></div></div><div></div></div><p>
            Object/relational mappings are usually defined in an XML document. The mapping
            document is designed to be readable and hand-editable. The mapping language is
            Java-centric, meaning that mappings are constructed around persistent class
            declarations, not table declarations.
        </p><p>
            Note that, even though many Hibernate users choose to write the XML by hand,
            a number of tools exist to generate the mapping document, including XDoclet,
            Middlegen and AndroMDA.
        </p><p>
            Lets kick off with an example mapping:
        </p><a name="mapping-declaration-ex1"></a><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" 
            table="cats"
            discriminator-value="C"&gt;
                
                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass" 
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name" 
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             We will now discuss the content of the mapping document. We will only describe the 
             document elements and attributes that are used by Hibernate at runtime. The mapping 
             document also contains some extra optional attributes and elements that affect the 
             database schemas exported by the schema export tool. (For example the <tt class="literal">
             not-null</tt> attribute.)
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-doctype"></a>5.1.1.&nbsp;Doctype</h3></div></div><div></div></div><p>
                All XML mappings should declare the doctype shown. The actual DTD may be found 
                at the URL above, in the directory <tt class="literal">hibernate-x.x.x/src/org/hibernate
                </tt> or in <tt class="literal">hibernate3.jar</tt>. Hibernate will always look for
                the DTD in its classpath first. If you experience lookups of the DTD using an
                Internet connection, check your DTD declaration against the contents of your
                claspath.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                This element has several optional attributes. The <tt class="literal">schema</tt> and 
                <tt class="literal">catalog</tt> attributes specify that tables referred to in this mapping 
                belong to the named schema and/or catalog. If specified, tablenames will be qualified 
                by the given schema and catalog names. If missing, tablenames will be unqualified. 
                The <tt class="literal">default-cascade</tt> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a 
                <tt class="literal">cascade</tt> attribute. The <tt class="literal">auto-import</tt> attribute lets us
                use unqualified class names in the query language, by default.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span class="co">(1)</span>
         catalog="catalogName"                        <span class="co">(2)</span>
         default-cascade="cascade_style"              <span class="co">(3)</span>
         default-access="field|property|ClassName"    <span class="co">(4)</span>
         default-lazy="true|false"                    <span class="co">(5)</span>
         auto-import="true|false"                     <span class="co">(6)</span>
         package="package.name"                       <span class="co">(7)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                             <tt class="literal">schema</tt> (optional): The name of a database schema.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                             <tt class="literal">catalog</tt> (optional): The name of a database catalog.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-cascade</tt> (optional - defaults to <tt class="literal">none</tt>): 
                             A default cascade style.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-access</tt> (optional - defaults to <tt class="literal">property</tt>):
                             The strategy Hibernate should use for accessing all properties. Can be a custom
                             implementation of <tt class="literal">PropertyAccessor</tt>.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-lazy</tt> (optional - defaults to <tt class="literal">true</tt>):
                             The default value for unspecifed <tt class="literal">lazy</tt> attributes of class and
                             collection mappings.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                             <tt class="literal">auto-import</tt> (optional - defaults to <tt class="literal">true</tt>):
                             Specifies whether we can use unqualified class names (of classes in this mapping)
                             in the query language.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                             <tt class="literal">package</tt> (optional): Specifies a package prefix to assume for 
                             unqualified class names in the mapping document.
                         </p></td></tr></table></div></div><p>
                 If you have two persistent classes with the same (unqualified) name, you should set 
                 <tt class="literal">auto-import="false"</tt>. Hibernate will throw an exception if you attempt
                 to assign two classes to the same "imported" name.
             </p><p>
                 Note that the <tt class="literal">hibernate-mapping</tt> element allows you to nest
                 several persistent <tt class="literal">&lt;class&gt;</tt> mappings, as shown above.
                 It is however good practice (and expected by some tools) to map only a single
                 persistent class (or a single class hierarchy) in one mapping file and name
                 it after the persistent superclass, e.g. <tt class="literal">Cat.hbm.xml</tt>,
                 <tt class="literal">Dog.hbm.xml</tt>, or if using inheritance,
                 <tt class="literal">Animal.hbm.xml</tt>.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                You may declare a persistent class using the <tt class="literal">class</tt> element:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span class="co">(1)</span>
        table="tableName"                             <span class="co">(2)</span>
        discriminator-value="discriminator_value"     <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="owner"                                <span class="co">(5)</span>
        catalog="catalog"                             <span class="co">(6)</span>
        proxy="ProxyInterface"                        <span class="co">(7)</span>
        dynamic-update="true|false"                   <span class="co">(8)</span>
        dynamic-insert="true|false"                   <span class="co">(9)</span>
        select-before-update="true|false"             <span class="co">(10)</span>
        polymorphism="implicit|explicit"              <span class="co">(11)</span>
        where="arbitrary sql where condition"         <span class="co">(12)</span>
        persister="PersisterClass"                    <span class="co">(13)</span>
        batch-size="N"                                <span class="co">(14)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(15)</span>
        lazy="true|false"                             <span class="co">(16)</span>
        entity-name="EntityName"                      <span class="co">(17)</span>
        catalog="catalog"                             <span class="co">(18)</span>
        check="arbitrary sql check condition"         <span class="co">(19)</span>
        rowid="rowid"                                 <span class="co">(20)</span>
        subselect="SQL expression"                    <span class="co">(21)</span>
        abstract="true|false"                         <span class="co">(22)</span>
        entity-name="EntityName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The fully qualified Java class name of the 
                            persistent class (or interface). If this attribute is missing, it is assumed 
                            that the mapping is for a non-POJO entity.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> (optional - defaults to the unqualified class name):  The
                            name of its database table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A value
                            that distiguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <tt class="literal">null</tt> and <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">true</tt>): Specifies 
                            that instances of the class are (not) mutable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): Override the catalog name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">UPDATE</tt> SQL should be generated at runtime and 
                            contain only those columns whose values have changed.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">INSERT</tt> SQL should be generated at runtime and 
                            contain only the columns whose values are not null.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <tt class="literal">UPDATE</tt> 
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <tt class="literal">update()</tt>),
                            this means that Hibernate will perform an extra SQL <tt class="literal">SELECT</tt> to determine
                            if an <tt class="literal">UPDATE</tt> is actually required.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optional, defaults to <tt class="literal">implicit</tt>): 
                            Determines whether implicit or explicit query polymorphism is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt> 
                            condition to be used when retrieving objects of this class
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optional): Specifies a custom <tt class="literal">ClassPersister</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a "batch size" 
                            for fetching instances of this class by identifier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional, defaults to <tt class="literal">version</tt>): 
                            Determines the optimistic locking strategy.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Lazy fetching may be completely disabled by setting 
                            <tt class="literal">lazy="false"</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): Hibernate3 allows a class to be mapped 
                            multiple times (to different tables, potentially), and allows entity mappings that
                            are represented by Maps or XML at the Java level. In these cases, you should
                            provide an explicit arbitrary name for the entity. See 
                            <a href="#persistent-classes-dynamicmodels" title="4.4.&nbsp;Dynamic models">Section&nbsp;4.4, &#8220;Dynamic models&#8221;</a> and <a href="#xml" title="Chapter&nbsp;18.&nbsp;XML Mapping">Chapter&nbsp;18, <i>XML Mapping</i></a>
                            for more information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): The name of a database catalog used for this
                            class and its table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p>
                            <tt class="literal">check</tt> (optional): A SQL expression used to generate a multi-row
                            <span class="emphasis"><em>check</em></span> constraint for automatic schema generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p>
                            <tt class="literal">rowid</tt> (optional): Hibernate can use so called ROWIDs on databases
                            which support. E.g. on Oracle, Hibernate can use the <tt class="literal">rowid</tt> extra
                            column for fast updates if you set this option to <tt class="literal">rowid</tt>. A ROWID
                            is an implementation detail and represents the physical location of a stored tuple.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p>
                            <tt class="literal">subselect</tt> (optional): Maps an immutable and read-only entity
                            to a database subselect. Useful if you want to have a view instead of a base table,
                            but don't. See below for more information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(22)</td><td valign="top" align="left"><p>
                            <tt class="literal">abstract</tt> (optional): Used to mark abstract superclasses in
                            <tt class="literal">&lt;union-subclass&gt;</tt> hierarchies.
                        </p></td></tr></table></div></div><p>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <tt class="literal">&lt;subclass&gt;</tt>
                element. You may persist any <span class="emphasis"><em>static</em></span> inner class. You should specify the
                class name using the standard form ie. <tt class="literal">eg.Foo$Bar</tt>.
            </p><p>
                Immutable classes, <tt class="literal">mutable="false"</tt>, may not be updated or deleted by the 
                application. This allows Hibernate to make some minor performance optimizations.
            </p><p>
                The optional <tt class="literal">proxy</tt> attribute enables lazy initialization of persistent
                instances of the class. Hibernate will initially return CGLIB proxies which implement 
                the named interface. The actual persistent object will be loaded when a method of the 
                proxy is invoked. See "Proxies for Lazy Initialization" below.
            </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself. 
                <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only
                by queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <tt class="literal">&lt;class&gt;</tt> declaration
                as a <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt>. For
                most purposes the default, <tt class="literal">polymorphism="implicit"</tt>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </p><p>
                The <tt class="literal">persister</tt> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of 
                <tt class="literal">org.hibernate.persister.EntityPersister</tt> or you might even provide a
                completely new implementation of the interface 
                <tt class="literal">org.hibernate.persister.ClassPersister</tt> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <tt class="literal">org.hibernate.test.CustomPersister</tt> for a simple example (of "persistence"
                to a <tt class="literal">Hashtable</tt>).
            </p><p>
                Note that the <tt class="literal">dynamic-update</tt> and <tt class="literal">dynamic-insert</tt>
                settings are not inherited by subclasses and so may also be specified on the
                <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt> elements. 
                These settings may increase performance in some cases, but might actually decrease 
                performance in others. Use judiciously.
            </p><p>
                Use of <tt class="literal">select-before-update</tt> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily if you reattach a
                graph of detached instances to a <tt class="literal">Session</tt>.
            </p><p>
                If you enable <tt class="literal">dynamic-update</tt>, you will have a choice of optimistic
                locking strategies:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">version</tt> check the version/timestamp columns
                    </p></li><li><p>
                        <tt class="literal">all</tt> check all columns
                    </p></li><li><p>
                        <tt class="literal">dirty</tt> check the changed columns, allowing some concurrent updates
                    </p></li><li><p>
                        <tt class="literal">none</tt> do not use optimistic locking
                    </p></li></ul></div><p>
                We <span class="emphasis"><em>very</em></span> strongly recommend that you use version/timestamp
                columns for optimistic locking with Hibernate. This is the optimal strategy with
                respect to performance and is the only strategy that correctly handles modifications
                made to detached instances (ie. when <tt class="literal">Session.merge()</tt> is used).
            </p><p>
                There is no difference between a view and a base table for a Hibernate mapping, as
                expected this is transparent at the database level (note that some DBMS don't support
                views properly, especially with updates). Sometimes you want to use a view, but can't
                create one in the database (ie. with a legacy schema). In this case, you can map an
                immutable and read-only entity to a given SQL subselect expression:
            </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class&gt;</pre><p>
                Declare the tables to synchronize this entity with, ensuring that auto-flush happens
                correctly, and that queries against the derived entity do not return stale data.
                The <tt class="literal">&lt;subselect&gt;</tt> is available as both as an attribute and
                a nested mapping element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.4.&nbsp;id</h3></div></div><div></div></div><p>
                Mapped classes <span class="emphasis"><em>must</em></span> declare the primary key column of the database 
                table. Most classes will also have a JavaBeans-style property holding the unique identifier 
                of an instance. The <tt class="literal">&lt;id&gt;</tt> element defines the mapping from that
                property to the primary key column.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                     <span class="co">(1)</span>
        type="typename"                                         <span class="co">(2)</span>
        column="column_name"                                    <span class="co">(3)</span>
        unsaved-value="null|any|none|undefined|id_value"        <span class="co">(4)</span>
        access="field|property|ClassName"&gt;                      <span class="co">(5)</span>

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The name of the identifier property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): A name that indicates the Hibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The
                            name of the primary key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to a "sensible" value): 
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from detached instances that were saved or loaded
                            in a previous session.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                If the <tt class="literal">name</tt> attribute is missing, it is assumed that the class has no 
                identifier property.
            </p><p>
                The <tt class="literal">unsaved-value</tt> attribute is important! If the identfier property of your 
                class does not default to the normal Java default value (null or zero), then you should specify 
                the actual default.
            </p><p>
                There is an alternative <tt class="literal">&lt;composite-id&gt;</tt> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.4.1.&nbsp;Generator</h4></div></div><div></div></div><p>
                    The optional <tt class="literal">&lt;generator&gt;</tt> child element names a Java class used
                    to generate unique identifiers for instances of the persistent class. If any parameters
                    are required to configure or initialize the generator instance, they are passed using the
                    <tt class="literal">&lt;param&gt;</tt> element.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    All generators implement the interface <tt class="literal">org.hibernate.id.IdentifierGenerator</tt>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, Hibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                generates identifiers of type <tt class="literal">long</tt>, <tt class="literal">short</tt> or
                                <tt class="literal">int</tt> that are unique only when no other process is inserting data
                                into the same table.
                                <span class="emphasis"><em>Do not use in a cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supports identity columns in DB2, MySQL, MS SQL Server, Sybase and
                                HypersonicSQL. The returned identifier is of type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> or <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator
                                in Interbase. The returned identifier is of type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> or <tt class="literal">int</tt>
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                uses a hi/lo algorithm to efficiently generate identifiers of
                                type <tt class="literal">long</tt>, <tt class="literal">short</tt> or <tt class="literal">int</tt>,
                                given a table and column (by default <tt class="literal">hibernate_unique_key</tt> and
                                <tt class="literal">next_hi</tt> respectively) as a source of hi values. The hi/lo 
                                algorithm generates identifiers that are unique only for a particular database.
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                uses a hi/lo algorithm to efficiently generate identifiers of type
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> or <tt class="literal">int</tt>,
                                given a named database sequence.
                            </p></dd><dt><span class="term"><tt class="literal">uuid</tt></span></dt><dd><p>
                                uses a 128-bit UUID algorithm to generate identifiers of type string,
                                unique within a network (the IP address is used). The UUID is encoded
                                as a string of hexadecimal digits of length 32.
                            </p></dd><dt><span class="term"><tt class="literal">guid</tt></span></dt><dd><p>
                                uses a database-generated GUID string on MS SQL Server and MySQL.
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                picks <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> or
                                <tt class="literal">hilo</tt> depending upon the capabilities of the
                                underlying database.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                lets the application to assign an identifier to the object before
                                <tt class="literal">save()</tt> is called. This is the default strategy
                                if no <tt class="literal">&lt;generator&gt;</tt> element is specified.
                            </p></dd><dt><span class="term"><tt class="literal">select</tt></span></dt><dd><p>
                                retrieves a primary key assigned by a database trigger by selecting
                                the row by some unique key and retrieving the primary key value.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                uses the identifier of another associated object. Usually used in conjunction
                                with a <tt class="literal">&lt;one-to-one&gt;</tt> primary key association.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.4.2.&nbsp;Hi/lo algorithm</h4></div></div><div></div></div><p>
                    The <tt class="literal">hilo</tt> and <tt class="literal">seqhilo</tt> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Unfortunately, you can't use <tt class="literal">hilo</tt> when supplying your own
                    <tt class="literal">Connection</tt> to Hibernate. When Hibernate is using an application
                    server datasource to obtain connections enlisted with JTA, you must properly configure
                    the <tt class="literal">hibernate.transaction.manager_lookup_class</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid"></a>5.1.4.3.&nbsp;UUID algorithm</h4></div></div><div></div></div><p>
                    The UUID contains: IP address, startup time of the JVM (accurate to a quarter
                    second), system time and a counter value (unique within the JVM). It's not
                    possible to obtain a MAC address or memory address from Java code, so this is
                    the best we can do without using JNI.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.4.4.&nbsp;Identity columns and sequences</h4></div></div><div></div></div><p>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <tt class="literal">identity</tt> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <tt class="literal">sequence</tt> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    For cross-platform development, the <tt class="literal">native</tt> strategy will
                    choose from the <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> and
                    <tt class="literal">hilo</tt> strategies, dependant upon the capabilities of the
                    underlying database.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.4.5.&nbsp;Assigned identifiers</h4></div></div><div></div></div><p>
                    If you want the application to assign identifiers (as opposed to having
                    Hibernate generate them), you may use the <tt class="literal">assigned</tt> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. This generator is used when the primary key
                    is a natural key instead of a surrogate key. This is the default behavior
                    if you do no specify a <tt class="literal">&lt;generator&gt;</tt> element.
                </p><p>
                    Choosing the <tt class="literal">assigned</tt> generator makes Hibernate use 
                    <tt class="literal">unsaved-value="undefined"</tt>, forcing Hibernate to go to
                    the database to determine if an instance is transient or detached, unless
                    there is a version or timestamp property, or you define 
                    <tt class="literal">Interceptor.isUnsaved()</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-select"></a>5.1.4.6.&nbsp;Primary keys assigned by triggers</h4></div></div><div></div></div><p>
                    For legacy schemas only (Hibernate does not generate DDL with triggers).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    In the above example, there is a unique valued property named 
                    <tt class="literal">socialSecurityNumber</tt> defined by the class, as a
                    natural key, and a surrogate key named <tt class="literal">person_id</tt>
                    whose value is generated by a trigger.
                </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.5.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        unsaved-value="undefined|any|none"
        access="field|property|ClassName"&gt;

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <tt class="literal">&lt;composite-id&gt;</tt> element
                accepts <tt class="literal">&lt;key-property&gt;</tt> property mappings and
                <tt class="literal">&lt;key-many-to-one&gt;</tt> mappings as child elements.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Your persistent class <span class="emphasis"><em>must</em></span> override <tt class="literal">equals()</tt>
                and <tt class="literal">hashCode()</tt> to implement composite identifier equality. It must
                also implements <tt class="literal">Serializable</tt>.
            </p><p>
                Unfortunately, this approach to composite identifiers means that a persistent object 
                is its own identifier. There is no convenient "handle" other than the object itself. 
                You must instantiate an instance of the persistent class itself and populate its 
                identifier properties before you can <tt class="literal">load()</tt> the persistent state
                associated with a composite key. We will describe a much more
                convenient approach where the composite identifier is implemented as a separate class
                in <a href="#components-compositeid" title="8.4.&nbsp;Components as composite identifiers">Section&nbsp;8.4, &#8220;Components as composite identifiers&#8221;</a>. The attributes described below apply only
                to this alternative approach:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optional): A property of component type that holds the
                        composite identifier (see next section).
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optional - defaults to the property type determined by 
                        reflection): The component class used as a composite identifier (see next section).
                    </p></li><li><p>
                        <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">undefined</tt>): 
                        Indicates that transient instances should be considered newly instantiated, if set 
                        to <tt class="literal">any</tt>, or detached, if set to <tt class="literal">none</tt>. It is best 
                        to leave the default value in all cases.
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.6.&nbsp;discriminator</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;discriminator&gt;</tt> element is required for polymorphic persistence 
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the 
                table. The discriminator column contains marker values that tell the persistence layer what 
                subclass to instantiate for a particular row. A restricted set of types may be used: 
                <tt class="literal">string</tt>, <tt class="literal">character</tt>, <tt class="literal">integer</tt>, 
                <tt class="literal">byte</tt>, <tt class="literal">short</tt>, <tt class="literal">boolean</tt>, 
                <tt class="literal">yes_no</tt>, <tt class="literal">true_false</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span class="co">(1)</span>
        type="discriminator_type"                          <span class="co">(2)</span>
        force="true|false"                                 <span class="co">(3)</span>
        insert="true|false"                                <span class="co">(4)</span>
        formula="arbitrary sql expression"                 <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to <tt class="literal">class</tt>) the
                            name of the discriminator column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">string</tt>) a
                            name that indicates the Hibernate type
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optional - defaults to <tt class="literal">false</tt>) 
                            "force" Hibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>)
                            set this to <tt class="literal">false</tt> if your discriminator column is also part
                            of a mapped composite identifier. (Tells Hibernate to not include the column
                            in SQL <tt class="literal">INSERT</tt>s.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional) an arbitrary SQL expression that is 
                            executed when a type has to be evaluated. Allows content-based discrimination.
                        </p></td></tr></table></div></div><p>
                Actual values of the discriminator column are specified by the
                <tt class="literal">discriminator-value</tt> attribute of the <tt class="literal">&lt;class&gt;</tt> and
                <tt class="literal">&lt;subclass&gt;</tt> elements.
            </p><p>
                The <tt class="literal">force</tt> attribute is (only) useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </p><p>
                Using the <tt class="literal">formula</tt> attribute you can declare an arbitrary SQL expression
                that will be used to evaluate the type of a row:
            </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.7.&nbsp;version (optional)</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;version&gt;</tt> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <span class="emphasis"><em>long transactions</em></span> (see below).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                            <span class="co">(1)</span>
        name="propertyName"                                <span class="co">(2)</span>
        type="typename"                                    <span class="co">(3)</span>
        access="field|property|ClassName"                  <span class="co">(4)</span>
        unsaved-value="null|negative|undefined"            <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property  of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">integer</tt>): 
                            The type of the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">undefined</tt>): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from detached instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr></table></div></div><p>
                Version numbers may be of Hibernate type <tt class="literal">long</tt>, <tt class="literal">integer</tt>,
                <tt class="literal">short</tt>, <tt class="literal">timestamp</tt> or <tt class="literal">calendar</tt>.
            </p><p>
                A version or timestamp property should never be null for a detached instance, so
                Hibernate will detact any instance with a null version or timestamp as transient,
                no matter what other <tt class="literal">unsaved-value</tt> strategies are specified.
                <span class="emphasis"><em>Declaring a nullable version or timestamp property is an easy way to avoid 
                any problems with transitive reattachment in Hibernate, especially useful for people 
                using assigned identifiers or composite keys!</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.8.&nbsp;timestamp (optional)</h3></div></div><div></div></div><p>
                The optional <tt class="literal">&lt;timestamp&gt;</tt> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"           <span class="co">(1)</span>
        name="propertyName"                 <span class="co">(2)</span>
        access="field|property|ClassName"   <span class="co">(3)</span>
        unsaved-value="null|undefined"      <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a JavaBeans style property of
                            Java type <tt class="literal">Date</tt> or <tt class="literal">Timestamp</tt> of the
                            persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">null</tt>): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from detached instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr></table></div></div><p>
                Note that <tt class="literal">&lt;timestamp&gt;</tt> is equivalent to 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.9.&nbsp;property</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;property&gt;</tt> element declares a persistent, JavaBean style 
                property of the class.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                 <span class="co">(1)</span>
        column="column_name"                <span class="co">(2)</span>
        type="typename"                     <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        insert="true|false"                 <span class="co">(4)</span>
        formula="arbitrary SQL expression"  <span class="co">(5)</span>
        access="field|property|ClassName"   <span class="co">(6)</span>
        lazy="true|false"                   <span class="co">(7)</span>
        unique="true|false"                 <span class="co">(8)</span>
        not-null="true|false"               <span class="co">(9)</span>
        optimistic-lock="true|false"        <span class="co">(10)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the name of the property, with an initial lowercase
                            letter.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): the name
                            of the mapped database table column. This may also be specified by nested 
                            <tt class="literal">&lt;column&gt;</tt> element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): a name that indicates the Hibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) :
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL expression that defines the value for a
                            <span class="emphasis"><em>computed</em></span> property. Computed properties do not have a column
                            mapping of their own.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that this property should be fetched lazily when the instance variable is first 
                            accessed (requires build-time bytecode instrumentation).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                            constraint for the columns. Also, allow this to be the target of 
                            a <tt class="literal">property-ref</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): Enable the DDL generation of a nullability
                            constraint for the columns.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> could be:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        The name of a Hibernate basic type (eg. <tt class="literal">integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</tt>).
                    </p></li><li><p>
                        The name of a Java class with a default basic type (eg. <tt class="literal">int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</tt>).
                    </p></li><li><p>
                        The name of a serializable Java class.
                    </p></li><li><p>
                        The class name of a custom type (eg. <tt class="literal">com.illflow.type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                If you do not specify a type, Hibernate will use reflection upon the named
                property to take a guess at the correct Hibernate type. Hibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <tt class="literal">type</tt>
                attribute. (For example, to distinguish between <tt class="literal">Hibernate.DATE</tt> and
                <tt class="literal">Hibernate.TIMESTAMP</tt>, or to specify a custom type.)
            </p><p>
                The <tt class="literal">access</tt> attribute lets you control how Hibernate will access
                the property at runtime. By default, Hibernate will call the property get/set pair.
                If you specify <tt class="literal">access="field"</tt>, Hibernate will bypass the get/set
                pair and access the field directly, using reflection. You may specify your own
                strategy for property access by naming a class that implements the interface
                <tt class="literal">org.hibernate.property.PropertyAccessor</tt>.
            </p><p>
                An especially powerful feature are derived properties. These properties are by
                definition read-only, the property value is computed at load time. You declare
                the computation as a SQL expression, this translates to a <tt class="literal">SELECT</tt>
                clause subquery in the SQL query that loads an instance:
            </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>
                Note that you can reference the entities own table by not declaring an alias on
                a particular column (<tt class="literal">customerId</tt> in the given example). Also note
                that you can use the nested <tt class="literal">&lt;formula&gt;</tt> mapping element
                if you don't like to use the attribute.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.10.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                An ordinary association to another persistent class is declared using a
                <tt class="literal">many-to-one</tt> element. The relational model is a
                many-to-one association: a foreign key in one table is referencing
                the primary key column(s) of the target table.
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                <span class="co">(1)</span>
        column="column_name"                               <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        cascade="cascade_style"                            <span class="co">(4)</span>
        fetch="join|select"                                <span class="co">(5)</span>
        update="true|false"                                <span class="co">(6)</span>
        insert="true|false"                                <span class="co">(6)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(7)</span>
        access="field|property|ClassName"                  <span class="co">(8)</span>
        unique="true|false"                                <span class="co">(9)</span>
        not-null="true|false"                              <span class="co">(10)</span>
        optimistic-lock="true|false"                       <span class="co">(11)</span>
        lazy="true|false"                                  <span class="co">(12)</span>
        entity-name="EntityName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the foreign key column. 
                            This may also be specified by nested <tt class="literal">&lt;column&gt;</tt>
                            element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>): 
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) 
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated 
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                            constraint for the foreign-key column. Also, allow this to be the target of 
                            a <tt class="literal">property-ref</tt>. This makes the association multiplicity 
                            effectively one to one.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): Enable the DDL generation of a nullability
                            constraint for the foreign key columns.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, dertermines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that this property should be fetched lazily when the instance variable is first 
                            accessed (requires build-time bytecode instrumentation). Note that this does not
                            influence Hibernate's proxy behavior - like the <tt class="literal">lazy</tt> attribute
                            on class or collection mappings, but uses interception for deferred loading.
                        </p></td></tr></table></div></div><p>
                Setting a value of the <tt class="literal">cascade</tt> attribute to any meaningful
                value other than <tt class="literal">none</tt> will propagate certain operations to the
                associated object. The meaningful values are the names of Hibernate's basic 
                operations, <tt class="literal">create, merge, delete, save-update, evict, replicate, lock,
                refresh</tt>, as well as the special values <tt class="literal">delete-orphan</tt> 
                and <tt class="literal">all</tt> and comma-separated combinations of operation
                names, for example, <tt class="literal">cascade="create,merge,evict"</tt> or
                <tt class="literal">cascade="all,delete-orphan"</tt>. See <a href="#objectstate-transitive" title="10.11.&nbsp;Transitive persistence">Section&nbsp;10.11, &#8220;Transitive persistence&#8221;</a>
                for a full explanation.
            </p><p>
                A typical <tt class="literal">many-to-one</tt> declaration looks as simple as this:
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                The <tt class="literal">property-ref</tt> attribute should only be used for mapping legacy
                data where a foreign key refers to a unique key of the associated table other than
                the primary key. This is an ugly relational model. For example, suppose the 
                <tt class="literal">Product</tt> class had a unique serial number, that is not the primary 
                key. (The <tt class="literal">unique</tt> attribute controls Hibernate's DDL generation with
                the SchemaExport tool.)
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                Then the mapping for <tt class="literal">OrderItem</tt> might use:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                This is certainly not encouraged, however.
            </p><p>
                If the referenced unique key comprises multiple properties of the associated entity, you should
                map the referenced properties inside a named <tt class="literal">&lt;properties&gt;</tt> element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.11.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                A one-to-one association to another persistent class is declared using a 
                <tt class="literal">one-to-one</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        cascade="cascade_style"                            <span class="co">(3)</span>
        constrained="true|false"                           <span class="co">(4)</span>
        fetch="join|select"                                <span class="co">(5)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(6)</span>
        access="field|property|ClassName"                  <span class="co">(7)</span>
        formula="any SQL expression"                       <span class="co">(8)</span>
        entity-name="EntityName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional) specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (optional) specifies that a foreign key constraint
                            on the primary key of the mapped table references the table of the associated
                            class. This option affects the order in which <tt class="literal">save()</tt> and
                            <tt class="literal">delete()</tt> are cascaded, and determines whether the association
                            may be proxied (it is also used by the schema export tool).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>): 
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated class
                            that is joined to the primary key of this class. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): Almost all one to one associations map to the
                            primary key of the owning entity. In the rare case that this is not the case, you may
                            specify a some other column, columns or expression to join on using an SQL formula. (See 
                            <tt class="literal">org.hibernate.test.onetooneformula</tt> for an example.)
                        </p></td></tr></table></div></div><p>
                There are two varieties of one-to-one association:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                primary key associations
            </p></li><li><p>
                unique foreign key associations
            </p></li></ul></div><p>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </p><p>
                For a primary key association, add the following mappings to <tt class="literal">Employee</tt> and 
                <tt class="literal">Person</tt>, respectively.
            </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special Hibernate identifier generation strategy
                called <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                A newly saved instance of <tt class="literal">Person</tt> is then assigned the same primary
                key value as the <tt class="literal">Employee</tt> instance refered with the <tt class="literal">employee</tt>
                property of that <tt class="literal">Person</tt>.
            </p><p>
                Alternatively, a foreign key with a unique constraint, from <tt class="literal">Employee</tt> to 
                <tt class="literal">Person</tt>, may be expressed as:
            </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                And this association may be made bidirectional by adding the following to the 
                <tt class="literal">Person</tt> mapping:
            </p><pre class="programlisting">&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.12.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;component&gt;</tt> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                "Components" below.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="propertyName"                 <span class="co">(1)</span>
        class="className"                   <span class="co">(2)</span>
        insert="true|false"                 <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        access="field|property|ClassName"   <span class="co">(5)</span>
        lazy="true|false"                   <span class="co">(6)</span>
        optimistic-lock="true|false"        <span class="co">(7)</span>
        unique="true|false"                 <span class="co">(8)</span>
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that this component should be fetched lazily when the instance variable is first 
                            accessed (requires build-time bytecode instrumentation).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                                <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                                Specifies that updates to this component do or do not require acquisition of the
                                optimistic lock. In other words, determines if a version increment should occur when 
                                this property is dirty.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                                <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>):
                                Specifies that a unique constraint exists upon all mapped columns of the
                                component.
                            </p></td></tr></table></div></div><p>
                The child <tt class="literal">&lt;property&gt;</tt> tags map properties of the
                child class to table columns.
            </p><p>
                The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
                subelement that maps a property of the component class as a reference back to the
                containing entity.
            </p><p>
                The <tt class="literal">&lt;dynamic-component&gt;</tt> element allows a <tt class="literal">Map</tt>
                to be mapped as a component, where the property names refer to keys of the map, see
                <a href="#components-dynamic" title="8.5.&nbsp;Dynamic components">Section&nbsp;8.5, &#8220;Dynamic components&#8221;</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-properties"></a>5.1.13.&nbsp;properties</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;properties&gt;</tt> element allows the definition of a named,
                logical grouping of properties of a class. The most important use of the construct
                is that it allows a combination of properties to be the target of a 
                <tt class="literal">property-ref</tt>. It is also a convenient way to define a multi-column
                unique constraint.
            </p><div class="programlistingco"><pre class="programlisting">&lt;properties 
        name="logicalName"                  <span class="co">(1)</span>
        insert="true|false"                 <span class="co">(2)</span>
        update="true|false"                 <span class="co">(3)</span>
        optimistic-lock="true|false"        <span class="co">(4)</span>
        unique="true|false"                 <span class="co">(5)</span>
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The logical name of the grouping - 
                            <span class="emphasis"><em>not</em></span> an actual property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                                <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                                Specifies that updates to these properties do or do not require acquisition of the
                                optimistic lock. In other words, determines if a version increment should occur when
                                these properties are dirty.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                                <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>):
                                Specifies that a unique constraint exists upon all mapped columns of the
                                component.
                            </p></td></tr></table></div></div><p>
                For example, if we have the following <tt class="literal">&lt;properties&gt;</tt> mapping:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;
    ...
    &lt;properties name="name" 
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>
                Then we might have some legacy data association which refers to this unique key of 
                the <tt class="literal">Person</tt> table, instead of to the primary key:
            </p><pre class="programlisting">&lt;many-to-one name="person" 
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one&gt;</pre><p>
                We don't recommend the use of this kind of thing outside the context of mapping
                legacy data.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.14.&nbsp;subclass</h3></div></div><div></div></div><p>
                Finally, polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the table-per-class-hierarchy
                mapping strategy, the <tt class="literal">&lt;subclass&gt;</tt> declaration is used.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span class="co">(1)</span>
        discriminator-value="discriminator_value"     <span class="co">(2)</span>
        proxy="ProxyInterface"                        <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A
                            value that distiguishes individual subclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use for 
                            lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting 
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                        </p></td></tr></table></div></div><p>
                Each subclass should declare its own persistent properties and subclasses.
                <tt class="literal">&lt;version&gt;</tt> and <tt class="literal">&lt;id&gt;</tt> properties
                are assumed to be inherited from the root class. Each subclass in a heirarchy must
                define a unique <tt class="literal">discriminator-value</tt>. If none is specified, the
                fully qualified Java class name is used.
            </p><p>
            It is possible to define <tt class="literal">subclass</tt>, <tt class="literal">union-subclass</tt>,
            and <tt class="literal">joined-subclass</tt> mappings in separate mapping documents, directly beneath
            <tt class="literal">hibernate-mapping</tt>. This allows you to extend a class hierachy just by adding
            a new mapping file. You must specify an <tt class="literal">extends</tt> attribute in the subclass mapping,
            naming a previously mapped superclass. Note: Previously this feature made the ordering of the mapping
            documents important. Since Hibernate3, the ordering of mapping files does not matter when using the
            extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses
            before subclasses.
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
    &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
         &lt;property name="name" type="string"/&gt;
    &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.15.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                Alternatively, each subclass may be mapped to its own table (table-per-subclass 
                mapping strategy). Inherited state is retrieved by joining with the table of the 
                superclass. We use the <tt class="literal">&lt;joined-subclass&gt;</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting 
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                         </p></td></tr></table></div></div><p>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <tt class="literal">&lt;key&gt;</tt> element. The mapping at the start of the chapter
                would be re-written as:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                 For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-unionsubclass"></a>5.1.16.&nbsp;union-subclass</h3></div></div><div></div></div><p>
               A third option is to map only the concrete classes of an inheritance hierarchy
               to tables, (the table-per-concrete-class strategy) where each table defines all 
               persistent state of the class, including inherited state. In Hibernate, it is
               not absolutely necessary to explicitly map such inheritance hierarchies. You
               can simply map each class with a separate <tt class="literal">&lt;class&gt;</tt>
               declaration. However, if you wish use polymorphic associations (e.g. an association
               to the superclass of your hierarchy), you need to
               use the <tt class="literal">&lt;union-subclass&gt;</tt> mapping.
           </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting 
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                         </p></td></tr></table></div></div><p>
                No discriminator column or key column is required for this mapping strategy.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-join"></a>5.1.17.&nbsp;join</h3></div></div><div></div></div><p>
                Using the <tt class="literal">&lt;join&gt;</tt> element, it is possible to map
                properties of one class to several tables.
            </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span class="co">(1)</span>
        schema="owner"                           <span class="co">(2)</span>
        catalog="catalog"                        <span class="co">(3)</span>
        fetch="join|select"                      <span class="co">(4)</span>
        inverse="true|false"                     <span class="co">(5)</span>
        optional="true|false"&gt;                   <span class="co">(6)</span>
        
        &lt;key ... /&gt;
        
        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the joined table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): Override the catalog name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">join</tt>):
                            If set to <tt class="literal">join</tt>, the default, Hibernate will use an inner join 
                            to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by a class or its superclasses 
                            and an outer join for a <tt class="literal">&lt;join&gt;</tt> defined by a subclass.
                            If set to <tt class="literal">select</tt> then Hibernate will use a sequential select for 
                            a <tt class="literal">&lt;join&gt;</tt> defined on a subclass, which will be issued only 
                            if a row turns out to represent an instance of the subclass. Inner joins will still
                            be used to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by the class and its 
                            superclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, Hibernate will not try to insert or update the properties defined
                            by this join.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optional</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, Hibernate will insert a row only if the properties defined by this 
                            join are non-null and will always use an outer join to retrieve the properties.
                        </p></td></tr></table></div></div><p>
                For example, the address information for a person can be mapped to a separate
                table (while preserving value type semantics for all properties):
            </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>
                This feature is often only useful for legacy data models, we recommend fewer
                tables than classes and a fine-grained domain model. However, it is useful
                for switching between inheritance mapping strategies in a single hierarchy, as
                explained later.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-key"></a>5.1.18.&nbsp;key</h3></div></div><div></div></div><p>
                We've seen the <tt class="literal">&lt;key&gt;</tt> element crop up a few times
                now. It appears anywhere the parent mapping element defines a join to
                a new table, and defines the foreign key in the joined table, that references
                the primary key of the original table.
            </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span class="co">(1)</span>
        on-delete="noaction|cascade"             <span class="co">(2)</span>
        property-ref="propertyName"              <span class="co">(3)</span>
        not-null="true|false"                    <span class="co">(4)</span>
        update="true|false"                      <span class="co">(5)</span>
        unique="true|false"                      <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the foreign key column.
                            This may also be specified by nested <tt class="literal">&lt;column&gt;</tt>
                            element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">on-delete</tt> (optional, defaults to <tt class="literal">noaction</tt>): 
                            Specifies whether the foreign key constraint has database-level cascade delete 
                            enabled.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optional): Specifies that the foreign key refers
                            to columns that are not the primary key of the orginal table. (Provided for 
                            legacy data.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): Specifies that the foreign key columns
                            are not nullable (this is implied whenever the foreign key is also part of the
                            primary key).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> (optional): Specifies that the foreign key should never
                            be updated (this is implied whenever the foreign key is also part of the primary 
                            key).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Specifies that the foreign key should have
                            a unique constraint (this is implied whenever the foreign key is also the primary key).
                        </p></td></tr></table></div></div><p>
                We recommend that for systems where delete performance is important, all keys should be 
                defined <tt class="literal">on-delete="cascade"</tt>, and Hibernate will use a database-level
                <tt class="literal">ON CASCADE DELETE</tt> constraint, instead of many individual 
                <tt class="literal">DELETE</tt> statements. Be aware that this feature bypasses Hibernate's
                usual optimistic locking strategy for versioned data.
            </p><p>
                The <tt class="literal">not-null</tt> and <tt class="literal">update</tt> attributes are useful when
                mapping a unidirectional one to many association. If you map a unidirectional one to many
                to a non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using
                <tt class="literal">&lt;key not-null="true"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-column"></a>5.1.19.&nbsp;column and formula elements</h3></div></div><div></div></div><p>
               Any mapping element which accepts a <tt class="literal">column</tt> attribute will alternatively
               accept a <tt class="literal">&lt;column&gt;</tt> subelement. Likewise, <tt class="literal">&lt;formula&gt;</tt>
               is an alternative to the <tt class="literal">formula</tt> attribute.
           </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p>
                <tt class="literal">column</tt> and <tt class="literal">formula</tt> attributes may even be combined
                within the same property or association mapping to express, for example, exotic join
                conditions.
            </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.20.&nbsp;import</h3></div></div><div></div></div><p>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified (package) name in Hibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <tt class="literal">auto-import="true"</tt>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span class="co">(1)</span>
        rename="ShortName"             <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt>: The fully qualified class name of of any Java class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </p></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.1.21.&nbsp;any</h3></div></div><div></div></div><p>
                There is one further type of property mapping. The <tt class="literal">&lt;any&gt;</tt> mapping element 
                defines a polymorphic association to classes from multiple tables. This type of mapping always
                requires more than one column. The first column holds the type of the associated entity. 
                The remaining columns hold the identifier. It is impossible to specify a foreign key constraint
                for this kind of association, so this is most certainly not meant as the usual way of mapping 
                (polymorphic) associations. You should use this only in very special cases (eg. audit logs,
                user session data, etc).
            </p><p>
                 The <tt class="literal">meta-type</tt> attribute lets the application specify a custom type that 
                 maps database column values to persistent classes which have identifier properties of the 
                 type specified by <tt class="literal">id-type</tt>. You must specify the mapping from values of
                 the meta-type to class names.
            </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span class="co">(1)</span>
        id-type="idtypename"                     <span class="co">(2)</span>
        meta-type="metatypename"                 <span class="co">(3)</span>
        cascade="cascade_style"                  <span class="co">(4)</span>
        access="field|property|ClassName"        <span class="co">(5)</span>
        optimistic-lock="true|false"             <span class="co">(6)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt>: the identifier type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optional - defaults to <tt class="literal">string</tt>): 
                            Any type that is allowed for a discriminator mapping.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional- defaults to <tt class="literal">none</tt>): 
                            the cascade style.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, define if a version increment should occur if this
                            property is dirty.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;Hibernate Types</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entities and values</h3></div></div><div></div></div><p>
                To understand the behaviour of various Java language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </p><p>
                An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding
                references to the entity. Contrast this with the usual Java model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <span class="emphasis"><em>cascaded</em></span>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachablity - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </p><p>
                An entity's persistent state consists of references to other entities and
                instances of <span class="emphasis"><em>value</em></span> types. Values are primitives,
                collections (not what's inside a collection), components and certain immutable
                objects. Unlike entities, values (in particular collections and components)
                <span class="emphasis"><em>are</em></span> persisted and deleted by reachability. Since value
                objects (and primitives) are persisted and deleted along with their containing
                entity they may not be independently versioned. Values have no independent
                identity, so they cannot be shared by two entities or collections.
            </p><p>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <span class="emphasis"><em>component</em></span> is a user defined class with value semantics.
                A Java property of type <tt class="literal">java.lang.String</tt> also has value
                semantics. Given this definition, we can say that all types (classes) provided
                by the JDK have value type semantics in Java, while user-defined types may
                be mapped with entity or value type semantics. This decision is up to the
                application developer. A good hint for an entity class in a domain model are
                shared references to a single instance of that class, while composition or
                aggregation usually translates to a value type.
            </p><p>
                We'll revisit both concepts throughout the documentation.
            </p><p>
                The challenge is to map the Java type system (and the developers' definition of
                entities and value types) to the SQL/database type system. The bridge between
                both systems is provided by Hibernate: for entities we use
                <tt class="literal">&lt;class&gt;</tt>, <tt class="literal">&lt;subclass&gt;</tt> and so on.
                For value types we use <tt class="literal">&lt;property&gt;</tt>,
                <tt class="literal">&lt;component&gt;</tt>, etc, usually with a <tt class="literal">type</tt>
                attribute. The value of this attribute is the name of a Hibernate
                <span class="emphasis"><em>mapping type</em></span>. Hibernate provides many mappings (for standard
                JDK value types) out of the box. You can write your own mapping types and implement your
                custom conversion strategies as well, as you'll see later.
            </p><p>
                All built-in Hibernate types except collections support null semantics.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Basic value types</h3></div></div><div></div></div><p>
                The built-in <span class="emphasis"><em>basic mapping types</em></span> may be roughly categorized into

                </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</tt></span></dt><dd><p>
                                Type mappings from Java primitives or wrapper classes to appropriate
                                (vendor-specific) SQL column types. <tt class="literal">boolean, yes_no</tt>
                                and <tt class="literal">true_false</tt> are all alternative encodings for
                                a Java <tt class="literal">boolean</tt> or <tt class="literal">java.lang.Boolean</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">string</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.lang.String</tt> to
                                <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                            </p></dd><dt><span class="term"><tt class="literal">date, time, timestamp</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Date</tt> and its subclasses 
                                to SQL types <tt class="literal">DATE</tt>, <tt class="literal">TIME</tt> and
                                <tt class="literal">TIMESTAMP</tt> (or equivalent).
                            </p></dd><dt><span class="term"><tt class="literal">calendar, calendar_date</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Calendar</tt> to
                                SQL types <tt class="literal">TIMESTAMP</tt> and <tt class="literal">DATE</tt>
                                (or equivalent).
                            </p></dd><dt><span class="term"><tt class="literal">big_decimal</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.math.BigDecimal</tt> to
                                <tt class="literal">NUMERIC</tt> (or Oracle <tt class="literal">NUMBER</tt>).
                            </p></dd><dt><span class="term"><tt class="literal">locale, timezone, currency</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Locale</tt>,
                                <tt class="literal">java.util.TimeZone</tt> and 
                                <tt class="literal">java.util.Currency</tt> 
                                to <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                                Instances of <tt class="literal">Locale</tt> and <tt class="literal">Currency</tt> are 
                                mapped to their ISO codes. Instances of <tt class="literal">TimeZone</tt> are
                                mapped to their <tt class="literal">ID</tt>. 
                            </p></dd><dt><span class="term"><tt class="literal">class</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.lang.Class</tt> to
                                <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                                A <tt class="literal">Class</tt> is mapped to its fully qualified name.
                            </p></dd><dt><span class="term"><tt class="literal">binary</tt></span></dt><dd><p>
                                Maps byte arrays to an appropriate SQL binary type.
                            </p></dd><dt><span class="term"><tt class="literal">text</tt></span></dt><dd><p>
                                Maps long Java strings to a SQL <tt class="literal">CLOB</tt> or 
                                <tt class="literal">TEXT</tt> type.
                            </p></dd><dt><span class="term"><tt class="literal">serializable</tt></span></dt><dd><p>
                                Maps serializable Java types to an appropriate SQL binary type. You
                                may also indicate the Hibernate type <tt class="literal">serializable</tt> with
                                the name of a serializable Java class or interface that does not default 
                                to a basic type.
                            </p></dd><dt><span class="term"><tt class="literal">clob, blob</tt></span></dt><dd><p>
                                Type mappings for the JDBC classes <tt class="literal">java.sql.Clob</tt> and
                                <tt class="literal">java.sql.Blob</tt>. These types may be inconvenient for some
                                applications, since the blob or clob object may not be reused outside of
                                a transaction. (Furthermore, driver support is patchy and inconsistent.)
                            </p></dd></dl></div><p>
            
            </p><p>
                Unique identifiers of entities and collections may be of any basic type except
                <tt class="literal">binary</tt>, <tt class="literal">blob</tt> and <tt class="literal">clob</tt>. 
                (Composite identifiers are also allowed, see below.)
            </p><p>
                The basic value types have corresponding <tt class="literal">Type</tt> constants defined on
                <tt class="literal">org.hibernate.Hibernate</tt>. For example, <tt class="literal">Hibernate.STRING</tt>
                represents the <tt class="literal">string</tt> type.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.3.&nbsp;Custom value types</h3></div></div><div></div></div><p>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <tt class="literal">java.lang.BigInteger</tt>
                to <tt class="literal">VARCHAR</tt> columns. Hibernate does not provide a built-in type 
                for this. But custom types are not limited to mapping a property (or collection element) 
                to a single table column. So, for example, you might have a Java property 
                <tt class="literal">getName()</tt>/<tt class="literal">setName()</tt> of type
                <tt class="literal">java.lang.String</tt> that is persisted to the columns 
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>. 
            </p><p>
                To implement a custom type, implement either <tt class="literal">org.hibernate.UserType</tt>
                or <tt class="literal">org.hibernate.CompositeUserType</tt> and declare properties using the
                fully qualified classname of the type. Check out 
                <tt class="literal">org.hibernate.test.DoubleStringType</tt> to see the kind of things that
                are possible.
            </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notice the use of <tt class="literal">&lt;column&gt;</tt> tags to map a property to multiple
                columns.
            </p><p>
                The <tt class="literal">CompositeUserType</tt>, <tt class="literal">EnhancedUserType</tt>,
                <tt class="literal">UserCollectionType</tt>, and <tt class="literal">UserVersionType</tt> 
                interfaces provide support for more specialized uses.
            </p><p>
                You may even supply parameters to a <tt class="literal">UserType</tt> in the mapping file. To 
                do this, your <tt class="literal">UserType</tt> must implement the 
                <tt class="literal">org.hibernate.usertype.ParameterizedType</tt> interface. To supply parameters 
                to your custom type, you can use the <tt class="literal">&lt;type&gt;</tt> element in your mapping 
                files.
            </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">UserType</tt> can now retrieve the value for the parameter named 
                <tt class="literal">default</tt> from the <tt class="literal">Properties</tt> object passed to it.
            </p><p>
                If you use a certain <tt class="literal">UserType</tt> very often, it may be useful to define a 
                shorter name for it. You can do this using the <tt class="literal">&lt;typedef&gt;</tt> element.
                Typedefs assign a name to a custom type, and may also contain a list of default
                parameter values if the type is parameterized.
            </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </p><p>
                Even though Hibernate's rich range of built-in types and support for components means you
                will very rarely <span class="emphasis"><em>need</em></span> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <tt class="literal">MonetaryAmount</tt> class is a good
                candidate for a <tt class="literal">CompositeUserType</tt>, even though it could easily be mapped 
                as a component. One motivation for this is abstraction. With a custom type, your mapping 
                documents would be future-proofed against possible changes in your way of representing 
                monetary values.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.3.&nbsp;SQL quoted identifiers</h2></div></div><div></div></div><p>
                You may force Hibernate to quote an identifier in the generated SQL by enclosing the table or
                column name in backticks in the mapping document. Hibernate will use the correct quotation
                style for the SQL <tt class="literal">Dialect</tt> (usually double quotes, but brackets for SQL
                Server and backticks for MySQL).
            </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-alternatives"></a>5.4.&nbsp;Metadata alternatives</h2></div></div><div></div></div><p>
   	    XML isn't for everyone, and so there are some alternative ways to define O/R mapping metadata in Hibernate.
   	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-xdoclet"></a>5.4.1.&nbsp;Using XDoclet markup</h3></div></div><div></div></div><p>
            Many Hibernate users prefer to embed mapping information directly in sourcecode using
            XDoclet <tt class="literal">@hibernate.tags</tt>. We will not cover this approach in this
            document, since strictly it is considered part of XDoclet. However, we include the
            following example of the <tt class="literal">Cat</tt> class with XDoclet mappings.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>
            See the Hibernate web site for more examples of XDoclet and Hibernate.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-annotations"></a>5.4.2.&nbsp;Using JDK 5.0 Annotations</h3></div></div><div></div></div><p>
            JDK 5.0 introduced XDoclet-style annotations at the language level, type-safe and
            checked at compile time. This mechnism is more powerful than XDoclet annotations and
            better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion
            and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification
            (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans.
            Hibernate3 implements the <tt class="literal">EntityManager</tt> of JSR-220 (the persistence API),
            support for mapping metadata is available via the <span class="emphasis"><em>Hibernate Annotations</em></span>
            package, as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported.
        </p><p>
            This is an example of a POJO class annotated as an EJB entity bean:
        </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Dependent
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL,
               targetEntity="Order")
    @JoinColumn(name="CUSTOMER_ID")
    Set orders;

    // Getter/setter and business methods
}</pre><p>
            Note that support for JDK 5.0 Annotations (and JSR-220) is still work in progress and
            not completed.
        </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapter&nbsp;6.&nbsp;Collection Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Persistent collections</h2></div></div><div></div></div><p>
            Hibernate requires that persistent collection-valued fields be declared
            as an interface type, for example:
        </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>
            The actual interface might be <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.Collection</tt>, <tt class="literal">java.util.List</tt>,
            <tt class="literal">java.util.Map</tt>, <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.SortedMap</tt> or ... anything you like! (Where 
            "anything you like" means you will have to write an implementation of 
            <tt class="literal">org.hibernate.usertype.UserCollectionType</tt>.)
        </p><p>
            Notice how we initialized the instance variable with an instance of
            <tt class="literal">HashSet</tt>. This is the best way to initialize collection
            valued properties of newly instantiated (non-persistent) instances. When
            you make the instance persistent - by calling <tt class="literal">persist()</tt>,
            for example - Hibernate will actually replace the <tt class="literal">HashSet</tt>
            with an instance of Hibernate's own implementation of <tt class="literal">Set</tt>.
            Watch out for errors like this:
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!</pre><p>
            The persistent collections injected by Hibernate behave like
            <tt class="literal">HashMap</tt>, <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>, <tt class="literal">TreeSet</tt> or
            <tt class="literal">ArrayList</tt>, depending upon the interface type.
        </p><p>
            Collections instances have the usual behavior of value types. They are 
            automatically persisted when referenced by a persistent object and 
            automatically deleted when unreferenced. If a collection is passed from one
            persistent object to another, its elements might be moved from one table to
            another. Two entities may not share a reference to the same collection 
            instance. Due to the underlying relational model, collection-valued properties
            do not support null value semantics; Hibernate does not distinguish between 
            a null collection reference and an empty collection.
        </p><p>
            You shouldn't have to worry much about any of this. Use persistent collections 
            the same way you use ordinary Java collections. Just make sure you understand 
            the semantics of bidirectional associations (discussed later).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Collection mappings</h2></div></div><div></div></div><p>
            The Hibernate mapping element used for mapping a collection depends upon
            the type of the interface. For example, a <tt class="literal">&lt;set&gt;</tt> 
            element is used for mapping properties of type <tt class="literal">Set</tt>.
        </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Apart from <tt class="literal">&lt;set&gt;</tt>, there is also 
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>, <tt class="literal">&lt;array&gt;</tt> and
            <tt class="literal">&lt;primitive-array&gt;</tt> mapping elements. The
            <tt class="literal">&lt;map&gt;</tt> element is representative:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="table_name"                                          <span class="co">(2)</span>
    schema="schema_name"                                        <span class="co">(3)</span>
    lazy="true|false"                                           <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|comparatorClass"                     <span class="co">(7)</span>
    order-by="column_name asc|desc"                             <span class="co">(8)</span>
    where="arbitrary sql where condition"                       <span class="co">(9)</span>
    fetch="join|select|subselect"                               <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|ClassName"                           <span class="co">(12)</span>
    optimistic-lock="true|false"                                <span class="co">(13)</span>
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> the collection property name
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optional - defaults to property name) the
                        name of the collection table (not used for one-to-many associations)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optional) the name of a table schema to
                        override the schema declared on the root element
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">true</tt>)
                        enable lazy initialization (not available for arrays)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>)
                        mark this collection as the "inverse" end of a bidirectional association
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>)
                        enable operations to cascade to child entities
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optional) specify a sorted collection with
                        <tt class="literal">natural</tt> sort order, or a given comparator class
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optional, JDK1.4 only) specify a table column (or columns)
                        that define the iteration order of the <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
                        or bag, together with an optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection (useful if the
                        collection should contain only a subset of the available data)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional, defaults to <tt class="literal">select</tt>) Choose
                        between outer-join fetching, fetching by sequential select, and fetching by sequential
                        subselect. Only one collection may be fetched by outer join per SQL 
                        <tt class="literal">SELECT</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a
                        "batch size" for lazily fetching instances of this collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                        strategy Hibernate should use for accessing the property value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                        Species that changes to the state of the collection results in increment of the
                        owning entity's version. (For one to many associations, it is often reasonable to
                        disable this setting.)
                    </p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-foreignkeys"></a>6.2.1.&nbsp;Collection foreign keys</h3></div></div><div></div></div><p>
                Collection instances are distinguished in the database by the foreign key of
                the entity that owns the collection. This foreign key is referred to as the
                <span class="emphasis"><em>collection key column</em></span> (or columns) of the collection 
                table. The collection key column is mapped by the <tt class="literal">&lt;key&gt;</tt> 
                element. 
            </p><p>
                There may be a nullability constraint on the foreign key column. For most
                collections, this is implied. For unidirectional one to many associations,
                the foreign key column is nullable by default, so you might need to specify
                <tt class="literal">not-null="true"</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>
                The foreign key constraint may use <tt class="literal">ON DELETE CASCADE</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p>
                See the previous chapter for a full definition of the <tt class="literal">&lt;key&gt;</tt> 
                element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-elements"></a>6.2.2.&nbsp;Collection elements</h3></div></div><div></div></div><p>
                Collections may contain almost any other Hibernate type, including all basic types,
                custom types, components, and of course, references to other entities. This is an
                important distinction: an object in a collection might be handled with "value" 
                semantics (its lifecycle fully depends on the collection owner) or it might be a
                reference to another entity, with its own lifecycle. In the latter case, only the 
                "link" between the two objects is considered to be state held by the collection. 
            </p><p>
                The contained type is referred to as the <span class="emphasis"><em>collection element type</em></span>. 
                Collection elements are mapped by <tt class="literal">&lt;element&gt;</tt> or
                <tt class="literal">&lt;composite-element&gt;</tt>, or in the case of entity references, 
                with <tt class="literal">&lt;one-to-many&gt;</tt> or <tt class="literal">&lt;many-to-many&gt;</tt>. 
                The first two map elements with value semantics, the next two are used to map entity 
                associations.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexed"></a>6.2.3.&nbsp;Indexed collections</h3></div></div><div></div></div><p>
                All collection mappings, except those with set and bag semantics, need an
                <span class="emphasis"><em>index column</em></span> in the collection table - a column that maps to an
                array index, or <tt class="literal">List</tt> index, or <tt class="literal">Map</tt> key. The
                index of a <tt class="literal">Map</tt> may be of any basic type, mapped with 
                <tt class="literal">&lt;map-key&gt;</tt>, it may be an entity reference mapped with 
                <tt class="literal">&lt;map-key-many-to-many&gt;</tt>, or it may be a composite type,
                mapped with <tt class="literal">&lt;composite-map-key&gt;</tt>. The index of an array or 
                list is always of type <tt class="literal">integer</tt> and is mapped using the 
                <tt class="literal">&lt;list-index&gt;</tt> element. The mapped column contains 
                sequential integers (numbered from zero, by default).
            </p><div class="programlistingco"><pre class="programlisting">&lt;list-index 
        column="column_name"                <span class="co">(1)</span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column_name</tt> (required): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">base</tt> (optional, defaults to <tt class="literal">0</tt>): The value
                        of the index column that corresponds to the first element of the list or array.
                    </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key 
        column="column_name"                <span class="co">(1)</span>
        formula="any SQL expression"        <span class="co">(2)</span>
        type="type_name"                    <span class="co">(3)</span>
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): A SQL formula used to evaluate the
                        key of the map.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (optional, defaults to <tt class="literal">integer</tt>):
                        The type of the collection index.
                    </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"                <span class="co">(1)</span>
        formula="any SQL expression"        <span class="co">(2)</span><span class="co">(3)</span>
        class="ClassName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the foreign key
                        column for the collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): A SQL formula used to evaluate the
                        foreign key of the map key.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The entity class used as the
                        collection index.
                    </p></td></tr></table></div></div><p>
                If your table doesn't have an index column, and you still wish to use <tt class="literal">List</tt> 
                as the property type, you should map the property as a Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>.
                A bag does not retain its order when it is retrieved from the database, but it may be 
                optionally sorted or ordered.
            </p></div><p>
            There are quite a range of mappings that can be generated for collections, covering 
            many common relational models. We suggest you experiment with the schema generation tool 
            to get a feeling for how various mapping declarations translate to database tables.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ofvalues"></a>6.2.4.&nbsp;Collections of values and many-to-many associations</h3></div></div><div></div></div><p>
            Any collection of values or many-to-many association requires a dedicated 
            <span class="emphasis"><em>collection table</em></span> with a foreign key column or columns, 
            <span class="emphasis"><em>collection element column</em></span> or columns and possibly 
            an index column or columns.
        </p><p>
            For a collection of values, we use the <tt class="literal">&lt;element&gt;</tt> tag.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                <span class="co">(1)</span>
        formula="any SQL expression"        <span class="co">(2)</span>
        type="typename"                     <span class="co">(3)</span>
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the column holding the
                        collection element values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): An SQL formula used to evaluate the
                        element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (required): The type of the collection element.
                    </p></td></tr></table></div></div><p>
            A <span class="emphasis"><em>many-to-many association</em></span> is specified using the 
            <tt class="literal">&lt;many-to-many&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span class="co">(1)</span>
        formula="any SQL expression"                       <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        fetch="select|join"                                <span class="co">(4)</span>
        unique="true|false"                                <span class="co">(5)</span>
        entity-name="EntityName"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (optional): The name of the element foreign key column.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">formula</tt> (optional): An SQL formula used to evaluate the element
                        foreign key value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">join</tt>):
                        enables outer-join or sequential select fetching for this association. This
                        is a special case; for full eager fetching (in a single <tt class="literal">SELECT</tt>)
                        of an entity and its many-to-many relationships to other entities, you would
                        enable <tt class="literal">join</tt> fetching not only of the collection itself,
                        but also with this attribute on the <tt class="literal">&lt;many-to-many&gt;</tt>
                        nested element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                        constraint for the foreign-key column. This makes the association multiplicity
                        effectively one to many.
                    </p></td></tr></table></div></div><p>
            Some examples, first, a set of strings:
        </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set&gt;</pre><p>
            A bag containing integers (with an iteration order determined by the
            <tt class="literal">order-by</tt> attribute):
        </p><pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            An array of entities - in this case, a many to many association:
        </p><pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="create"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>
            A map from string indices to dates:
        </p><pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            A list of components (discussed in the next chapter):
        </p><pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-onetomany"></a>6.2.5.&nbsp;One-to-many associations</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>one to many association</em></span> links the tables of two classes
            via a foreign key, with no intervening collection table. This mapping loses 
            certain semantics of normal Java collections:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    An instance of the contained entity class may not belong to more than
                    one instance of the collection
                </p></li><li><p>
                    An instance of the contained entity class may not appear at more than
                    one value of the collection index
                </p></li></ul></div><p>
            An association from <tt class="literal">Product</tt> to <tt class="literal">Part</tt> requires 
            existence of a foreign key column and possibly an index column to the <tt class="literal">Part</tt> 
            table. A <tt class="literal">&lt;one-to-many&gt;</tt> tag indicates that this is a one to many 
            association.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many                                               <span class="co">(1)</span>
        class="ClassName"
        entity-name="EntityName"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr></table></div></div><p>
            Notice that the <tt class="literal">&lt;one-to-many&gt;</tt> element does not need to
            declare any columns. Nor is it necessary to specify the <tt class="literal">table</tt>
            name anywhere.
        </p><p>
            <span class="emphasis"><em>Very important note:</em></span> If the foreign key column of a 
            <tt class="literal">&lt;one-to-many&gt;</tt> association is declared <tt class="literal">NOT NULL</tt>, 
            you must declare the <tt class="literal">&lt;key&gt;</tt> mapping 
            <tt class="literal">not-null="true"</tt> or <span class="emphasis"><em>use a bidirectional association</em></span> 
            with the collection mapping marked <tt class="literal">inverse="true"</tt>. See the discussion 
            of bidirectional associations later in this chapter.
        </p><p>
            This example shows a map of <tt class="literal">Part</tt> entities by name (where
            <tt class="literal">partName</tt> is a persistent property of <tt class="literal">Part</tt>).
            Notice the use of a formula-based index.
        </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-advancedmappings"></a>6.3.&nbsp;Advanced collection mappings</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-sorted"></a>6.3.1.&nbsp;Sorted collections</h3></div></div><div></div></div><p>
            Hibernate supports collections implementing <tt class="literal">java.util.SortedMap</tt> and
            <tt class="literal">java.util.SortedSet</tt>. You must specify a comparator in the mapping file:
        </p><pre class="programlisting">&lt;set name="aliases" 
            table="person_aliases" 
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Allowed values of the <tt class="literal">sort</tt> attribute are <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> and the name of a class implementing
            <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Sorted collections actually behave like <tt class="literal">java.util.TreeSet</tt> or
            <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            If you want the database itself to order the collection elements use the
            <tt class="literal">order-by</tt> attribute of <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            or <tt class="literal">map</tt> mappings. This solution is only available under
            JDK 1.4 or higher (it is implemented using <tt class="literal">LinkedHashSet</tt> or
            <tt class="literal">LinkedHashMap</tt>). This performs the ordering in the SQL query, 
            not in memory.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Note that the value of the <tt class="literal">order-by</tt> attribute is an SQL ordering, not
            a HQL ordering!
        </p><p>
            Associations may even be sorted by some arbitrary criteria at runtime using a collection
            <tt class="literal">filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-bidirectional"></a>6.3.2.&nbsp;Bidirectional associations</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both
            "ends" of the association. Two kinds of bidirectional association are
            supported:

            </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                            set or bag valued at one end, single-valued at the other
                        </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                            set or bag valued at both ends
                        </p></dd></dl></div><p>

        </p><p>
            You may specify a bidirectional many-to-many association simply by mapping two
            many-to-many associations to the same database table and declaring one end as
            <span class="emphasis"><em>inverse</em></span> (which one is your choice, but it can not be an
            indexed collection).
        </p><p>
            Here's an example of a bidirectional many-to-many association; each category can
            have many items and each item can be in many categories:
        </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span>
            persisted. This means that Hibernate has two representations in memory for every
            bidirectional association, one link from A to B and another link from B to A. This
            is easier to understand if you think about the Java object model and how we create
            a many-to-many relationship in Java:
        </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved</pre><p>
            The non-inverse side is used to save the in-memory representation to the database.
        </p><p>
            You may define a bidirectional one-to-many association by mapping a one-to-many association
            to the same table column(s) as a many-to-one association and declaring the many-valued
            end <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
            Mapping one end of an association with <tt class="literal">inverse="true"</tt> doesn't
            affect the operation of cascades, these are orthogonal concepts!
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ternary"></a>6.3.3.&nbsp;Ternary associations</h3></div></div><div></div></div><p>
            There are three possible approaches to mapping a ternary association. One is to use a 
            <tt class="literal">Map</tt> with an association as its index:
        </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>
            A second approach is to simply remodel the association as an entity class. This
            is the approach we use most commonly.
        </p><p>
            A final alternative is to use composite elements, which we will discuss later. 
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-idbag"></a>6.3.4.&nbsp;<tt class="literal">Using an &lt;idbag&gt;</tt></h3></div></div><div></div></div><p>
            If you've fully embraced our view that composite keys are a bad thing and that
            entities should have synthetic identifiers (surrogate keys), then you might
            find it a bit odd that the many to many associations and collections of values
            that we've shown so far all map to tables with composite keys! Now, this point
            is quite arguable; a pure association table doesn't seem to benefit much from
            a surrogate key (though a collection of composite values <span class="emphasis"><em>might</em></span>).
            Nevertheless, Hibernate provides a feature that allows you to map many to many
            associations and collections of values to a table with a surrogate key.
        </p><p>
            The <tt class="literal">&lt;idbag&gt;</tt> element lets you map a <tt class="literal">List</tt>
            (or <tt class="literal">Collection</tt>) with bag semantics.
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="eg.Person" outer-join="true"/&gt;
&lt;/idbag&gt;</pre><p>
            As you can see, an <tt class="literal">&lt;idbag&gt;</tt> has a synthetic id generator,
            just like an entity class! A different surrogate key is assigned to each collection
            row. Hibernate does not provide any mechanism to discover the surrogate key value
            of a particular row, however.
        </p><p>
            Note that the update performance of an <tt class="literal">&lt;idbag&gt;</tt> is
            <span class="emphasis"><em>much</em></span> better than a regular <tt class="literal">&lt;bag&gt;</tt>!
            Hibernate can locate individual rows efficiently and update or delete them
            individually, just like a list, map or set.
        </p><p>
            In the current implementation, the <tt class="literal">native</tt> identifier generation
            strategy is not supported for <tt class="literal">&lt;idbag&gt;</tt> collection identifiers.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.4.&nbsp;Collection examples</h2></div></div><div></div></div><p>
            The previous sections are pretty confusing. So lets look at an example. This
            class:
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            has a collection of <tt class="literal">Child</tt> instances. If each
            child has at most one parent, the most natural mapping is a 
            one-to-many association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            This maps to the following table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            If the parent is <span class="emphasis"><em>required</em></span>, use a bidirectional one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notice the <tt class="literal">NOT NULL</tt> constraint:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Alternatively, if you absolutely insist that this association should be unidirectional,
            you can declare the <tt class="literal">NOT NULL</tt> constraint on the <tt class="literal">&lt;key&gt;</tt>
            mapping:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>
            For more examples and a complete walk-through a parent/child relationship mapping,
            see <a href="#example-parentchild" title="Chapter&nbsp;21.&nbsp;Example: Parent/Child">Chapter&nbsp;21, <i>Example: Parent/Child</i></a>.
        </p><p>
            Even more exotic association mappings are possible, we will catalog all possibilities
            in the next chapter.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="associations"></a>Chapter&nbsp;7.&nbsp;Association Mappings</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-intro"></a>7.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
            Association mappings are the often most difficult thing to get right. In
            this section we'll go through the canonical cases one by one, starting
            with unidirectional mappings, and then considering the bidirectional cases.
            We'll use <tt class="literal">Person</tt> and <tt class="literal">Address</tt> in all
            the examples.
        </p><p>
        	We'll classify associations by whether or not they map to an intervening
        	join table, and by multiplicity.
        </p><p>
        	Nullable foreign keys are not considered good practice in traditional data
        	modelling, so all our examples use not null foreign keys. This is not a
        	requirement of Hibernate, and the mappings will all work if you drop the
        	nullability constraints.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-unidirectional"></a>7.2.&nbsp;Unidirectional associations</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-m21"></a>7.2.1.&nbsp;many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional many-to-one association</em></span> is the most 
            common kind of unidirectional association.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-121"></a>7.2.2.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-one association on a foreign key</em></span>
            is almost identical. The only difference is the column unique constraint.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            A <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span>
            usually uses a special id generator. (Notice that we've reversed the direction
            of the association in this example.)
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-12m"></a>7.2.3.&nbsp;one to many</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> 
            is a very unusual case, and is not really recommended.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>
            We think it's better to use a join table for this kind of association.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-unidirectional-join"></a>7.3.&nbsp;Unidirectional associations with join tables</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-12m"></a>7.3.1.&nbsp;one to many</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> 
            is much preferred. Notice that by specifying <tt class="literal">unique="true"</tt>,
            we have changed the multiplicity from many-to-many to one-to-many.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-m21"></a>7.3.2.&nbsp;many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> 
            is quite common when the association is optional.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-121"></a>7.3.3.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> 
            is extremely unusual, but possible.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-unidirectional-join-m2m"></a>7.3.4.&nbsp;many to many</h3></div></div><div></div></div><p>
            Finally, we have a <span class="emphasis"><em>unidirectional many-to-many association</em></span>.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-bidirectional"></a>7.4.&nbsp;Bidirectional associations</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-m21"></a>7.4.1.&nbsp;one to many / many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the
            most common kind of association. (This is the standard parent/child
            relationship.)
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-121"></a>7.4.2.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span>
            is quite common.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>
            A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span>
            uses the special id generator.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc-bidirectional-join"></a>7.5.&nbsp;Bidirectional associations with join tables</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-12m"></a>7.5.1.&nbsp;one to many / many to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional one-to-many association on a join table</em></span>.
            Note that the <tt class="literal">inverse="true"</tt> can go on either end of the
            association, on the collection, or on the join.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-121"></a>7.5.2.&nbsp;one to one</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> 
            is extremely unusual, but possible.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assoc-bidirectional-join-m2m"></a>7.5.3.&nbsp;many to many</h3></div></div><div></div></div><p>
            Finally, we have a <span class="emphasis"><em>bidirectional many-to-many association</em></span>.
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapter&nbsp;8.&nbsp;Component Mapping</h2></div></div><div></div></div><p>
        The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts,
        for different purposes, throughout Hibernate.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>8.1.&nbsp;Dependent objects</h2></div></div><div></div></div><p>
            A component is a contained object that is persisted as a value type, not an entity
            reference. The term "component" refers to the object-oriented notion of composition
            (not to architecture-level components). For example, you might model a person like this:
        </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>
            Now <tt class="literal">Name</tt> may be persisted as a component of
            <tt class="literal">Person</tt>. Notice that <tt class="literal">Name</tt> defines getter
            and setter methods for its persistent properties, but doesn't need to declare
            any interfaces or identifier properties.
        </p><p>
            Our Hibernate mapping would look like:
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            The person table would have the columns <tt class="literal">pid</tt>,
            <tt class="literal">birthday</tt>,
            <tt class="literal">initial</tt>,
            <tt class="literal">first</tt> and
            <tt class="literal">last</tt>.
        </p><p>
            Like all value types, components do not support shared references. In other words, two
            persons could have the same name, but the two person objects would contain two independent
            name ojects, only "the same" by value. The null value semantics of a component are
            <span class="emphasis"><em>ad hoc</em></span>. When reloading the containing object, Hibernate will assume
            that if all component columns are null, then the entire component is null. This should
            be okay for most purposes.
        </p><p>
            The properties of a component may be of any Hibernate type (collections, many-to-one 
            associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> 
            be considered an exotic usage. Hibernate is intended to support a very fine-grained 
            object model.
        </p><p>
            The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
            subelement that maps a property of the component class as a reference back to the
            containing entity.
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>8.2.&nbsp;Collections of dependent objects</h2></div></div><div></div></div><p>
            Collections of components are supported (eg. an array of type
            <tt class="literal">Name</tt>). Declare your component collection by
            replacing the <tt class="literal">&lt;element&gt;</tt> tag with a
            <tt class="literal">&lt;composite-element&gt;</tt> tag.
        </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Note: if you define a <tt class="literal">Set</tt> of composite elements, it is 
            very important to implement <tt class="literal">equals()</tt> and 
            <tt class="literal">hashCode()</tt> correctly.
        </p><p>
            Composite elements may contain components but not collections. If your
            composite element itself contains 
            components, use the <tt class="literal">&lt;nested-composite-element&gt;</tt> 
            tag. This is a pretty exotic case - a collection of components which 
            themselves have components. By this stage you should be asking yourself 
            if a one-to-many association is more appropriate. Try remodelling the 
            composite element as an entity - but note that even though the Java model 
            is the same, the relational model and persistence semantics are still 
            slightly different.
        </p><p>
            Please note that a composite element mapping doesn't support null-able properties
            if you're using a <tt class="literal">&lt;set&gt;</tt>. Hibernate
            has to use each columns value to identify a record when deleting objects
            (there is no separate primary key column in the composite element table),
            which is not possible with null values. You have to either use only
            not-null properties in a composite-element or choose a
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> or <tt class="literal">&lt;idbag&gt;</tt>.
        </p><p>
            A special case of a composite element is a composite element with a nested
            <tt class="literal">&lt;many-to-one&gt;</tt> element. A mapping like this allows
            you to map extra columns of a many-to-many association table to the
            composite element class. The following is a many-to-many association
            from <tt class="literal">Order</tt> to <tt class="literal">Item</tt> where 
            <tt class="literal">purchaseDate</tt>, <tt class="literal">price</tt> and
            <tt class="literal">quantity</tt> are properties of the association:
        </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Of course, there can't be a reference to the purchae on the other side, for
            bidirectional association navigation. Remember that components are value types and
            don't allow shared references. A single <tt class="literal">Purchase</tt> can be in the
            set of an <tt class="literal">Order</tt>, but it can't be referenced by the <tt class="literal">Item</tt>
            at the same time.
        </p><p>Even ternary (or quaternary, etc) associations are possible:</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Composite elements may appear in queries using the same syntax as
            associations to other entities.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>8.3.&nbsp;Components as Map indices</h2></div></div><div></div></div><p>
            The <tt class="literal">&lt;composite-map-key&gt;</tt> element lets you map a
            component class as the key of a <tt class="literal">Map</tt>. Make sure you override
            <tt class="literal">hashCode()</tt> and <tt class="literal">equals()</tt> correctly on
            the component class.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>8.4.&nbsp;Components as composite identifiers</h2></div></div><div></div></div><p>
            You may use a component as an identifier of an entity class. Your component
            class must satisfy certain requirements:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It must implement <tt class="literal">java.io.Serializable</tt>.
                </p></li><li><p>
                    It must re-implement <tt class="literal">equals()</tt> and
                    <tt class="literal">hashCode()</tt>, consistently with the database's 
                    notion of composite key equality.
                </p></li></ul></div><p>
            <span class="emphasis"><em>Note: in Hibernate3, the second requirement is not an absolutely hard
            requirement of Hibernate. But do it anyway.</em></span>
        </p><p>
            You can't use an <tt class="literal">IdentifierGenerator</tt> to generate composite keys.
            Instead the application must assign its own identifiers.
        </p><p>
            Use the <tt class="literal">&lt;composite-id&gt;</tt> tag (with nested 
            <tt class="literal">&lt;key-property&gt;</tt> elements) in place of the usual 
            <tt class="literal">&lt;id&gt;</tt> declaration. For example, the
            <tt class="literal">OrderLine</tt> class has a primary key that depends upon
            the (composite) primary key of <tt class="literal">Order</tt>.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class&gt;</pre><p>
            Now, any foreign keys referencing the <tt class="literal">OrderLine</tt> table are also 
            composite. You must declare this in your mappings for other classes. An association 
            to <tt class="literal">OrderLine</tt> would be mapped like this:
        </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><p>
            (Note that the <tt class="literal">&lt;column&gt;</tt> tag is an alternative to the 
            <tt class="literal">column</tt> attribute everywhere.) 
        </p><p>
            A <tt class="literal">many-to-many</tt> association to <tt class="literal">OrderLine</tt> also
            uses the composite foreign key:
        </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            The collection of <tt class="literal">OrderLine</tt>s in <tt class="literal">Order</tt> would 
            use:
        </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>
            (The <tt class="literal">&lt;one-to-many&gt;</tt> element, as usual, declares no columns.)
        </p><p>
            If <tt class="literal">OrderLine</tt> itself owns a collection, it also has a composite 
            foreign key.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>8.5.&nbsp;Dynamic components</h2></div></div><div></div></div><p>
            You may even map a property of type <tt class="literal">Map</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO"/&gt;
    &lt;property name="bar" column="BAR"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            The semantics of a <tt class="literal">&lt;dynamic-component&gt;</tt> mapping are identical
            to <tt class="literal">&lt;component&gt;</tt>. The advantage of this kind of mapping is 
            the ability to determine the actual properties of the bean at deployment time, just
            by editing the mapping document. Runtime manipulation of the mapping document is 
            also possible, using a DOM parser. Even better, you can access (and change) Hibernate's
            configuration-time metamodel via the <tt class="literal">Configuration</tt> object.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapter&nbsp;9.&nbsp;Inheritance Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>9.1.&nbsp;The Three Strategies</h2></div></div><div></div></div><p>
            Hibernate supports the three basic inheritance mapping strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            table per class hierarchy
        </p></li><li><p>
            table per subclass
        </p></li><li><p>
            table per concrete class
        </p></li></ul></div><p>
            In addition, Hibernate supports a fourth, slightly different kind of 
            polymorphism:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            implicit polymorphism
        </p></li></ul></div><p>
            It is possible to use different mapping strategies for different
            branches of the same inheritance hierarchy, and then make use of implicit
            polymorphism to achieve polymorphism across the whole hierarchy. However, 
            Hibernate does not support mixing <tt class="literal">&lt;subclass&gt;</tt>,
            and <tt class="literal">&lt;joined-subclass&gt;</tt> and 
            <tt class="literal">&lt;union-subclass&gt;</tt> mappings under the same root
            <tt class="literal">&lt;class&gt;</tt> element. It is possible to mix together
            the table per hierarchy and table per subclass strategies, under the
            the same <tt class="literal">&lt;class&gt;</tt> element, by combining the 
            <tt class="literal">&lt;subclass&gt;</tt> and <tt class="literal">&lt;join&gt;</tt>
            elements (see below).
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperclass"></a>9.1.1.&nbsp;Table per class hierarchy</h3></div></div><div></div></div><p>
            Suppose we have an interface <tt class="literal">Payment</tt>, with implementors
            <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. The table per hierarchy mapping would
            look like:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Exactly one table is required. There is one big limitation of this mapping 
            strategy: columns declared by the subclasses, such as <tt class="literal">CCTYPE</tt>, 
            may not have <tt class="literal">NOT NULL</tt> constraints.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass"></a>9.1.2.&nbsp;Table per subclass</h3></div></div><div></div></div><p>
            A table per subclass mapping would look like:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Four tables are required. The three subclass tables have primary
            key associations to the superclass table (so the relational model
            is actually a one-to-one association).
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass-discriminator"></a>9.1.3.&nbsp;Table per subclass, using a discriminator</h3></div></div><div></div></div><p>
            Note that Hibernate's implementation of table per subclass requires
            no discriminator column. Other object/relational mappers use a
            different implementation of table per subclass which requires a type
            discriminator column in the superclass table. The approach taken by
            Hibernate is much more difficult to implement but arguably more
            correct from a relational point of view. If you would like to use
            a discriminator column with the table per subclass strategy, you
            may combine the use of <tt class="literal">&lt;subclass&gt;</tt> and 
            <tt class="literal">&lt;join&gt;</tt>, as follow:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            The optional <tt class="literal">fetch="select"</tt> declaration tells Hibernate 
            not to fetch the <tt class="literal">ChequePayment</tt> subclass data using an
            outer join when querying the superclass.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-mixing-tableperclass-tablepersubclass"></a>9.1.4.&nbsp;Mixing table per class hierarchy with table per subclass</h3></div></div><div></div></div><p>
            You may even mix the table per hierarchy and table per subclass strategies
            using this approach:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            For any of these mapping strategies, a polymorphic association to the root
            <tt class="literal">Payment</tt> class is mapped using 
            <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcrete"></a>9.1.5.&nbsp;Table per concrete class</h3></div></div><div></div></div><p>
            There are two ways we could go about mapping the table per concrete class
            strategy. The first is to use <tt class="literal">&lt;union-subclass&gt;</tt>.
        </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>
            Three tables are involved. Each table defines columns for all properties
            of the class, including inherited properties. 
        </p><p>
            The limitation of this approach is that if a property is mapped on the 
            superclass, the column name must be the same on all subclass tables.
            (We might relax this in a future release of Hibernate.)
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcreate-polymorphism"></a>9.1.6.&nbsp;Table per concrete class, using implicit polymorphism</h3></div></div><div></div></div><p>
            An alternative approach is to make use of implicit polymorphism:
        </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Notice that nowhere do we mention the <tt class="literal">Payment</tt> interface 
            explicitly. Also notice that properties of <tt class="literal">Payment</tt> are 
            mapped in each of the subclasses. If you want to avoid duplication, consider
            using XML entities
            (e.g. <tt class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</tt>
            in the <tt class="literal">DOCTYPE</tt> declartion and 
            <tt class="literal">&amp;allproperties;</tt> in the mapping).
        </p><p>
            The disadvantage of this approach is that Hibernate does not generate SQL
            <tt class="literal">UNION</tt>s when performing polymorphic queries.
        </p><p>
            For this mapping strategy, a polymorphic association to <tt class="literal">Payment</tt> 
            is usually mapped using <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritace-mixingpolymorphism"></a>9.1.7.&nbsp;Mixing implicit polymorphism with other inheritance mappings</h3></div></div><div></div></div><p>
            There is one further thing to notice about this mapping. Since the subclasses 
            are each mapped in their own <tt class="literal">&lt;class&gt;</tt> element (and since
            <tt class="literal">Payment</tt> is just an interface), each of the subclasses could 
            easily be part of another inheritance hierarchy! (And you can still use polymorphic
            queries against the <tt class="literal">Payment</tt> interface.)
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Once again, we don't mention <tt class="literal">Payment</tt> explicitly. If we
            execute a query against the <tt class="literal">Payment</tt> interface - for
            example, <tt class="literal">from Payment</tt> - Hibernate
            automatically returns instances of <tt class="literal">CreditCardPayment</tt>
            (and its subclasses, since they also implement <tt class="literal">Payment</tt>),
            <tt class="literal">CashPayment</tt> and <tt class="literal">ChequePayment</tt> but
            not instances of <tt class="literal">NonelectronicTransaction</tt>.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>9.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            There are certain limitations to the "implicit polymorphism" approach to
            the table per concrete-class mapping strategy. There are somewhat less
            restrictive limitations to <tt class="literal">&lt;union-subclass&gt;</tt>
            mappings.
        </p><p>
            The following table shows the limitations of table per concrete-class
            mappings, and of implicit polymorphism, in Hibernate.
        </p><div class="table"><a name="d0e7133"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Features of inheritance mappings</b></p><table summary="Features of inheritance mappings" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Inheritance strategy</th><th align="left">Polymorphic many-to-one</th><th align="left">Polymorphic one-to-one</th><th align="left">Polymorphic one-to-many</th><th align="left">Polymorphic many-to-many</th><th align="left">Polymorphic <tt class="literal">load()/get()</tt></th><th align="left">Polymorphic queries</th><th align="left">Polymorphic joins</th><th align="left">Outer join fetching</th></tr></thead><tbody><tr><td align="left">table per class-hierarchy</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete-class (union-subclass)</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt> (for <tt class="literal">inverse="true"</tt> only)</td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete class (implicit polymorphism)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><tt class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="objectstate"></a>Chapter&nbsp;10.&nbsp;Working with objects</h2></div></div><div></div></div><p>
        Hibernate is a full object/relational mapping solution that not only shields
        the developer from the details of the underlying database management
        system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is,
        contrary to the management of SQL <tt class="literal">statements</tt> in common JDBC/SQL
        persistence layers, a very natural object-oriented view of persistence in Java
        applications.
    </p><p>
        In other words, Hibernate application developers should always think about the
        <span class="emphasis"><em>state</em></span> of their objects, and not necessarily about the
        execution of SQL statements. This part is taken care of by Hibernate and is only
        relevant for the application developer when tuning the performance of the system.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-overview"></a>10.1.&nbsp;Hibernate object states</h2></div></div><div></div></div><p>
            Hibernate defines and supports the following object states:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Transient</em></span> - an object is transient if it has just
                    been instantiated using the <tt class="literal">new</tt> operator, and it
                    is not associated with a Hibernate <tt class="literal">Session</tt>. It has no
                    persistent representation in the database and no identifier value has been
                    assigned. Transient instances will be destroyed by the garbage collector if
                    the application doesn't hold a reference anymore. Use the Hibernate
                    <tt class="literal">Session</tt> to make an object persistent (and let Hibernate
                    take care of the SQL statements that need to be executed for this transition).
                </p></li><li><p>
                    <span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation
                    in the database and an identifier value. It might just have been saved or loaded,
                    however, it is by definition in the scope of a <tt class="literal">Session</tt>.
                    Hibernate will detect any changes made to an object in persistent state and
                    synchronize the state with the database when the unit of work completes.
                    Developers don't execute manual <tt class="literal">UPDATE</tt> statements, or
                    <tt class="literal">DELETE</tt> statements when an object should be made transient.
                </p></li><li><p>
                    <span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been
                    persistent, but its <tt class="literal">Session</tt> has been closed. The reference
                    to the object is still valid, of course, and the detached instance might even
                    be modified in this state. A detached instance can be reattached to a new
                    <tt class="literal">Session</tt> at a later point in time, making it (and all the
                    modifications) persistent again. This feature enables a programming model for
                    long running units of work that require user think-time. We call them
                    <span class="emphasis"><em>application transactions</em></span>, i.e. a unit of work from the
                    point of view of the user.
                </p></li></ul></div><p>
            We'll now discuss the states and state transitions (and the Hibernate methods that
            trigger a transition) in more detail.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-makingpersistent"></a>10.2.&nbsp;Making objects persistent</h2></div></div><div></div></div><p>
            Newly instantiated instances of a a persistent class are considered 
            <span class="emphasis"><em>transient</em></span> by Hibernate. We can make a transient 
            instance <span class="emphasis"><em>persistent</em></span> by associating it with a 
            session:
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>
            If <tt class="literal">Cat</tt> has a generated identifier, the identifier is
            generated and assigned to the <tt class="literal">cat</tt> when <tt class="literal">save()</tt> 
            is called. If <tt class="literal">Cat</tt> has an <tt class="literal">assigned</tt>
            identifier, or a composite key, the identifier should be assigned to 
            the <tt class="literal">cat</tt> instance before calling <tt class="literal">save()</tt>.
            You may also use <tt class="literal">persist()</tt> instead of <tt class="literal">save()</tt>,
            with the semantics defined in the EJB3 early draft.
        </p><p>
            Alternatively, you may assign the identifier using an overloaded version
            of <tt class="literal">save()</tt>.
        </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>
            If the object you make persistent has associated objects (e.g. the
            <tt class="literal">kittens</tt> collection in the previous example),
            these objects may be made persistent in any order you like unless you
            have a <tt class="literal">NOT NULL</tt> constraint upon a foreign key column.
            There is never a risk of violating foreign key constraints. However, you 
            might violate a <tt class="literal">NOT NULL</tt> constraint if you
            <tt class="literal">save()</tt> the objects in the wrong order.
        </p><p>
            Usually you don't bother with this detail, as you'll very likely use Hibernate's
            <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated
            objects automatically. Then, even <tt class="literal">NOT NULL</tt>
            constraint violations don't occur - Hibernate will take care of everything.
            Transitive persistence is discussed later in this chapter.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-loading"></a>10.3.&nbsp;Loading an object</h2></div></div><div></div></div><p>
            The <tt class="literal">load()</tt> methods of <tt class="literal">Session</tt> gives you
            a way to retrieve a persistent instance if you already know its identifier. 
            <tt class="literal">load()</tt> takes a class object and will load the state into 
            a newly instantiated instance of that class, in persistent state.
        </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );</pre><p>
            Alternatively, you can load state into a given instance:
        </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>
            Note that <tt class="literal">load()</tt> will throw an unrecoverable exception if 
            there is no matching database row. If the class is mapped with a proxy, 
            <tt class="literal">load()</tt> just returns an uninitialized proxy and does not 
            actually hit the database until you invoke a method of the proxy. This 
            behaviour is very useful if you wish to create an association to an object
            without actually loading it from the database. It also allows multiple
            instances to be loaded as a batch if <tt class="literal">batch-size</tt> is
            defined for the class mapping.
        </p><p>
            If you are not certain that a matching row exists, you should use the 
            <tt class="literal">get()</tt> method, which hits the database immediately and 
            returns null if there is no matching row.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>
            You may even load an object using an SQL <tt class="literal">SELECT ... FOR UPDATE</tt>,
            using a <tt class="literal">LockMode</tt>. See the API documentation for more information.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>
            Note that any associated instances or contained collections are 
            <span class="emphasis"><em>not</em></span> selected <tt class="literal">FOR UPDATE</tt>, unless you decide
            to specify <tt class="literal">lock</tt> or <tt class="literal">all</tt> as a
            cascade style for the association.
        </p><p>
            It is possible to re-load an object and all its collections at any time, using the 
            <tt class="literal">refresh()</tt> method. This is useful when database triggers are used to
            initialize some of the properties of the object.
        </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>
            An important question usually appears at this point: How much does Hibernate load
            from the database and how many SQL <tt class="literal">SELECT</tt>s will it use? This
            depends on the <span class="emphasis"><em>fetching strategy</em></span> and is explained in
            <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-querying"></a>10.4.&nbsp;Querying</h2></div></div><div></div></div><p>
            If you don't know the identifiers of the objects you are looking for, 
            you need a query. Hibernate supports an easy-to-use but powerful object 
            oriented query language (HQL). For programmatic query creation, Hibernate
            supports a sophisticated Criteria and Example query feature (QBC and QBE).
            You may also express your query in the native SQL of your database, with
            optional support from Hibernate for result set conversion into objects.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-querying-executing"></a>10.4.1.&nbsp;Executing queries</h3></div></div><div></div></div><p>
                HQL and native SQL queries are represented with an instance of <tt class="literal">org.hibernate.Query</tt>.
                This interface offers methods for parameter binding, result set handling, and for the execution
                of the actual query. You always obtain a <tt class="literal">Query</tt> using the current
                <tt class="literal">Session</tt>:
            </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();</pre><p>
                A query is usually executed by invoking <tt class="literal">list()</tt>, the
                result of the query will be loaded completely into a collection in memory.
                Entity instances retrieved by a query are in persistent state. The
                <tt class="literal">uniqueResult()</tt> method offers a shortcut if you
                know your query will only return a single object.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-iterate"></a>10.4.1.1.&nbsp;Iterating results</h4></div></div><div></div></div><p>
                    Occasionally, you might be able to achieve better performance by
                    executing the query using the <tt class="literal">iterate()</tt> method.
                    This will only usually be the case if you expect that the actual
                    entity instances returned by the query will already be in the session
                    or second-level cache. If they are not already cached,
                    <tt class="literal">iterate()</tt> will be slower than <tt class="literal">list()</tt>
                    and might require many database hits for a simple query, usually
                    <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers,
                    and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances.
                </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-tuples"></a>10.4.1.2.&nbsp;Queries that return tuples</h4></div></div><div></div></div><p>
                    Hibernate queries sometimes return tuples of objects, in which case each tuple
                    is returned as an array:
                </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten  = tuple[0];
    Cat mother  = tuple[1];
    ....
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-scalar"></a>10.4.1.3.&nbsp;Scalar results</h4></div></div><div></div></div><p>
                    Queries may specify a property of a class in the <tt class="literal">select</tt> clause.
                    They may even call SQL aggregate functions. Properties or aggregates are considered
                    "scalar" results (and not entities in persistent state).
                </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-parameters"></a>10.4.1.4.&nbsp;Bind parameters</h4></div></div><div></div></div><p>
                    Methods on <tt class="literal">Query</tt> are provided for binding values to
                    named parameters or JDBC-style <tt class="literal">?</tt> parameters. 
                    <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span>
                    Named parameters are identifiers of the form <tt class="literal">:name</tt> in 
                    the query string. The advantages of named parameters are:
                </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                            named parameters are insensitive to the order they occur in the
                            query string
                        </p></li><li><p>
                            they may occur multiple times in the same query
                        </p></li><li><p>
                            they are self-documenting
                        </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-pagination"></a>10.4.1.5.&nbsp;Pagination</h4></div></div><div></div></div><p>
                    If you need to specify bounds upon your result set (the maximum number of rows
                    you want to retrieve and / or the first row you want to retrieve) you should
                    use methods of the <tt class="literal">Query</tt> interface:
                </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>
                    Hibernate knows how to translate this limit query into the native
                    SQL of your DBMS.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-scrolling"></a>10.4.1.6.&nbsp;Scrollable iteration</h4></div></div><div></div></div><p>
                    If your JDBC driver supports scrollable <tt class="literal">ResultSet</tt>s, the
                    <tt class="literal">Query</tt> interface may be used to obtain a
                    <tt class="literal">ScrollableResults</tt> object, which allows flexible
                    navigation of the query results.
                </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>
                    Note that an open database connection (and cursor) is required for this
                    functionality, use <tt class="literal">setMaxResult()</tt>/<tt class="literal">setFirstResult()</tt>
                    if you need offline pagination functionality.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="objectstate-querying-executing-named"></a>10.4.1.7.&nbsp;Externalizing named queries</h4></div></div><div></div></div><p>
                    You may also define named queries in the mapping document. (Remember to use a
                    <tt class="literal">CDATA</tt> section if your query contains characters that could
                    be interpreted as markup.)
                </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>
                    Parameter binding and executing is done programatically:
                </p><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>
                    Note that the actual program code is independent of the query language that
                    is used, you may also define native SQL queries in metadata, or migrate
                    existing queries to Hibernate by placing them in mapping files.
                </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-filtering"></a>10.4.2.&nbsp;Filtering collections</h3></div></div><div></div></div><p>
                A collection <span class="emphasis"><em>filter</em></span> is a special type of query that may be applied to
                a persistent collection or array. The query string may refer to <tt class="literal">this</tt>,
                meaning the current collection element.
            </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>
                The returned collection is considered a bag, and it's a copy of the given
                collection. The original collection is not modified (this is contrary to
                the implication of the name "filter", but consistent with expected behavior).
            </p><p>
                Observe that filters do not require a <tt class="literal">from</tt> clause (though they may have
                one if required). Filters are not limited to returning the collection elements themselves.
            </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>
                Even an empty filter query is useful, e.g. to load a subset of elements in a
                huge collection:
            </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objecstate-querying-criteria"></a>10.4.3.&nbsp;Criteria queries</h3></div></div><div></div></div><p>
                HQL is extremely powerful but some developers prefer to build queries dynamically,
                using an object-oriented API, rather than building query strings. Hibernate provides
                an intuitive <tt class="literal">Criteria</tt> query API for these cases:
            </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>
                The <tt class="literal">Criteria</tt> and the associated <tt class="literal">Example</tt>
                API are discussed in more detail in <a href="#querycriteria" title="Chapter&nbsp;15.&nbsp;Criteria Queries">Chapter&nbsp;15, <i>Criteria Queries</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objectstate-querying-nativesql"></a>10.4.4.&nbsp;Queries in native SQL</h3></div></div><div></div></div><p>
                You may express a query in SQL, using <tt class="literal">createSQLQuery()</tt> and
                let Hibernate take care of the mapping from result sets to objects. Note
                that you may at any time call <tt class="literal">session.connection()</tt> and
                use the JDBC <tt class="literal">Connection</tt> directly. If you chose to use the
                Hibernate API, you must enclose SQL aliases in braces:
            </p><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list()</pre><p>
                SQL queries may contain named and positional parameters, just like Hibernate queries.
                More information about native SQL queries in Hibernate can be found in
                <a href="#querysql" title="Chapter&nbsp;16.&nbsp;Native SQL">Chapter&nbsp;16, <i>Native SQL</i></a>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-modifying"></a>10.5.&nbsp;Modifying persistent objects</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Transactional persistent instances</em></span> (ie. objects loaded, saved, created or
            queried by the <tt class="literal">Session</tt>) may be manipulated by the application
            and any changes to persistent state will be persisted when the <tt class="literal">Session</tt>
            is <span class="emphasis"><em>flushed</em></span> (discussed later in this chapter). There is no need
            to call a particular method (like <tt class="literal">update()</tt>, which has a different
            purpose) to make your modifications persistent. So the most straightforward way to update
            the state of an object is to <tt class="literal">load()</tt> it,
            and then manipulate it directly, while the <tt class="literal">Session</tt> is open:
        </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>
            Sometimes this programming model is inefficient since it would require both an SQL
            <tt class="literal">SELECT</tt> (to load an object) and an SQL <tt class="literal">UPDATE</tt>
            (to persist its updated state) in the same session. Therefore Hibernate offers an
            alternate approach, using detached instances.
        </p><p>
            <span class="emphasis"><em>Note that Hibernate does not offer its own API for direct execution of
            <tt class="literal">UPDATE</tt> or <tt class="literal">DELETE</tt> statements. Hibernate is a
            <span class="emphasis"><em>state management</em></span> service, you don't have to think in
            <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing
            SQL statements, you can get a JDBC <tt class="literal">Connection</tt> at any time
            by calling <tt class="literal">session.connection()</tt>. Furthermore, the notion
            of mass operations conflicts with object/relational mapping for online
            transaction processing-oriented applications. Future versions of Hibernate
            may however provide special mass operation functions. See <a href="#batch" title="Chapter&nbsp;13.&nbsp;Batch processing">Chapter&nbsp;13, <i>Batch processing</i></a>
            for some possible batch operation tricks.</em></span>
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-detached"></a>10.6.&nbsp;Modifying detached objects</h2></div></div><div></div></div><p>
            Many applications need to retrieve an object in one transaction, send it to the
            UI layer for manipulation, then save the changes in a new transaction.
            Applications that use this kind of approach in a high-concurrency environment
            usually use versioned  data to ensure isolation for the "long" unit of work.
        </p><p>
            Hibernate supports this model by providing for reattachment of detached instances
            using the <tt class="literal">Session.update()</tt> or <tt class="literal">Session.merge()</tt>
            methods:
        </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>
            If the <tt class="literal">Cat</tt> with identifier <tt class="literal">catId</tt> had already
            been loaded  by <tt class="literal">secondSession</tt> when the application tried to
            reattach it, an exception would have been thrown.
        </p><p>
            Use <tt class="literal">update()</tt> if you are sure that the session does
            not contain an already persistent instance with the same identifier, and
            <tt class="literal">merge()</tt> if you want to merge your modifications at any time
            without consideration of the state of the session. In other words, <tt class="literal">update()</tt>
            is usually the first method you would call in a fresh session, ensuring that
            reattachment of your detached instances is the first operation that is executed.
        </p><p>
            The application should individually <tt class="literal">update()</tt> detached instances
            reachable from the given detached instance if and <span class="emphasis"><em>only</em></span> if it wants
            their state also updated. This can be automated of course, using <span class="emphasis"><em>transitive
            persistence</em></span>, see <a href="#objectstate-transitive" title="10.11.&nbsp;Transitive persistence">Section&nbsp;10.11, &#8220;Transitive persistence&#8221;</a>.
        </p><p>
            The <tt class="literal">lock()</tt> method also allows an application to reassociate
            an object with a new session. However, the detached instance has to be unmodified!
        </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>
            Note that <tt class="literal">lock()</tt> can be used with various
            <tt class="literal">LockMode</tt>s, see the API documentation and the
            chapter on transaction handling for more information. Reattachment is not
            the only usecase for <tt class="literal">lock()</tt>.
        </p><p>
            Other models for long units of work are discussed in <a href="#transactions-optimistic" title="11.3.&nbsp;Optimistic concurrency control">Section&nbsp;11.3, &#8220;Optimistic concurrency control&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-saveorupdate"></a>10.7.&nbsp;Automatic state detection</h2></div></div><div></div></div><p>
            Hibernate users have requested a general purpose method that either saves a
            transient instance by generating a new identifier or updates/reattaches
            the detached instances associated with its current identifier.
            The <tt class="literal">saveOrUpdate()</tt> method implements this functionality.
        </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>
            The usage and semantics of <tt class="literal">saveOrUpdate()</tt> seems to be confusing
            for new users. Firstly, so long as you are not trying to use instances from one session
            in another new session, you should not need to use <tt class="literal">update()</tt>,
            <tt class="literal">saveOrUpdate()</tt>, or <tt class="literal">merge()</tt>. Some whole
            applications will never use either of these methods.
        </p><p>
            Usually <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt> are used in
            the following scenario:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    the application loads an object in the first session
                </p></li><li><p>
                    the object is passed up to the UI tier
                </p></li><li><p>
                    some modifications are made to the object
                </p></li><li><p>
                    the object is passed back down to the business logic tier
                </p></li><li><p>
                    the application persists these modifications by calling
                    <tt class="literal">update()</tt> in a second session
                </p></li></ul></div><p>
            <tt class="literal">saveOrUpdate()</tt> does the following:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    if the object is already persistent in this session, do nothing
                </p></li><li><p>
                    if another object associated with the session has the same identifier, 
                    throw an exception
                </p></li><li><p>
                    if the object has no identifier property, <tt class="literal">save()</tt> it
                </p></li><li><p>
                    if the object's identifier has the value assigned to a newly instantiated
                    object, <tt class="literal">save()</tt> it
                </p></li><li><p>
                    if the object is versioned (by a <tt class="literal">&lt;version&gt;</tt> or
                    <tt class="literal">&lt;timestamp&gt;</tt>), and the version property value
                    is the same value assigned to a newly instantiated object, 
                    <tt class="literal">save()</tt> it
                </p></li><li><p>
                    otherwise <tt class="literal">update()</tt> the object
                </p></li></ul></div><p>
            and <tt class="literal">merge()</tt> is very different:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    if there is a persistent instance with the same identifier currently 
                    associated with the session, copy the state of the given object onto 
                    the persistent instance
                </p></li><li><p>
                    if there is no persistent instance currently associated with the session, 
                    try to load it from the database, or create a new persistent instance
                </p></li><li><p>
                    the persistent instance is returned
                </p></li><li><p>
                    the given instance does not become associated with the session, it
                    remains detached
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-deleting"></a>10.8.&nbsp;Deleting persistent objects</h2></div></div><div></div></div><p>
            <tt class="literal">Session.delete()</tt> will remove an object's state from the database.
            Of course, your application might still hold a reference to a deleted object.
            It's best to think of <tt class="literal">delete()</tt> as making a persistent instance
            transient.
        </p><pre class="programlisting">sess.delete(cat);</pre><p>
            You may delete objects in any order you like, without risk of foreign key
            constraint violations. It is still possible to violate a <tt class="literal">NOT
            NULL</tt> constraint on a foreign key column by deleting objects in
            the wrong order, e.g. if you delete the parent, but forget to delete the
            children.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-replicating"></a>10.9.&nbsp;Replicating object between two different datastores</h2></div></div><div></div></div><p>
    	    It is occasionally useful to be able to take a graph of persistent instances
    	    and make them persistent in a different datastore, without regenerating identifier
    	    values.
    	</p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>
            The <tt class="literal">ReplicationMode</tt> determines how <tt class="literal">replicate()</tt>
            will deal with conflicts with existing rows in the database.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">ReplicationMode.IGNORE</tt> - ignore the object when there is
                    an existing database row with the same identifier
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.OVERWRITE</tt> - overwrite any existing database 
                    row with the same identifier
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.EXCEPTION</tt> - throw an exception if there is
                    an existing database row with the same identifier
                </p></li><li><p>
                    <tt class="literal">ReplicationMode.LATEST_VERSION</tt> - overwrite the row if its
                    version number is earlier than the version number of the object, or ignore
                    the object otherwise
                </p></li></ul></div><p>
            Usecases for this feature include reconciling data entered into different database
            instances, upgrading system configuration information during product upgrades,
            rolling back changes made during non-ACID transactions and more.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-flushing"></a>10.10.&nbsp;Flushing the Session</h2></div></div><div></div></div><p>
            From time to time the <tt class="literal">Session</tt> will execute the SQL statements 
            needed to synchronize the JDBC connection's state with the state of objects held in 
            memory. This process, <span class="emphasis"><em>flush</em></span>, occurs by default at the following 
            points
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    before some query executions
                </p></li><li><p>
                    from <tt class="literal">org.hibernate.Transaction.commit()</tt>
                </p></li><li><p>
                    from <tt class="literal">Session.flush()</tt>
                </p></li></ul></div><p>
            The SQL statements are issued in the following order
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    all entity insertions, in the same order the corresponding objects
                    were saved using <tt class="literal">Session.save()</tt>
                </p></li><li><p>
                    all entity updates
                </p></li><li><p>
                    all collection deletions
                </p></li><li><p>
                    all collection element deletions, updates and insertions
                </p></li><li><p>
                    all collection insertions
                </p></li><li><p>
                    all entity deletions, in the same order the corresponding objects
                    were deleted using <tt class="literal">Session.delete()</tt>
                </p></li></ol></div><p>
            (An exception is that objects using <tt class="literal">native</tt> ID generation are 
            inserted when they are saved.)
        </p><p>
            Except when you explicity <tt class="literal">flush()</tt>, there are absolutely no 
            guarantees about <span class="emphasis"><em>when</em></span> the <tt class="literal">Session</tt> executes 
            the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed.
            However, Hibernate does guarantee that the <tt class="literal">Query.list(..)</tt> 
            will never return stale data; nor will they return the wrong data.
        </p><p>
            It is possible to change the default behavior so that flush occurs less frequently.
            The <tt class="literal">FlushMode</tt> class defines three different modes: only flush
            at commit time (and only when the Hibernate <tt class="literal">Transaction</tt> API
            is used), flush automatically using the explained routine, or never flush unless
            <tt class="literal">flush()</tt> is called explicitly. The last mode is useful for long running
            units of work, where a <tt class="literal">Session</tt> is kept open and disconnected for
            a long time (see <a href="#transactions-optimistic-longsession" title="11.3.2.&nbsp;Long session and automatic versioning">Section&nbsp;11.3.2, &#8220;Long session and automatic versioning&#8221;</a>).
        </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs</pre><p>
            During flush, an exception might occur (e.g. if a DML operation violates a constraint).
            Since handling exceptions involves some understanding of Hibernate's transactional 
            behavior, we discuss it in <a href="#transactions" title="Chapter&nbsp;11.&nbsp;Transactions And Concurrency">Chapter&nbsp;11, <i>Transactions And Concurrency</i></a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-transitive"></a>10.11.&nbsp;Transitive persistence</h2></div></div><div></div></div><p>
            It is quite cumbersome to save, delete, or reattach individual objects,
            especially if you deal with a graph of associated objects. A common case is
            a parent/child relationship. Consider the following example:
        </p><p>
            If the children in a parent/child relationship would be value typed (e.g. a collection
            of addresses or strings), their lifecycle would depend on the parent and no
            further action would be required for convenient "cascading" of state changes.
            When the parent is saved, the value-typed child objects are saved as
            well, when the parent is deleted, the children will be deleted, etc. This
            even works for operations such as the removal of a child from the collection;
            Hibernate will detect this and, since value-typed objects can't have shared
            references, delete the child from the database.
        </p><p>
            Now consider the same scenario with parent and child objects being entities,
            not value-types (e.g. categories and items, or parent and child cats). Entities
            have their own lifecycle, support shared references (so removing an entity from
            the collection does not mean it can be deleted), and there is by default no
            cascading of state from one entity to any other associated entities. Hibernate
            does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default.
        </p><p>
            For each basic operation of the Hibernate session - including <tt class="literal">persist(), merge(),
            saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</tt> - there is a 
            corresponding cascade style. Respectively, the cascade styles are named <tt class="literal">create, 
            merge, save-update, delete, lock, refresh, evict, replicate</tt>. If you want an 
            operation to be cascaded along an association, you must indicate that in the mapping
            document. For example:
        </p><pre class="programlisting">&lt;one-to-one name="person" cascade="create"/&gt;</pre><p>
            Cascade styles my be combined:
        </p><pre class="programlisting">&lt;one-to-one name="person" cascade="create,delete,lock"/&gt;</pre><p>
            You may even use <tt class="literal">cascade="all"</tt> to specify that <span class="emphasis"><em>all</em></span>
            operations should be cascaded along the association. The default <tt class="literal">cascade="none"</tt>
            specifies that no operations are to be cascaded.
        </p><p>
            A special cascade style, <tt class="literal">delete-orphan</tt>, applies only to one-to-many
            associations, and indicates that the <tt class="literal">delete()</tt> operation should
            be applied to any child object that is removed from the association.
        </p><p>
            Recommendations:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It doesn't usually make sense to enable cascade on a <tt class="literal">&lt;many-to-one&gt;</tt>
                    or <tt class="literal">&lt;many-to-many&gt;</tt> association. Cascade is often useful for 
                    <tt class="literal">&lt;one-to-one&gt;</tt> and <tt class="literal">&lt;one-to-many&gt;</tt>
                    associations.
                </p></li><li><p>
                    If the child object's lifespan is bounded by the lifespan of the of the parent
                    object make it a <span class="emphasis"><em>lifecycle object</em></span> by specifying
                    <tt class="literal">cascade="all,delete-orphan"</tt>.
                </p></li><li><p>
                    Otherwise, you might not need cascade at all. But if you think that you will often be
                    working with the parent and children together in the same transaction, and you want to save 
                    yourself some typing, consider using <tt class="literal">cascade="create,merge,save-update"</tt>.
                </p></li></ul></div><p>
            Mapping an association (either a single valued association, or a collection) with 
            <tt class="literal">cascade="all"</tt> marks the association as a 
            <span class="emphasis"><em>parent/child</em></span> style relationship where save/update/delete of the 
            parent results in save/update/delete of the child or children.
        </p><p>
            Futhermore, a mere reference to a child from a persistent parent will result in 
            save/update of the child. This metaphor is incomplete, however. A child which becomes 
            unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except 
            in the case of a <tt class="literal">&lt;one-to-many&gt;</tt> association mapped with
            <tt class="literal">cascade="delete-orphan"</tt>. The precise semantics of cascading 
            operations for a parent/child relationship are as follows:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If a parent is passed to <tt class="literal">persist()</tt>, all children are passed to 
                    <tt class="literal">persist()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">merge()</tt>, all children are passed to 
                    <tt class="literal">merge()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">save()</tt>, <tt class="literal">update()</tt> or 
                    <tt class="literal">saveOrUpdate()</tt>, all children are passed to <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a transient or detached child becomes referenced by a persistent parent, 
                    it is passed to <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is deleted, all children are passed to <tt class="literal">delete()</tt>
                </p></li><li><p>
                    If a child is dereferenced by a persistent parent, <span class="emphasis"><em>nothing
                    special happens</em></span> - the application should explicitly delete 
                    the child if necessary - unless <tt class="literal">cascade="delete-orphan"</tt>, 
                    in which case the "orphaned" child is deleted.
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-metadata"></a>10.12.&nbsp;Using metadata</h2></div></div><div></div></div><p>
            Hibernate requires a very rich meta-level model of all entity and value types. From time
            to time, this model is very useful to the application itself. For example, the application
            might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands
            which objects should be copied (eg. mutable value types) and which should not (eg. 
            immutable value types and, possibly, associated entities).
        </p><p>
            Hibernate exposes metadata via the <tt class="literal">ClassMetadata</tt> and
            <tt class="literal">CollectionMetadata</tt> interfaces and the <tt class="literal">Type</tt>
            hierarchy. Instances of the metadata interfaces may be obtained from the 
            <tt class="literal">SessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapter&nbsp;11.&nbsp;Transactions And Concurrency</h2></div></div><div></div></div><p>
        The most important point about Hibernate and concurrency control is that it is very
        easy to understand. Hibernate directly uses JDBC connections and JTA resources without
        adding any additional locking behavior. We highly recommend you spend some time with the
        JDBC, ANSI, and transaction isolation specification of your database management system.
        Hibernate only adds automatic versioning but does not lock objects in memory or change the
        isolation level of your database transactions. Basically, use Hibernate like you would
        use direct JDBC (or JTA/CMT) with your database resources.
    </p><p>
        However, in addition to automatic versioning, Hibernate also offers a (minor) API for
        pessimistic locking of rows, using the <tt class="literal">SELECT FOR UPDATE</tt> syntax. This API
        is discussed later in this chapter.
    </p><p>
        We start the discussion of concurrency control in Hibernate with the granularity of
        <tt class="literal">Configuration</tt>, <tt class="literal">SessionFactory</tt>, and
        <tt class="literal">Session</tt>, as well as database and long application transactions.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>11.1.&nbsp;Session and transaction scopes</h2></div></div><div></div></div><p>
            A <tt class="literal">SessionFactory</tt> is an expensive-to-create, threadsafe object 
            intended to be shared by all application threads. It is created once, usually on
            application startup, from a <tt class="literal">Configuration</tt> instance.
        </p><p>
            A <tt class="literal">Session</tt> is an inexpensive, non-threadsafe object that should be
            used once, for a single business process, a single unit of work, and then discarded.
            A <tt class="literal">Session</tt> will not obtain a JDBC <tt class="literal">Connection</tt>
            (or a <tt class="literal">Datasource</tt>) unless it is needed, so you may safely open
            and close a <tt class="literal">Session</tt> even if you are not sure that data access will
            be needed to serve a particular request. (This becomes important as soon as you are
            implementing some of the following patterns using request interception.)
        </p><p>
            To complete this picture you also have to think about database transactions. A
            database transaction has to be as short as possible, to reduce lock contention in
            the database. Long database transactions will prevent your application from scaling
            to highly concurrent load.
        </p><p>
            What is the scope of a unit of work? Can a single Hibernate <tt class="literal">Session</tt>
            span several database transactions or is this a one-to-one relationship of scopes? When
            should you open and close a <tt class="literal">Session</tt> and how do you demarcate the
            database transaction boundaries?
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-uow"></a>11.1.1.&nbsp;Unit of work</h3></div></div><div></div></div><p>
                First, don't use the <span class="emphasis"><em>session-per-operation</em></span> antipattern, that is,
                don't open and close a <tt class="literal">Session</tt> for every simple database call in
                a single thread! Of course, the same is true for database transactions. Database calls
                in an application are made using a planned sequence, they are grouped into atomic
                units of work. (Note that this also means that auto-commit after every single
                SQL statement is useless in an application, this mode is intended for ad-hoc SQL
                console work. Hibernate disables, or expects the application server to do so,
                auto-commit mode immediately.)
            </p><p>
                The most common pattern in a multi-user client/server application is
                <span class="emphasis"><em>session-per-request</em></span>. In this model, a request from the client
                is send to the server (where the Hibernate persistence layer runs), a new Hibernate
                <tt class="literal">Session</tt> is opened, and all database operations are executed in this unit
                of work. Once the work has been completed (and the response for the client has been prepared),
                the session is flushed and closed. You would also use a single database transaction to
                serve the clients request, starting and committing it when you open and close the
                <tt class="literal">Session</tt>. The relationship between the two is one-to-one and this
                model is a perfect fit for many applications.
            </p><p>
                The challenge lies in the implementation:  not only has the <tt class="literal">Session</tt>
                and transaction to be started and ended correctly, but they also have to be accessible for
                data access operations. The demarcation of a unit of work is ideally implemented using an
                interceptor that runs when a request hits the server and before the response will be send (i.e.
                a <tt class="literal">ServletFilter</tt>). We recommend to bind the <tt class="literal">Session</tt> to
                the thread that serves the request, using a <tt class="literal">ThreadLocal</tt> variable. This allows
                easy access (like accessing a static variable) in all code that runs in this thread. Depending
                on the database transaction demarcation mechanism you chose, you might also keep the transaction
                context in a <tt class="literal">ThreadLocal</tt> variable. The implementation patterns for this
                are known as <span class="emphasis"><em>ThreadLocal Session</em></span> and <span class="emphasis"><em>Open Session in View</em></span>.
                You can easily extend the <tt class="literal">HibernateUtil</tt> helper class shown earlier in this
                documentation to implement this. Of course, you'd have to find a way to implement an interceptor
                and set it up in your environment. See the Hibernate website for tips and examples.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-apptx"></a>11.1.2.&nbsp;Application transactions</h3></div></div><div></div></div><p>
                The session-per-request pattern is not the only useful concept you can use to design
                units of work. Many business processes require a whole series of interactions with the user
                interleaved with database accesses. In web and enterprise applications it is
                not acceptable for a database transaction to span a user interaction. Consider the following
                example:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        The first screen of a dialog opens, the data seen by the user has been loaded in
                        a particular <tt class="literal">Session</tt> and database transaction. The user is free to
                        modify the objects.
                    </p></li><li><p>
                        The user clicks "Save" after 5 minutes and expects his modifications to be made
                        persistent; he also expects that he was the only person editing this information and
                        that no conflicting modification can occur.
                    </p></li></ul></div><p>
                We call this unit of work, from the point of view of the user, a long running
                <span class="emphasis"><em>application transaction</em></span>. There are many ways how you can implement
                this in your application.
            </p><p>
                A first naive implementation might keep the <tt class="literal">Session</tt> and database
                transaction open during user think time, with locks held in the database to prevent
                concurrent modification, and to guarantee isolation and atomicity. This is of course
                an anti-pattern, since lock contention would not allow the application to scale with
                the number of concurrent users.
            </p><p>
                Clearly, we have to use several database transactions to implement the application
                transaction. In this case, maintaining isolation of business processes becomes the
                partial responsibility of the application tier. A single application transaction
                usually spans several database transactions. It will be atomic if only one of
                these database transactions (the last one) stores the updated data, all others
                simply read data (e.g. in a wizard-style dialog spanning several request/response
                cycles). This is easier to implement than it might sound, especially if
                you use Hibernate's features:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <span class="emphasis"><em>Automatic Versioning</em></span> - Hibernate can do automatic
                        optimistic concurrency control for you, it can automatically detect
                        if a concurrent modification occured during user think time.
                    </p></li><li><p>
                        <span class="emphasis"><em>Detached Objects</em></span> - If you decide to use the already
                        discussed <span class="emphasis"><em>session-per-request</em></span> pattern, all loaded instances
                        will be in detached state during user think time. Hibernate allows you to
                        reattach the objects and persist the modifications, the pattern is called
                        <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>. Automatic
                        versioning is used to isolate concurrent modifications.
                    </p></li><li><p>
                        <span class="emphasis"><em>Long Session</em></span> - The Hibernate <tt class="literal">Session</tt> may
                        be disconnected from the underlying JDBC connection after the database transaction
                        has been committed, and reconnected when a new client request occurs. This pattern
                        is known as <span class="emphasis"><em>session-per-application-transaction</em></span> and makes
                        even reattachment unnecessary. Automatic versioning is used to isolate
                        concurrent modifications.
                    </p></li></ul></div><p>
                Both <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> and
                <span class="emphasis"><em>session-per-application-transaction</em></span> have advantages and disadvantages,
                we discuss them later in this chapter in the context of optimistic concurrency control.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-identity"></a>11.1.3.&nbsp;Considering object identity</h3></div></div><div></div></div><p>
                An application may concurrently access the same persistent state in two
                different <tt class="literal">Session</tt>s. However, an instance of a persistent class
                is never shared between two <tt class="literal">Session</tt> instances. Hence there are
                two different notions of identity:
            </p><div class="variablelist"><dl><dt><span class="term">Database Identity</span></dt><dd><p>
                            <tt class="literal">foo.getId().equals( bar.getId() )</tt>
                        </p></dd><dt><span class="term">JVM Identity</span></dt><dd><p>
                            <tt class="literal">foo==bar</tt>
                        </p></dd></dl></div><p>
                Then for objects attached to a <span class="emphasis"><em>particular</em></span> <tt class="literal">Session</tt>
                (i.e. in the scope of a <tt class="literal">Session</tt>) the two notions are equivalent, and
                JVM identity for database identity is guaranteed by Hibernate. However, while the application
                might concurrently access the "same" (persistent identity) business object in two different
                sessions, the two instances will actually be "different" (JVM identity). Conflicts are
                resolved using (automatic versioning) at flush/commit time, using an optimistic approach.
            </p><p>
                This approach leaves Hibernate and the database to worry about concurrency; it also provides
                the best scalability, since guaranteeing identity in single-threaded units of work only doesn't
                need expensive locking or other means of synchronization. The application never needs to
                synchronize on any business object, as long as it sticks to a single thread per
                <tt class="literal">Session</tt>. Within a <tt class="literal">Session</tt> the  application may safely use
                <tt class="literal">==</tt> to compare objects.
            </p><p>
                However, an application that uses <tt class="literal">==</tt> outside of a <tt class="literal">Session</tt>,
                might see unexpected results. This might occur even in some unexpected places, for example,
                if you put two detached instances into the same <tt class="literal">Set</tt>. Both might have the same
                database identity (i.e. they represent the same row), but JVM identity is by definition not
                guaranteed for instances in detached state. The developer has to override the <tt class="literal">equals()</tt>
                and <tt class="literal">hashCode()</tt> methods in persistent classes and implement
                his own notion of object equality. There is one caveat: Never use the database
                identifier to implement equality, use a business key, a combination of unique, usually
                immutable, attributes. The database identifier will change if a transient object is made
                persistent. If the transient instance (usually together with detached instances) is held in a
                <tt class="literal">Set</tt>, changing the hashcode breaks the contract of the <tt class="literal">Set</tt>.
                Attributes for business keys don't have to be as stable as database primary keys, you only
                have to guarantee stability as long as the objects are in the same <tt class="literal">Set</tt>. See
                the Hibernate website for a more thorough discussion of this issue. Also note that this is not
                a Hibernate issue, but simply how Java object identity and equality has to be implemented.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-basics-issues"></a>11.1.4.&nbsp;Common issues</h3></div></div><div></div></div><p>
                 Never use the anti-patterns <span class="emphasis"><em>session-per-user-session</em></span> or
                 <span class="emphasis"><em>session-per-application</em></span> (of course, there are rare exceptions to
                 this rule). Note that some of the following issues might also appear with the recommended
                 patterns, make sure you understand the implications before making a design decision:
             </p><div class="itemizedlist"><ul type="disc"><li><p>
                        A <tt class="literal">Session</tt> is not thread-safe. Things which are supposed to work
                        concurrently, like HTTP requests, session beans, or Swing workers, will cause race
                        conditions if a <tt class="literal">Session</tt> instance would be shared. If you keep your
                        Hibernate <tt class="literal">Session</tt> in your <tt class="literal">HttpSession</tt> (discussed
                        later), you should consider synchronizing access to your Http session. Otherwise,
                        a user that clicks reload fast enough may use the same <tt class="literal">Session</tt> in
                        two concurrently running threads.
                    </p></li><li><p>
                        An exception thrown by Hibernate means you have to rollback your database transaction
                        and close the <tt class="literal">Session</tt> immediately (discussed later in more detail).
                        If your <tt class="literal">Session</tt> is bound to the application, you have to stop
                        the application. Rolling back the database transaction doesn't put your business
                        objects back into the state they were at the start of the transaction. This means the
                        database state and the business objects do get out of sync. Usually this is not a
                        problem, because exceptions are not recoverable and you have to start over after
                        rollback anyway.
                    </p></li><li><p>
                        The <tt class="literal">Session</tt> caches every object that is in persistent state (watched
                        and checked for dirty state by Hibernate). This means it grows endlessly until you
                        get an OutOfMemoryException, if you keep it open for a long time or simply load too
                        much data. One solution for this is to call <tt class="literal">clear()</tt> and <tt class="literal">evict()</tt>
                        to manage the <tt class="literal">Session</tt> cache, but you most likely should consider a
                        Stored Procedure if you need mass data operations. Some solutions are shown in
                        <a href="#batch" title="Chapter&nbsp;13.&nbsp;Batch processing">Chapter&nbsp;13, <i>Batch processing</i></a>. Keeping a <tt class="literal">Session</tt> open for the duration
                        of a user session also means a high probability of stale data.
                    </p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-demarcation"></a>11.2.&nbsp;Database transaction demarcation</h2></div></div><div></div></div><p>
            Datatabase (or system) transaction boundaries are always necessary. No communication with
            the database can occur outside of a database transaction (this seems to confuse many developers
            who are used to the auto-commit mode). Always use clear transaction boundaries, even for
            read-only operations. Depending on your isolation level and database capabilities this might not
            be required but there is no downside if you always demarcate transactions explicitly.
        </p><p>
            A Hibernate application can run in non-managed (i.e. standalone, simple Web- or Swing applications)
            and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for
            its own database connection pool. The application developer has to manually set transaction
            boundaries, in other words, begin, commit, or rollback database transactions himself. A managed environment
            usually provides container-managed transactions, with the transaction assembly defined declaratively
            in deployment descriptors of EJB session beans, for example. Programmatic transaction demarcation is
            then no longer necessary, even flushing the <tt class="literal">Session</tt> is done automatically.
        </p><p>
            However, it is often desirable to keep your persistence layer portable. Hibernate offers a wrapper
            API called <tt class="literal">Transaction</tt> that translates into the native transaction system of
            your deployment environment. This API is optional (using database transactions is not!) and you don't
            have to use it if database portability provided by Hibernate is all you need.
        </p><p>
            Usually, ending a <tt class="literal">Session</tt> involves four distinct phases:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    flush the session
                </p></li><li><p>
                    commit the transaction
                </p></li><li><p>
                    close the session
                </p></li><li><p>
                    handle exceptions
                </p></li></ul></div><p>
            Flushing the session has been discussed earlier, we'll now have a closer look at transaction
            demarcation and exception handling in both managed- and non-managed environments.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-nonmanaged"></a>11.2.1.&nbsp;Non-managed environment</h3></div></div><div></div></div><p>
                If a Hibernate persistence layer runs in a non-managed environment, database connections
                are either handled by Hibernate's pooling mechanism or provided by the developer (this
                case has other implications, esp. with regard to caching):
            </p><pre class="programlisting">// Session sess = factory.openSession(myConnection);
Session sess = factory.openSession();

try {
    // do some work
    ...
    sess.flush();
    sess.connection().commit();
}
catch (RuntimeException e) {
    sess.connection().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>
                Note that you will very likely never see this piece of code in a normal application;
                fatal (system) exceptions should always be caught at the "top". In other words, the
                code that executes Hibernate calls (in the persistence layer) and the code that handles
                <tt class="literal">RuntimeException</tt> (and usually can only clean up and exit) are in
                different layers. This can be a challenge to design yourself and you should use J2EE/EJB
                container services whenever they are available. Exception handling is discussed later in
                this chapter.
            </p><p>
                We recommend, even if persistence layer portability is not your primary concern, the
                <tt class="literal">Transaction</tt> API:
            </p><pre class="programlisting">Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>
                Note that you don't have to <tt class="literal">flush()</tt> the <tt class="literal">Session</tt>
                explicitly, the call to <tt class="literal">commit()</tt> automatically triggers the
                synchronization. This piece of code is now portable and runs in non-managed and JTA
                environments. See <a href="#configuration-optional-transactionstrategy" title="3.4.5.&nbsp;Transaction strategy configuration">Section&nbsp;3.4.5, &#8220;Transaction strategy configuration&#8221;</a> for
                the configuration options of the <tt class="literal">Transaction</tt> API and how it can
                be mapped to the underlying resource transaction system.
            </p><p>
                A call to <tt class="literal">close()</tt> marks the end of a session. The main implication
                of <tt class="literal">close()</tt> is that the JDBC connection will be relinquished by the session.
                If you provided your own connection, <tt class="literal">close()</tt> returns a reference
                to it, so you can manually close it or return it to the pool. Otherwise <tt class="literal">close()
                </tt> returns it to the pool.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-jta"></a>11.2.2.&nbsp;Using JTA</h3></div></div><div></div></div><p>
                If your persistence layer runs in an application server (e.g. behind EJB session beans),
                transaction boundaries are defined in deployment descriptors. Every datasource connection
                obtained by Hibernate will automatically be part of a global JTA transaction. Hibernate
                simply joins this transaction, or if a particular session bean method has no mandatory
                transaction, Hibernate will tell the application server to start and end a transaction
                directly. (The latter should be considered a very rare case and is offered for consistency
                reasons. Note that your container might not allow mixed CMT and BMT behavior.)
            </p><p>
                If you set the properties <tt class="literal">hibernate.transaction.flush_before_completion</tt>
                and <tt class="literal">hibernate.transaction.auto_close_session</tt> to <tt class="literal">true</tt>,
                Hibernate wil also automatically flush and close the <tt class="literal">Session</tt> for you.
                The only thing left is exception handling and rollback of the database transaction.
                Fortunately, even this happens automatically, since an unhandled <tt class="literal">RuntimeException</tt>
                thrown by a session bean method tells the container to set the global transaction to
                rollback.
            </p><p>
                In other words, all you have to do in a managed environment is to get a <tt class="literal">Session</tt>
                from the <tt class="literal">SessionFactory</tt> (usually bound to JNDI), do your data access
                work, and leave the rest to the container. Transaction boundaries are set declaratively in
                the deployment descriptors of your session bean.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-demarcation-exceptions"></a>11.2.3.&nbsp;Exception handling</h3></div></div><div></div></div><p>
                If the <tt class="literal">Session</tt> throws an exception (including any
                <tt class="literal">SQLException</tt>), you should immediately rollback the database
                transaction, call <tt class="literal">Session.close()</tt> and discard the
                <tt class="literal">Session</tt> instance. Certain methods of <tt class="literal">Session</tt>
                will <span class="emphasis"><em>not</em></span> leave the session in a consistent state. No
                exception thrown by Hibernate can be treated as recoverable. Ensure that the
                <tt class="literal">Session</tt> will be closed by calling <tt class="literal">close()</tt>
                in a <tt class="literal">finally</tt> block.
            </p><p>
                The <tt class="literal">HibernateException</tt>, which wraps most of the errors that
                can occur in a Hibernate persistence layer, is an unchecked exception (it wasn't
                in older versions of Hibernate). In our opinion, we shouldn't force the application
                developer to catch an unrecoverable exception at a low layer. In most systems, unchecked
                and fatal exceptions are only catched in one of the first frames of the method call
                stack (i.e. in higher layers) and an error message is presented to the application
                user (or some other appropriate action is taken). Note that Hibernate might also throw
                other unchecked exceptions (e.g. when detecting stale data in version checks) which are
                not a <tt class="literal">HibernateException</tt>. These are, again, not recoverable and
                appropriate action should be taken.
            </p><p>
		        A subtype of <tt class="literal">HibernateException</tt> is <tt class="literal">SQLException</tt>
		        which indicate a specific set of error conditions occuring while Hibernate
		        interacts with the database.
	        </p><p>
                For SQLExceptions thrown while interacting with the database, Hibernate will
                attempt to convert the error into a subclass of JDBCException.  The underlying
                SQLException is accessible by calling <tt class="literal">JDBCException.getCause()</tt>.
                Hibernate converts the SQLException into an appropriate JDBCException subclass
                based on the SQLExceptionConverter attached to the SessionFactory.  By default,
                the SQLExceptionConverter is defined by the configured dialect; however, it is
                also possible to plug in a custom implmentation (see the javadocs for the
                SQLExceptionConverterFactory class for details).  The standard JDBCException
                subtypes are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">JDBCConnectionException</tt> - indicates an error
                        with the underlying JDBC communication.
                    </p></li><li><p>
                        <tt class="literal">SQLGrammarException</tt> - indicates a grammar
                        or syntax problem with the issued SQL.
                    </p></li><li><p>
                        <tt class="literal">ConstraintViolationException</tt> - indicates some
                        form of integrity constraint violation.
                    </p></li><li><p>
                        <tt class="literal">LockAcquisitionException</tt> - indicates an error
                        acquiring a lock level necessary to perform the requested operation.
                    </p></li><li><p>
                        <tt class="literal">GenericJDBCException</tt> - a generic exception
                        which did not fall into any of the other categories.
                    </p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>11.3.&nbsp;Optimistic concurrency control</h2></div></div><div></div></div><p>
            The only approach that is consistent with high concurrency and high
            scalability is optimistic concurrency control with versioning. Version
            checking uses version numbers, or timestamps, to detect conflicting updates
            (and to prevent lost updates). Hibernate provides for three possible approaches
            to writing application code that uses optimistic concurrency. The use cases
            we show are in the context of long application transactions but version checking
            also has the benefit of preventing lost updates in single database transactions.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>11.3.1.&nbsp;Application version checking</h3></div></div><div></div></div><p>
                In an implementation without much help from Hibernate, each interaction with the
                database occurs in a new <tt class="literal">Session</tt> and the developer is responsible
                for reloading all persistent instances from the database before manipulating them.
                This approach forces the application to carry out its own version checking to ensure
                application transaction isolation. This approach is the least efficient in terms of
                database access. It is the approach most similar to entity EJBs.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();
int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");
t.commit();
session.close();</pre><p>
                The <tt class="literal">version</tt> property is mapped using <tt class="literal">&lt;version&gt;</tt>,
                and Hibernate will automatically increment it during flush if the entity is
                dirty.
            </p><p>
                Of course, if you are operating in a low-data-concurrency environment and don't
                require version checking, you may use this approach and just skip the version
                check. In that case, <span class="emphasis"><em>last commit wins</em></span> will be the default
                strategy for your long application transactions. Keep in mind that this might
                confuse the users of the application, as they might experience lost updates without
                error messages or a chance to merge conflicting changes.
            </p><p>
                Clearly, manual version checking is only feasible in very trivial circumstances
                and not practical for most applications. Often not only single instances, but
                complete graphs of modified ojects have to be checked. Hibernate offers automatic
                version checking with either long <tt class="literal">Session</tt> or detached instances
                as the design paradigm.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>11.3.2.&nbsp;Long session and automatic versioning</h3></div></div><div></div></div><p>
                A single <tt class="literal">Session</tt> instance and its persistent instances are
                used for the whole application transaction. Hibernate checks instance versions
                at flush time, throwing an exception if concurrent modification is detected.
                It's up to the developer to catch and handle this exception (common options
                are the opportunity for the user to merge changes or to restart the business
                process with non-stale data).
            </p><p>
                The <tt class="literal">Session</tt> is disconnected from any underlying JDBC connection
                when waiting for user interaction. This approach is the most efficient in terms
                of database access. The application need not concern itself with version checking or
                with reattaching detached instances, nor does it have to reload instances in every
                database transaction.
            </p><pre class="programlisting">// foo is an instance loaded earlier by the Session
session.reconnect(); // Obtain a new JDBC connection
Transaction t = session.beginTransaction();
foo.setProperty("bar");
t.commit(); // End database transaction, flushing the change and checking the version
session.disconnect(); // Return JDBC connection </pre><p>
                The <tt class="literal">foo</tt> object still knows which <tt class="literal">Session</tt> it was
                loaded in. <tt class="literal">Session.reconnect()</tt> obtains a new connection (or you
                may supply one) and resumes the session. The method <tt class="literal">Session.disconnect()</tt> will disconnect the session from
                the JDBC connection and return the connection to the pool (unless you provided the
                connection). After reconnection, to force a version check on data you aren't updating, you
                may call <tt class="literal">Session.lock()</tt> with <tt class="literal">LockMode.READ</tt> on any
                objects that might have been updated by another transaction. You don't need to lock any
                data that you <span class="emphasis"><em>are</em></span> updating.
            </p><p>
                This pattern is problematic if the <tt class="literal">Session</tt> is too big to
                be stored during user think time, e.g. an <tt class="literal">HttpSession</tt> should
                be kept as small as possible. As the <tt class="literal">Session</tt> is also the
                (mandatory) first-level cache and contains all loaded objects, we can probably
                use this strategy only for a few request/response cycles. This is indeed
                recommended, as the <tt class="literal">Session</tt> will soon also have stale data.
            </p><p>
                Also note that you should keep the disconnected <tt class="literal">Session</tt> close
                to the persistence layer. In other words, use an EJB stateful session bean to
                hold the <tt class="literal">Session</tt> and don't transfer it to the web layer (or
                even serialize it to a separate tier) to store it in the <tt class="literal">HttpSession</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>11.3.3.&nbsp;Detached objects and automatic versioning</h3></div></div><div></div></div><p>
                Each interaction with the persistent store occurs in a new <tt class="literal">Session</tt>.
                However, the same persistent instances are reused for each interaction with the database.
                The application manipulates the state of detached instances originally loaded in another
                <tt class="literal">Session</tt> and then reattaches them using <tt class="literal">Session.update()</tt>,
                <tt class="literal">Session.saveOrUpdate()</tt>, or <tt class="literal">Session.merge()</tt>.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();</pre><p>
                Again, Hibernate will check instance versions during flush, throwing an
                exception if conflicting updates occured.
            </p><p>
                You may also call <tt class="literal">lock()</tt> instead of <tt class="literal">update()</tt>
                and use <tt class="literal">LockMode.READ</tt> (performing a version check, bypassing all
                caches) if you are sure that the object has not been modified.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-customizing"></a>11.3.4.&nbsp;Customizing automatic versioning</h3></div></div><div></div></div><p>
                You may disable Hibernate's automatic version increment for particular properties and 
                collections by setting the <tt class="literal">optimistic-lock</tt> mapping attribute to 
                <tt class="literal">false</tt>. Hibernate will then no longer increment versions if the 
                property is dirty.
            </p><p>
                Legacy database schemas are often static and can't be modified. Or, other applications
                might also access the same database and don't know how to handle version numbers or
                even timestamps. In both cases, versioning can't rely on a particular column in a table.
                To force a version check without a version or timestamp property mapping, with a
                comparison of the state of all fields in a row, turn on <tt class="literal">optimistic-lock="all"</tt>
                in the <tt class="literal">&lt;class&gt;</tt> mapping. Note that this concepetually only works
                if Hibernate can compare the old and new state, i.e. if you use a single long
                <tt class="literal">Session</tt> and not session-per-request-with-detached-objects.
            </p><p>
                Sometimes concurrent modification can be permitted as long as the changes that have been
                made don't overlap. If you set <tt class="literal">optimistic-lock="dirty"</tt> when mapping the
                <tt class="literal">&lt;class&gt;</tt>, Hibernate will only compare dirty fields during flush.
            </p><p>
                In both cases, with dedicated version/timestamp columns or with full/dirty field
                comparison, Hibernate uses a single <tt class="literal">UPDATE</tt> statement (with an
                appropriate <tt class="literal">WHERE</tt> clause) per entity to execute the version check
                and update the information. If you use transitive persistence to cascade reattachment
                to associated entities, Hibernate might execute uneccessary updates. This is usually
                not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be
                executed even when no changes have been made to detached instances. You can customize
                this behavior by setting  <tt class="literal">select-before-update="true"</tt> in the
                <tt class="literal">&lt;class&gt;</tt> mapping, forcing Hibernate to <tt class="literal">SELECT</tt>
                the instance to ensure that changes did actually occur, before updating the row.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>11.4.&nbsp;Pessimistic Locking</h2></div></div><div></div></div><p>
            It is not intended that users spend much time worring about locking strategies. Its usually
            enough to specify an isolation level for the JDBC connections and then simply let the
            database do all the work. However, advanced users may sometimes wish to obtain
            exclusive pessimistic locks, or re-obtain locks at the start of a new transaction.
        </p><p>
            Hibernate will always use the locking mechanism of the database, never lock objects
            in memory!
        </p><p>
            The <tt class="literal">LockMode</tt> class defines the different lock levels that may be acquired
            by Hibernate. A lock is obtained by the following mechanisms:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.WRITE</tt> is acquired automatically when Hibernate updates or inserts
                    a row.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE</tt> may be acquired upon explicit user request using
                    <tt class="literal">SELECT ... FOR UPDATE</tt> on databases which support that syntax.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE_NOWAIT</tt> may be acquired upon explicit user request using a
                    <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> under Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.READ</tt> is acquired automatically when Hibernate reads data
                    under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user
                    request.
                </p></li><li><p>
            <tt class="literal">LockMode.NONE</tt> represents the absence of a lock. All objects switch to this
            lock mode at the end of a <tt class="literal">Transaction</tt>. Objects associated with the session
            via a call to <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt> also start out
            in this lock mode.
        </p></li></ul></div><p>
            The "explicit user request" is expressed in one of the following ways:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    A call to <tt class="literal">Session.load()</tt>, specifying a <tt class="literal">LockMode</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">Session.lock()</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">Query.setLockMode()</tt>.
                </p></li></ul></div><p>
            If <tt class="literal">Session.load()</tt> is called with <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>, and the requested object was not yet loaded by
            the session, the object is loaded using <tt class="literal">SELECT ... FOR UPDATE</tt>.
            If <tt class="literal">load()</tt> is called for an object that is already loaded with
            a less restrictive lock than the one requested, Hibernate calls
            <tt class="literal">lock()</tt> for that object.
        </p><p>
            <tt class="literal">Session.lock()</tt> performs a version number check if the specified lock
            mode is <tt class="literal">READ</tt>, <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>. (In the case of <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>, <tt class="literal">SELECT ... FOR UPDATE</tt> is used.)
        </p><p>
            If the database does not support the requested lock mode, Hibernate will use an appropriate
            alternate mode (instead of throwing an exception). This ensures that applications will
            be portable.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapter&nbsp;12.&nbsp;Interceptors and events</h2></div></div><div></div></div><p>
        It is often useful for the application to react to certain events that occur
        inside Hibernate. This allows implementation of certain kinds of generic 
        functionality, and extension of Hibernate functionality.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-interceptors"></a>12.1.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">Interceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and/or manipulate properties of a
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. For example, the following 
            <tt class="literal">Interceptor</tt> automatically sets the  <tt class="literal">createTimestamp</tt> 
            when an <tt class="literal">Auditable</tt> is created and updates the 
            <tt class="literal">lastUpdateTimestamp</tt> property when an <tt class="literal">Auditable</tt> is 
            updated.
        </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.Interceptor;
import org.hibernate.type.Type;

public class AuditInterceptor implements Interceptor, Serializable {

    private int updates;
    private int creates;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creations: " + creates + ", Updates: " + updates);
    }

    public void preFlush(Iterator entities) {
        updates=0;
        creates=0;
    }

    ...

}</pre><p>
            The interceptor would be specified when a session is created.
        </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>
            You may also set an interceptor on a global level, using the <tt class="literal">Configuration</tt>:
        </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-events"></a>12.2.&nbsp;Event system</h2></div></div><div></div></div><p>
            If you have to react to particular events in your persistence layer, you may
            also use the Hibernate3 <span class="emphasis"><em>event</em></span> architecture. The event
            system can be used in addition or as a replacement for interceptors.
        </p><p>
            Essentially all of the methods of the <tt class="literal">Session</tt> interface correlate
            to an event. You have a <tt class="literal">LoadEvent</tt>, a <tt class="literal">FlushEvent</tt>, etc
            (consult the XML configuration-file DTD or the <tt class="literal">org.hibernate.event</tt>
            package for the full list of defined event types). When a request is made of one of
            these methods, the Hibernate <tt class="literal">Session</tt> generates an appropriate
            event and passes it to the configured event listener for that type. Out-of-the-box,
            these listeners implement the same processing in which those methods always resulted.
            However, you are free to implement a customization of one of the listener interfaces
            (i.e., the <tt class="literal">LoadEvent</tt> is processed by the registered implemenation
            of the <tt class="literal">LoadEventListener</tt> interface), in which case their
            implementation would be responsible for processing any <tt class="literal">load()</tt> requests
            made of the <tt class="literal">Session</tt>.
        </p><p>
            The listeners should be considered effectively singletons; meaning, they are shared between
            requests, and thus should not save any state as instance variables.
        </p><p>
            A custom listener should implement the appropriate interface for the event it wants to
            process and/or extend one of the convenience base classes (or even the default event
            listeners used by Hibernate out-of-the-box as these are declared non-final for this
            purpose). Custom listeners can either be registered programmatically through the
            <tt class="literal">Configuration</tt> object, or specified in the Hibernate configuration
            XML (declarative configuration through the properties file is not supported). Here's an
            example of a custom load event listener:
        </p><pre class="programlisting">public class MyLoadListener extends DefaultLoadEventListener {
    // this is the single method defined by the LoadEventListener interface
    public Object onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
        return super.onLoad(event, loadType);
    }
}</pre><p>
            You also need a configuration entry telling Hibernate to use the listener instead
            of the default listener:
        </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;listener type="load" class="MyLoadListener"/&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>
            Instead, you may register it programmatically:
        </p><pre class="programlisting">Configuration cfg = new Configuration();
cfg.getSessionEventListenerConfig().setLoadEventListener( new MyLoadListener() );</pre><p>
            Listeners registered declaratively cannot share instances. If the same class name is
            used in multiple <tt class="literal">&lt;listener/&gt;</tt> elements, each reference will
            result in a separate instance of that class. If you need the capability to share
            listener instances between listener types you must use the programmatic registration
            approach.
        </p><p>
            Why implement an interface and define the specific type during configuration? Well, a
            listener implementation could implement multiple event listener interfaces. Having the
            type additionally defined during registration makes it easier to turn custom listeners on
            or off during configuration.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-decl-security"></a>12.3.&nbsp;Hibernate declarative security</h2></div></div><div></div></div><p>
            Usually, declarative security in Hibernate applications is managed in a session facade
            layer. Now, Hibernate3 allows certain actions to be permissioned via JACC, and authorized 
            via JAAS. This is optional functionality built on top of the event architecture.
        </p><p>
            First, you must configure the appropriate event listeners, to enable the use of JAAS
            authorization.
        </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>
            Next, still in <tt class="literal">hibernate.cfg.xml</tt>, bind the permissions to roles:
        </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>
            The role names are the roles understood by your JACC provider.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="batch"></a>Chapter&nbsp;13.&nbsp;Batch processing</h2></div></div><div></div></div><p>
        A naive approach to inserting 100 000 rows in the database using Hibernate might 
        look like this:
    </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>
        This would fall over with an <tt class="literal">OutOfMemoryException</tt> somewhere 
        around the 50 000th row. That's because Hibernate caches all the newly inserted 
        <tt class="literal">Customer</tt> instances in the session-level cache. 
    </p><p>
        In this chapter we'll show you how to avoid this problem. First, however, if you
        are doing batch processing, it is absolutely critical that you enable the use of
        JDBC batching, if you intend to achieve reasonable performance. Set the JDBC batch 
        size to a reasonable number (say, 10-50):
    </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p>
        You also might like to do this kind of work in a process where interaction with 
        the second-level cache is completely disabled:
    </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-inserts"></a>13.1.&nbsp;Batch inserts</h2></div></div><div></div></div><p>
            When making new objects persistent, you must <tt class="literal">flush()</tt> and 
            then <tt class="literal">clear()</tt> the session regularly, to control the size of
            the first-level cache.
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-update"></a>13.2.&nbsp;Batch updates</h2></div></div><div></div></div><p>
            For retrieving and updating data the same ideas apply. In addition, you need to 
            use <tt class="literal">scroll()</tt> to take advantage of server-side cursors for 
            queries that return many rows of data.
        </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapter&nbsp;14.&nbsp;HQL: The Hibernate Query Language</h2></div></div><div></div></div><p>
        Hibernate is equiped with an extremely powerful query language that (quite intentionally)
        looks very much like SQL. But don't be fooled by the syntax; HQL is fully object-oriented,
        understanding notions like inheritence, polymorphism and association.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>14.1.&nbsp;Case Sensitivity</h2></div></div><div></div></div><p>
            Queries are case-insensitive, except for names of Java classes and properties.
            So <tt class="literal">SeLeCT</tt> is the same as
            <tt class="literal">sELEct</tt> is the same as
            <tt class="literal">SELECT</tt> but
            <tt class="literal">org.hibernate.eg.FOO</tt> is not
            <tt class="literal">org.hibernate.eg.Foo</tt> and
            <tt class="literal">foo.barSet</tt> is not
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords 
            more readable, but we find this convention ugly when embedded in Java code.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>14.2.&nbsp;The from clause</h2></div></div><div></div></div><p>
            The simplest possible Hibernate query is of the form:
        </p><pre class="programlisting">from eg.Cat</pre><p>
            which simply returns all instances of the class <tt class="literal">eg.Cat</tt>.
            We don't usually need to qualify the class name, since <tt class="literal">auto-import</tt>
            is the default. So we almost always just write:
        </p><pre class="programlisting">from Cat</pre><p>
            Most of the time, you will need to assign an <span class="emphasis"><em>alias</em></span>, since
            you will want to refer to the <tt class="literal">Cat</tt> in other parts of the
            query.
        </p><pre class="programlisting">from Cat as cat</pre><p>
            This query assigns the alias <tt class="literal">cat</tt> to <tt class="literal">Cat</tt>
            instances, so we could use that alias later in the query. The <tt class="literal">as</tt>
            keyword is optional; we could also write:
        </p><pre class="programlisting">from Cat cat</pre><p>
            Multiple classes may appear, resulting in a cartesian product or "cross" join.
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            It is considered good practice to name query aliases using an initial lowercase,
            consistent with Java naming standards for local variables
            (eg. <tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>14.3.&nbsp;Associations and joins</h2></div></div><div></div></div><p>
            We may also assign aliases to associated entities, or even to elements of a 
            collection of values, using a <tt class="literal">join</tt>.
        </p><pre class="programlisting">from Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>
            The supported join types are borrowed from ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt>
                </p></li><li><p>
                    <tt class="literal">left outer join</tt>
                </p></li><li><p>
                    <tt class="literal">right outer join</tt>
                </p></li><li><p>
                    <tt class="literal">full join</tt> (not usually useful)
                </p></li></ul></div><p>
            The <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> and 
            <tt class="literal">right outer join</tt> constructs may be abbreviated.
        </p><pre class="programlisting">from Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>
            In addition, a "fetch" join allows associations or collections of values to be 
            initialized along with their parent objects, using a single select. This is particularly 
            useful in the case of a collection. It effectively overrides the outer join and
            lazy declarations of the mapping file for associations and collections. See
            <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p><pre class="programlisting">from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>
            A fetch join does not usually need to assign an alias, because the associated objects 
            should not be used in the <tt class="literal">where</tt> clause (or any other clause). Also, 
            the associated objects are not returned directly in the query results. Instead, they may 
            be accessed via the parent object.
        </p><p>
            Note that, in the current implementation, only one collection role may be fetched
            in a query (everything else would be non-performant). Note also that the
            <tt class="literal">fetch</tt> construct may not be used in queries called using
            <tt class="literal">scroll()</tt> or <tt class="literal">iterate()</tt>. Finally, note that
            <tt class="literal">full join fetch</tt> and <tt class="literal">right join fetch</tt> are not meaningful.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>14.4.&nbsp;The select clause</h2></div></div><div></div></div><p>
            The <tt class="literal">select</tt> clause picks which objects and properties to return in 
            the query result set. Consider:
        </p><pre class="programlisting">select mate 
from Cat as cat 
    inner join cat.mate as mate</pre><p>
            The query will select <tt class="literal">mate</tt>s of other <tt class="literal">Cat</tt>s.
            Actually, you may express this query more compactly as:
        </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>
            Queries may return properties of any value type including properties of component type:
        </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'

select cust.name.firstName from Customer as cust</pre><p>
            Queries may return multiple objects and/or properties as an array of type 
            <tt class="literal">Object[]</tt>
        </p><pre class="programlisting">select mother, offspr, mate.name 
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            or as an actual typesafe Java object
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>
            assuming that the class <tt class="literal">Family</tt> has an appropriate constructor.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>14.5.&nbsp;Aggregate functions</h2></div></div><div></div></div><p>
            HQL queries may even return the results of aggregate functions on properties:
        </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>
            The supported aggregate functions are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            The <tt class="literal">distinct</tt> and <tt class="literal">all</tt> keywords may be used and have
            the same semantics as in SQL.
        </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>14.6.&nbsp;Polymorphic queries</h2></div></div><div></div></div><p>
            A query like:
        </p><pre class="programlisting">from Cat as cat</pre><p>
            returns instances not only of <tt class="literal">Cat</tt>, but also of subclasses like
            <tt class="literal">DomesticCat</tt>. Hibernate queries may name <span class="emphasis"><em>any</em></span> Java 
            class or interface in the <tt class="literal">from</tt> clause. The query will return instances 
            of all persistent classes that extend that class or implement the interface. The following 
            query would return all persistent objects:
        </p><pre class="programlisting">from java.lang.Object o</pre><p>
            The interface <tt class="literal">Named</tt> might be implemented by various persistent
            classes:
        </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>
            Note that these last two queries will require more than one SQL <tt class="literal">SELECT</tt>. This
            means that the <tt class="literal">order by</tt> clause does not correctly order the whole result set.
            (It also means you can't call these queries using <tt class="literal">Query.scroll()</tt>.)
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>14.7.&nbsp;The where clause</h2></div></div><div></div></div><p>
            The <tt class="literal">where</tt> clause allows you to narrow the list of instances returned.
            If no alias exists, you may refer to properties by name:
        </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>
        	If there is an alias, use a qualified property name:
        </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>
            returns instances of <tt class="literal">Cat</tt> named 'Fritz'.
        </p><pre class="programlisting">select foo 
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>
            will return all instances of <tt class="literal">Foo</tt> for which
            there exists an instance of <tt class="literal">bar</tt> with a
            <tt class="literal">date</tt> property equal to the
            <tt class="literal">startDate</tt> property of the
            <tt class="literal">Foo</tt>. Compound path expressions make the
            <tt class="literal">where</tt> clause extremely powerful. Consider:
        </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>
            This query translates to an SQL query with a table (inner) join. If you were to write
            something like
        </p><pre class="programlisting">from Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><p>
            you would end up with a query that would require four table joins in SQL.
        </p><p>
            The <tt class="literal">=</tt> operator may be used to compare not only properties, but also 
            instances:
        </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate 
from Cat cat, Cat mate
where cat.mate = mate</pre><p>
            The special property (lowercase) <tt class="literal">id</tt> may be used to reference the 
            unique identifier of an object. (You may also use its property name.)
        </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>
            The second query is efficient. No table join is required!
        </p><p>
            Properties of composite identifiers may also be used. Suppose <tt class="literal">Person</tt> 
            has a composite identifier consisting of <tt class="literal">country</tt> and 
            <tt class="literal">medicareNumber</tt>.
        </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><p>
            Once again, the second query requires no table join.
        </p><p>
            Likewise, the special property <tt class="literal">class</tt> accesses the discriminator value
            of an instance in the case of polymorphic persistence. A Java class name embedded in the 
            where clause will be translated to its discriminator value.
        </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>
            You may also specify properties of components or composite user types (and of components 
            of components, etc). Never try to use a path-expression that ends in a property of component 
            type (as opposed to a property of a component). For example, if <tt class="literal">store.owner</tt>
            is an entity with a component <tt class="literal">address</tt>
        </p><pre class="programlisting">store.owner.address.city    // okay
store.owner.address         // error!</pre><p>
            An "any" type has the special properties <tt class="literal">id</tt> and <tt class="literal">class</tt>,
            allowing us to express a join in the following way (where <tt class="literal">AuditLog.item</tt>
            is a property mapped with <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from AuditLog log, Payment payment 
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>
            Notice that <tt class="literal">log.item.class</tt> and <tt class="literal">payment.class</tt>
            would refer to the values of completely different database columns in the above query.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>14.8.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Expressions allowed in the <tt class="literal">where</tt> clause include
            most of the kind of things you could write in SQL:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    mathematical operators <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    binary comparison operators <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    logical operations <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    string concatenation ||
                </p></li><li><p>
                    SQL scalar functions like <tt class="literal">upper()</tt> and
                    <tt class="literal">lower()</tt>
                </p></li><li><p>
                    <tt class="literal">current_date()</tt>, <tt class="literal">current_time()</tt>,
                    <tt class="literal">current_timestamp()</tt>
                </p></li><li><p>
                    Any function or operator defined by EJB-QL 3.0
                </p></li><li><p>
                    <tt class="literal">case when ... then ... else ... end</tt> 
                </p></li><li><p>
                    Parentheses <tt class="literal">( )</tt> indicate grouping
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">not in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>
                    <tt class="literal">is not null</tt>
                    <tt class="literal">is empty</tt>
                    <tt class="literal">is not empty</tt>
                    <tt class="literal">member of</tt>
                    <tt class="literal">not member of</tt>
                </p></li><li><p>
                    JDBC IN parameters <tt class="literal">?</tt>
                </p></li><li><p>
                    named parameters <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    SQL literals <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Java <tt class="literal">public static final</tt> constants <tt class="literal">eg.Color.TABBY</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> and <tt class="literal">between</tt> may be used as follows:
        </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            and the negated forms may be written
        </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            Likewise, <tt class="literal">is null</tt> and <tt class="literal">is not null</tt> may be used to test 
            for null values.
        </p><p>
            Booleans may be easily used in expressions by declaring HQL query substitutions in Hibernate
            configuration:
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            This will replace the keywords <tt class="literal">true</tt> and <tt class="literal">false</tt> with the
            literals <tt class="literal">1</tt> and <tt class="literal">0</tt> in the translated SQL from this HQL:
        </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>
            You may test the size of a collection with the special property <tt class="literal">size</tt>, or
            the special <tt class="literal">size()</tt> function.
        </p><pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre><p>
            For indexed collections, you may refer to the minimum and maximum indices using
            <tt class="literal">minindex</tt> and <tt class="literal">maxindex</tt> functions. Similarly, 
            you may refer to the minimum and maximum elements of a collection of basic type 
            using the <tt class="literal">minelement</tt> and <tt class="literal">maxelement</tt>
            functions.
        </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current date</pre><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre><p>
            The SQL functions <tt class="literal">any, some, all, exists, in</tt> are supported when passed the element 
            or index set of a collection (<tt class="literal">elements</tt> and <tt class="literal">indices</tt> functions)
            or the result of a subquery (see below).
        </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>
            Note that these constructs - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minindex</tt>, <tt class="literal">maxindex</tt>,
            <tt class="literal">minelement</tt>, <tt class="literal">maxelement</tt> - may only be used in
            the where clause in Hibernate3.
        </p><p>
            Elements of indexed collections (arrays, lists, maps) may be referred to by
            index (in a where clause only):
        </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            The expression inside <tt class="literal">[]</tt> may even be an arithmetic expression.
        </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>
            HQL also provides the built-in <tt class="literal">index()</tt> function, for elements 
            of a one-to-many association or collection of values.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><p>
            Scalar SQL functions supported by the underlying database may be used
        </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>
            If you are not yet convinced by all this, think how much longer and less readable the 
            following query would be in SQL:
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p>
            <span class="emphasis"><em>Hint:</em></span> something like
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>14.9.&nbsp;The order by clause</h2></div></div><div></div></div><p>
            The list returned by a query may be ordered by any property of a returned class or components:
        </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>
            The optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt> indicate ascending or descending order 
            respectively.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>14.10.&nbsp;The group by clause</h2></div></div><div></div></div><p>
            A query that returns aggregate values may be grouped by any property of a returned class or components:
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name) 
from Foo foo join foo.names name
group by foo.id</pre><p>
            A <tt class="literal">having</tt> clause is also allowed.
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>
            SQL functions and aggregate functions are allowed in the <tt class="literal">having</tt>
            and <tt class="literal">order by</tt> clauses, if supported by the underlying database 
            (eg. not in MySQL).
        </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>
            Note that neither the <tt class="literal">group by</tt> clause nor the
            <tt class="literal">order by</tt> clause may contain arithmetic expressions.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>14.11.&nbsp;Subqueries</h2></div></div><div></div></div><p>
            For databases that support subselects, Hibernate supports subqueries within queries. A subquery must
            be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries
            (subqueries that refer to an alias in the outer query) are allowed.
        </p><pre class="programlisting">from Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from DomesticCat cat 
)</pre><pre class="programlisting">from DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from Name as name 
)</pre><pre class="programlisting">from Cat as cat 
where not exists ( 
    from Cat as mate where mate.mate = cat 
)</pre><pre class="programlisting">from DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from Name as name 
)</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>14.12.&nbsp;HQL examples</h2></div></div><div></div></div><p>
            Hibernate queries can be quite powerful and complex. In fact, the power of the query language
            is one of Hibernate's main selling points. Here are some example queries very similar to queries
            that I used on a recent project. Note that most queries you will write are much simpler than these!
        </p><p>
            The following query returns the order id, number of items and total value of the order for all 
            unpaid orders for a particular customer and given minimum total value, ordering the results by 
            total value. In determining the prices, it uses the current catalog. The resulting SQL query, 
            against the <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> and <tt class="literal">PRICE</tt> tables has four inner joins and an
            (uncorrelated) subselect.
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            What a monster! Actually, in real life, I'm not very keen on subqueries, so my query was 
            really more like this:
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            The next query counts the number of payments in each status, excluding all payments in the
            <tt class="literal">AWAITING_APPROVAL</tt> status where the most recent status change was made by the 
            current user. It translates to an SQL query with two inner joins and a correlated subselect 
            against the <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt> and 
            <tt class="literal">PAYMENT_STATUS_CHANGE</tt> tables.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            If I would have mapped the <tt class="literal">statusChanges</tt> collection as a list, instead of a set, 
            the query would have been much simpler to write.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            The next query uses the MS SQL Server <tt class="literal">isNull()</tt> function to return all
            the accounts and unpaid payments for the organization to which the current user belongs.
            It translates to an SQL query with three inner joins, an outer join and a subselect against 
            the <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt>,
            <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> and 
            <tt class="literal">ORG_USER</tt> tables.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>
            For some databases, we would need to do away with the (correlated) subselect.
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>14.13.&nbsp;Tips &amp; Tricks</h2></div></div><div></div></div><p>
            You can count the number of query results without actually returning them:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre><p>
            To order a result by the size of a collection, use the following query:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>
            If your database supports subselects, you can place a condition upon selection
            size in the where clause of your query:
        </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>
            If your database doesn't support subselects, use the following query:
        </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>
            As this solution can't return a <tt class="literal">User</tt> with zero messages
            because of the inner join, the following form is also useful:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>
            Properties of a JavaBean can be bound to named query parameters:
        </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>
            Collections are pageable by using the <tt class="literal">Query</tt> interface with a filter:
        </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>
            Collection elements may be ordered or grouped using a query filter:
        </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>
            You can find the size of a collection without initializing it:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapter&nbsp;15.&nbsp;Criteria Queries</h2></div></div><div></div></div><p>
        Hibernate features an intuitive, extensible criteria query API.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>15.1.&nbsp;Creating a <tt class="literal">Criteria</tt> instance</h2></div></div><div></div></div><p>
            The interface <tt class="literal">org.hibernate.Criteria</tt> represents a query against
            a particular persistent class. The <tt class="literal">Session</tt> is a factory for
            <tt class="literal">Criteria</tt> instances.
        </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>15.2.&nbsp;Narrowing the result set</h2></div></div><div></div></div><p>
            An individual query criterion is an instance of the interface
            <tt class="literal">org.hibernate.criterion.Criterion</tt>. The class
            <tt class="literal">org.hibernate.criterion.Restrictions</tt> defines
            factory methods for obtaining certain built-in
            <tt class="literal">Criterion</tt> types.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>
            Restrictions may be grouped logically.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
    	.add( Restrictions.eq("age", new Integer(0) ) )
    	.add( Restrictions.eq("age", new Integer(1) ) )
    	.add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>
            There are quite a range of built-in criterion types (<tt class="literal">Restrictions</tt>
            subclasses), but one that is especially useful lets you specify SQL directly.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>
            The <tt class="literal">{alias}</tt> placeholder with be replaced by the row alias
            of the queried entity.
        </p><p>
            An alternative approach to obtaining a criterion is to get it from a 
            <tt class="literal">Property</tt> instance. You can create a <tt class="literal">Property</tt>
            by calling <tt class="literal">Property.forName()</tt>.
        </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
    	.add( age.eq( new Integer(0) ) )
    	.add( age.eq( new Integer(1) ) )
    	.add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>15.3.&nbsp;Ordering the results</h2></div></div><div></div></div><p>
            You may order the results using <tt class="literal">org.hibernate.criterion.Order</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>15.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            You may easily specify constraints upon related entities by navigating
            associations using <tt class="literal">createCriteria()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%")
    .list();</pre><p>
            note that the second <tt class="literal">createCriteria()</tt> returns a new
            instance of <tt class="literal">Criteria</tt>, which refers to the elements of
            the <tt class="literal">kittens</tt> collection.
        </p><p>
            The following, alternate form is useful in certain circumstances.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>
            (<tt class="literal">createAlias()</tt> does not create a new instance of
            <tt class="literal">Criteria</tt>.)
        </p><p>
            Note that the kittens collections held by the <tt class="literal">Cat</tt> instances
            returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered
            by the criteria! If you wish to retrieve just the kittens that match the
            criteria, you must use <tt class="literal">returnMaps()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .returnMaps()
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>15.5.&nbsp;Dynamic association fetching</h2></div></div><div></div></div><p>
            You may specify association fetching semantics at runtime using
            <tt class="literal">setFetchMode()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>
            This query will fetch both <tt class="literal">mate</tt> and <tt class="literal">kittens</tt>
            by outer join. See <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>15.6.&nbsp;Example queries</h2></div></div><div></div></div><p>
            The class <tt class="literal">org.hibernate.criterion.Example</tt> allows
            you to construct a query criterion from a given instance.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>
           Version properties, identifiers and associations are ignored. By default,
           null valued properties are excluded.
        </p><p>
           You can adjust how the <tt class="literal">Example</tt> is applied.
        </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>
            You can even use examples to place criteria upon associated objects.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-projection"></a>15.7.&nbsp;Projections, aggregation and grouping</h2></div></div><div></div></div><p>
            The class <tt class="literal">org.hibernate.criterion.Projections</tt> is a
            factory for <tt class="literal">Projection</tt> instances. We apply a
            projection to a query by calling <tt class="literal">setProjection()</tt>.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>
            There is no explicit "group by" necessary in a criteria query. Certain
            projection types are defined to be <span class="emphasis"><em>grouping projections</em></span>,
            which also appear in the SQL <tt class="literal">group by</tt> clause.
        </p><p>
            An alias may optionally be assigned to a projection, so that the projected value
            may be referred to in restrictions or orderings. Here are two different ways to
            do this:
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p>
            The <tt class="literal">alias()</tt> and <tt class="literal">as()</tt> methods simply wrap a
            projection instance in another, aliased, instance of <tt class="literal">Projection</tt>.
            As a shortcut, you can assign an alias when you add the projection to a 
            projection list:
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>
            You can also use <tt class="literal">Property.forName()</tt> to express projections:
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-detachedqueries"></a>15.8.&nbsp;Detached queries and subqueries</h2></div></div><div></div></div><p>
    		The <tt class="literal">DetachedCriteria</tt> class lets you create a query outside the scope 
    		of a session, and then later execute it using some arbitrary <tt class="literal">Session</tt>.
    	</p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );
    
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>
			A <tt class="literal">DetachedCriteria</tt> may also be used to express a subquery. Criterion
			instances involving subqueries may be obtained via <tt class="literal">Subqueries</tt> or
			<tt class="literal">Property</tt>.			
		</p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
	.setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
	.add( Property.forName("weight).gt(avgWeight) )
	.list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
	.setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
	.add( Subqueries.geAll("weight", weights) )
	.list();</pre><p>
			Even correlated subqueries are possible:
		</p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
	.setProjection( Property.forName("weight").avg() )
	.add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
	.add( Property.forName("weight).gt(avgWeightForSex) )
	.list();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapter&nbsp;16.&nbsp;Native SQL</h2></div></div><div></div></div><p>
        You may also express queries in the native SQL dialect of your database. This is useful if you
        want to utilize database specific features such as query hints or the <tt class="literal">CONNECT</tt> 
        keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based 
        application to Hibernate.
    </p><p>
        Hibernate3 allows you to specify handwritten SQL (including stored procedures) for 
        all create, update, delete, and load operations. 
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>16.1.&nbsp;Creating a native SQL <tt class="literal">Query</tt></h2></div></div><div></div></div><p>
            SQL queries are controlled via the <tt class="literal">SQLQuery</tt> interface, which 
            is obtained by calling <tt class="literal">Session.createSQLQuery()</tt>.
        </p><pre class="programlisting">List cats = sess.createSQLQuery("select {cat.*} from cats cat")
        .addEntity("cat", Cat.class);
        .setMaxResults(50);
        .list();</pre><p>
            This query specified:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            the SQL query string, with a placeholder for Hibernate to inject the column aliases
        </p></li><li><p>
            the entity returned by the query, and its SQL table alias
        </p></li></ul></div><p>
            The <tt class="literal">addEntity()</tt> method associates SQL table aliases with entity classes,
            and determines the shape of the query result set.
        </p><p>
            The <tt class="literal">addJoin()</tt> method may be used to load associations to other entities
            and collections. TODO: examples!
        </p><p>
            A native SQL query might return a simple scalar value or a combination of scalars and
            entities.
        </p><pre class="programlisting">Double max = (Double) sess.createSQLQuery("select max(cat.weight) as maxWeight from cats cat")
        .addScalar("maxWeight", Hibernate.DOUBLE);
        .uniqueResult();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-aliasreferences"></a>16.2.&nbsp;Alias and property references</h2></div></div><div></div></div><p>
            The <tt class="literal">{cat.*}</tt> notation used above is a shorthand for "all properties". 
            Alternatively, you may list the columns explicity, but even then you must let Hibernate 
            inject the SQL column aliases for each property. The placeholder for a column alias is 
            just the property name qualified by the table alias. In the following example, we retrieve 
            <tt class="literal">Cat</tt>s from a different table (<tt class="literal">cat_log</tt>) to the one 
            declared in the mapping metadata. Notice that we may even use the property aliases in the 
            where clause if we like.
            
            The <tt class="literal">{}</tt>-syntax is not required for named queries. See more in <a href="#querysql-namedqueries" title="16.3.&nbsp;Named SQL queries">Section&nbsp;16.3, &#8220;Named SQL queries&#8221;</a>
        </p><pre class="programlisting">String sql = "select cat.originalId as {cat.id}, " +
    "cat.mateid as {cat.mate}, cat.sex as {cat.sex}, " +
    "cat.weight*10 as {cat.weight}, cat.name as {cat.name} " +
    "from cat_log cat where {cat.mate} = :catId"
    
List loggedCats = sess.createSQLQuery(sql)
    .addEntity("cat", Cat.class)
    .setLong("catId", catId)
    .list();</pre><p>
            <span class="emphasis"><em>Note:</em></span> if you list each property explicitly, you must include all
            properties of the class <span class="emphasis"><em>and its subclasses</em></span>!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>16.3.&nbsp;Named SQL queries</h2></div></div><div></div></div><p>
            Named SQL queries may be defined in the mapping document and called in exactly the same way
            as a named HQL query. In this case, we do <span class="emphasis"><em>not</em></span> need to call
            <tt class="literal">addEntity()</tt>.
        </p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person WHERE person.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("mySqlQuery")
    .setMaxResults(50)
    .list();</pre><p>
            A named SQL query may return a scalar value. You must specfy the column alias
            and Hibernate type using the <tt class="literal">&lt;return-scalar&gt;</tt> element:
        </p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>
             The <tt class="literal">&lt;return-join&gt;</tt> and <tt class="literal">&lt;load-collection&gt;</tt>
             elements are used to join associations and define queries which initialize collections,
             respectively. TODO!
         </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="propertyresults"></a>16.3.1.&nbsp;Using return-property to explicitly specify column/alias names</h3></div></div><div></div></div><p>
                 With <tt class="literal">&lt;return-property&gt;</tt> you can explicitly tell Hibernate what columns
                 to use as opposed to use <tt class="literal">{}</tt>-syntax to let Hibernate inject its own aliases.                 
             </p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
      &lt;return-property name="name" column="myName"/&gt;
      &lt;return-property name="age" column="myAge"/&gt;
      &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><tt class="literal">&lt;return-property&gt;</tt> also works with multiple columns. This solves a limitation with
             the <tt class="literal">{}</tt>-syntax which can not allow fine grained control of multi-column properties.
             
             <pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
            &lt;return alias="emp" class="Employment"&gt;            
             &lt;return-property name="salary"&gt; 
               &lt;return-column name="VALUE"/&gt;
               &lt;return-column name="CURRENCY"/&gt;            
             &lt;/return-property&gt;
             &lt;return-property name="endDate" column="myEndDate"/&gt;
            &lt;/return&gt;
            SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer}, 
            STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
            REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
            FROM EMPLOYMENT
            WHERE EMPLOYER = :id AND ENDDATE IS NULL
            ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>
             Notice that in this example we used <tt class="literal">&lt;return-property&gt;</tt> in combination
             with the <tt class="literal">{}</tt>-syntax for injection. Allowing users to choose 
             how they want to refer column and properties.
            </p><p>
             If your mapping has a discriminator you must use &lt;return-discriminator&gt; to specify the 
             discriminator column.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sp_query"></a>16.3.2.&nbsp;Using stored procedures for querying</h3></div></div><div></div></div><p>
                 Hibernate 3 introduces support for queries via stored procedures. 
                 
                 The stored procedures must return a resultset as the first out-parameter to be able to work with Hibernate. 
                 
                 An example of such a stored procedure in Oracle 9 and higher is as follows:
                 
                 </p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments 
    RETURN SYS_REFCURSOR 
AS 
    st_cursor SYS_REFCURSOR; 
BEGIN 
    OPEN st_cursor FOR 
 SELECT EMPLOYEE, EMPLOYER, 
 STARTDATE, ENDDATE, 
 REGIONCODE, EID, VALUE, CURRENCY 
 FROM EMPLOYMENT; 
      RETURN  st_cursor; 
 END;</pre><p>
                 
                 To use this query in Hibernate you need to map it via a named query.
                 
             </p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;            
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;            
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;            
        &lt;return-property name="id" column="EID"/&gt;                        
        &lt;return-property name="salary"&gt; 
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;            
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</pre><p>
             </p><p>
               Notice stored procedures currently only return scalars and entities. 
               <tt class="literal">&lt;return-join&gt;</tt> and <tt class="literal">&lt;load-collection&gt;</tt> 
               are not supported.
             </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-limits-storedprocedures"></a>16.3.2.1.&nbsp;Rules/limitations for using stored procedures</h4></div></div><div></div></div><p>
                   To use stored procedures with Hibernate the procedures have to follow some rules. 
                   If they do not follow those rules they are not usable with Hibernate. If you still 
                   want to use these procedures you have to execute them via <tt class="literal">session.connection()</tt>.
                   The rules are different for each database, since database vendors have different stored
                   procedure semantics/syntax.
               </p><p>
                   For Oracle the following rules apply:
               </p><div class="itemizedlist"><ul type="disc" compact><li><p>    
                   The procedure must return a result set. This is done by returning a SYS_REFCURSOR in Oracle 9
                   or 10. In Oracle you need to define a <tt class="literal">REF CURSOR</tt> type.
               </p></li><li><p>    
                   Recommended form is <tt class="literal">{ ? = call procName(&lt;parameters&gt;) }</tt> or
                   <tt class="literal">{ ? = call procName }</tt> (This is more an Oracle rule than a Hibernate rule.)
               </p></li></ul></div><p>                   
                   For Sybase or MS SQL server the following rules apply:
               </p><div class="itemizedlist"><ul type="disc" compact><li><p>    
                   The procedure must return a result set. Note that since these servers can/will return multiple
                   result sets and update counts, Hibernate will iterate the results and take the first result that
                   is a result set as its return value. Everything else will be discarded.
               </p></li><li><p>    
                   If you can enable <tt class="literal">SET NOCOUNT ON</tt> in your procedure it will probably be
                   more efficient, but this is not a requirement.
               </p></li></ul></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-cud"></a>16.4.&nbsp;Custom SQL for create, update and delete</h2></div></div><div></div></div><p>
            Hibernate3 can use custom SQL statements for create, update, and delete operations.
            The class and collection persisters in Hibernate already contain a set of configuration
            time generated strings (insertsql, deletesql, updatesql etc.). The mapping tags
            <tt class="literal">&lt;sql-insert&gt;</tt>, <tt class="literal">&lt;sql-delete&gt;</tt>, and
            <tt class="literal">&lt;sql-update&gt;</tt> override these strings:
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>
            The SQL is directly executed in your database, so you are free to use any dialect
            you like. This will of course reduce the portability of your mapping if you use database
            specific SQL.
        </p><p>
            Stored procedures are supported if the <tt class="literal">callable</tt> attribute is set:
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>
          The order of the positional parameters are currently vital, as they must be in 
          the same sequence as Hibernate expects them.
        </p><p>
          You can see the expected order by enabling debug logging for the <tt class="literal">org.hiberante.persister.entity</tt>
          level. With this level enabled Hibernate will print out the static SQL that is used to create, update, delete etc. entities.
          To see the expected sequence, remember to not include your custom SQL in the mapping files as that will override the Hibernate generated static sql.          
        </p><p>
            The stored procedures are in most cases (read: better do it than not) required to
            return the number of rows inserted/updated/deleted, as Hibernate has some runtime
            checks for the success of the statement. Hibernate always registers the first statement
            parameter as a numeric output parameter for the CUD operations:
        </p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-load"></a>16.5.&nbsp;Custom SQL for loading</h2></div></div><div></div></div><p>
            You may also declare your own SQL (or HQL) queries for entity loading:
        </p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="p" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {p.name}, ID AS {p.id} FROM PERSON WHERE ID=? FOR UPDATE
&lt;/sql-query&gt;</pre><p>
            This is just a named query declaration, as discussed earlier. You may 
            reference this named query in a class mapping:
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>
            And this also works with stored procedures.
        </p><p>
            TODO: Document the following example for collection loader.
        </p><pre class="programlisting">&lt;sql-query name="organizationEmployments"&gt;
    &lt;load-collection alias="empcol" role="Organization.employments"/&gt;
    SELECT {empcol.*}
    FROM EMPLOYMENT empcol
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;

&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"/&gt;
    &lt;synchronize table="EMPLOYMENT"/&gt;
    SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, ID AS {emp.id}
    FROM EMPLOYMENT
    WHERE EMPLOYER = :id AND ENDDATE IS NULL
    ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="filters"></a>Chapter&nbsp;17.&nbsp;Filtering data</h2></div></div><div></div></div><p>
        Hibernate3 provides an innovative new approach to handling data with "visibility" rules.
        A <span class="emphasis"><em>Hibernate filter</em></span> is a global, named, parameterized filter that may be 
        enabled or disabled for a particular Hibernate session.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-filters"></a>17.1.&nbsp;Hibernate filters</h2></div></div><div></div></div><p>
            Hibernate3 adds the ability to pre-define filter criteria and attach those filters at both
            a class and a collection level. A filter criteria is the ability to define a restriction clause
            very similiar to the existing "where" attribute available on the class and various collection
            elements. Except these filter conditions can be parameterized. The application can then make
            the decision at runtime whether given filters should be enabled and what their parameter
            values should be. Filters can be used like database views, but parameterized inside the
            application.
        </p><p>
            In order to use filters, they must first be defined and then attached to the appropriate
            mapping elements. To define a filter, use the <tt class="literal">&lt;filter-def/&gt;</tt> element
            within a <tt class="literal">&lt;hibernate-mapping/&gt;</tt> element:
        </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre><p>
            Then, this filter can be attached to a class:
        </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>
            or, to a collection:
        </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>
            or, even to both (or multiples of each) at the same time.
        </p><p>
            The methods on <tt class="literal">Session</tt> are: <tt class="literal">enableFilter(String filterName)</tt>,
            <tt class="literal">getEnabledFilter(String filterName)</tt>, and <tt class="literal">disableFilter(String filterName)</tt>.
            By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session; they must be explcitly
            enabled through use of the <tt class="literal">Session.enabledFilter()</tt> method, which returns an
            instance of the <tt class="literal">Filter</tt> interface. Using the simple filter defined above, this
            would look like:
        </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>
            Note that methods on the org.hibernate.Filter interface do allow the method-chaining common to much of Hibernate.
        </p><p>
            A full example, using temporal data with an effective record date pattern:
        </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Then, in order to ensure that you always get back currently effective records, simply
            enable the filter on the session prior to retrieving employee data:
        </p><pre class="programlisting">Session session = ...;
session.enabledFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>
            In the HQL above, even though we only explicitly mentioned a salary constraint on the results,
            because of the enabled filter the query will return only currently active employees who have
            a salary greater than a million dollars.
        </p><p>
            Note: if you plan on using filters with outer joining (either through HQL or load fetching) be
            careful of the direction of the condition expression.  Its safest to set this up for left
            outer joining; in general, place the parameter first followed by the column name(s) after
            the operator.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapter&nbsp;18.&nbsp;XML Mapping</h2></div></div><div></div></div><p><span class="emphasis"><em>
        Note that this is an experimental feature in Hibernate 3.0 and is under
        extremely active development.
    </em></span></p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-intro"></a>18.1.&nbsp;Working with XML data</h2></div></div><div></div></div><p>
            Hibernate lets you work with persistent XML data in much the same way
            you work with persistent POJOs. A parsed XML tree can be thought of
            as just another way to represent the relational data at the object level,
            instead of POJOs.
        </p><p>
            Hibernate supports dom4j as API for manipulating XML trees. You can write 
            queries that retrieve dom4j trees from the database and have any 
            modification you make to the tree automatically synchronized to the 
            database. You can even take an XML document, parse it using dom4j, and
            write it to the database with any of Hibernate's basic operations: 
            <tt class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</tt> 
            (merging is not yet supported).
        </p><p>
            This feature has many applications including data import/export, 
            externalization of entity data via JMS or SOAP and XSLT-based reporting.
        </p><p>
            A single mapping may be used to simultaneously map properties of a class
            and nodes of an XML document to the database, or, if there is no class to map, 
            it may be used to map just the XML.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-intro-mapping"></a>18.1.1.&nbsp;Specifying XML and class mapping together</h3></div></div><div></div></div><p>
                Here is an example of mapping a POJO and XML simultaneously:
            </p><pre class="programlisting">&lt;class name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="accountId" 
            column="ACCOUNT_ID" 
            node="@id"/&gt;
            
    &lt;many-to-one name="customer" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance"/&gt;
            
    ...
    
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-onlyxml"></a>18.1.2.&nbsp;Specifying only an XML mapping</h3></div></div><div></div></div><p>
                Here is an example where there is no POJO class:
            </p><pre class="programlisting">&lt;class entity-name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="id" 
            column="ACCOUNT_ID" 
            node="@id" 
            type="string"/&gt;
            
    &lt;many-to-one name="customerId" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false" 
            entity-name="Customer"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance" 
            type="big_decimal"/&gt;
            
    ...
    
&lt;/class&gt;</pre><p>
                This mapping allows you to access the data as a dom4j tree, or as a graph of
                property name/value pairs (java <tt class="literal">Map</tt>s). The property names
                are purely logical constructs that may be referred to in HQL queries.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-mapping"></a>18.2.&nbsp;XML mapping metadata</h2></div></div><div></div></div><p>
            Many Hibernate mapping elements accept the <tt class="literal">node</tt> attribute.
            This let's you specify the name of an XML attribute or element that holds the
            property or entity data. The format of the <tt class="literal">node</tt> attribute
            must be one of the following:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">"element-name"</tt> - map to the named XML element</p></li><li><p><tt class="literal">"@attribute-name"</tt> - map to the named XML attribute</p></li><li><p><tt class="literal">"."</tt> - map to the parent element</p></li><li><p>
                <tt class="literal">"element-name/@attribute-name"</tt> - 
                map to the named attribute of the named element
            </p></li></ul></div><p>
            For collections and single valued associations, there is an additional 
            <tt class="literal">embed-xml</tt> attribute. If <tt class="literal">embed-xml="true"</tt>,
            the default, the XML tree for the associated entity (or collection of value type) 
            will be embedded directly in the XML tree for the entity that owns the association.
            Otherwise, if <tt class="literal">embed-xml="false"</tt>, then only the referenced 
            identifier value will appear in the XML for single point associations and 
            collections will simply not appear at all.
        </p><p>
            You should be careful not to leave <tt class="literal">embed-xml="true"</tt> for
            too many associations, since XML does not deal well with circularity!
        </p><pre class="programlisting">&lt;class name="Customer" 
        table="CUSTOMER" 
        node="customer"&gt;
        
    &lt;id name="id" 
            column="CUST_ID" 
            node="@id"/&gt;
            
    &lt;map name="accounts" 
            node="." 
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID" 
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC" 
                node="@short-desc" 
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false" 
                node="account/@id"/&gt;
    &lt;/map&gt;
    
    &lt;component name="name" 
            node="name"&gt;
        &lt;property name="firstName" 
                node="first-name"/&gt;
        &lt;property name="initial" 
                node="initial"/&gt;
        &lt;property name="lastName" 
                node="last-name"/&gt;
    &lt;/component&gt;
    
    ...
    
&lt;/class&gt;</pre><p>
            in this case, we have decided to embed the collection of account ids, but not
            the actual account data. The following HQL query:
        </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>
            Would return datasets such as this:
        </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"/&gt;
    &lt;account id="985612323" short-desc="Credit Card"/&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre><p>
            If you set <tt class="literal">embed-xml="true"</tt> on the <tt class="literal">&lt;one-to-many&gt;</tt>
            mapping, the data might look more like this:
        </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-manipulation"></a>18.3.&nbsp;Manipulating XML data</h2></div></div><div></div></div><p>
            Let's rearead and update XML documents in the application. We do this by
            obtaining a dom4j session:
        </p><pre class="programlisting">Document doc = ....;
       
Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>
            It is extremely useful to combine this feature with Hibernate's <tt class="literal">replicate()</tt>
            operation to implement XML-based data import/export.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;19.&nbsp;Improving performance</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>19.1.&nbsp;Fetching strategies</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>fetching strategy</em></span> is the strategy Hibernate will
            use for retrieving associated objects if the application needs to 
            navigate the association. Fetch strategies may be declared in the O/R
            mapping metadata, or over-ridden by a particular HQL or 
            <tt class="literal">Criteria</tt> query.
        </p><p>
            Hibernate3 defines the following fetching strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Join fetching</em></span> - Hibernate retrieves the
                    associated instance or collection in the same <tt class="literal">SELECT</tt>,
                    using an <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Select fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated entity or collection. Unless
                    you explicitly disable lazy fetching by specifying <tt class="literal">lazy="false"</tt>, 
                    this second select will only be executed when you actually access the
                    association.
                </p></li><li><p>
                    <span class="emphasis"><em>Subselect fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated collections for all entities retrieved in a
                    previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                    <tt class="literal">lazy="false"</tt>, this second select will only be executed when you 
                    actually access the association.
                </p></li><li><p>
                    <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                    for select fetching - Hibernate retrieves a batch of entity instances 
                    or collections in a single <tt class="literal">SELECT</tt>, by specifying 
                    a list of primary keys or foreign keys.
                </p></li></ul></div><p>
            By default, Hibernate3 uses lazy select fetching, which is the best choice for most entities 
            and collections in most applications. If you set 
            <tt class="literal">hibernate.default_batch_fetch_size</tt>, Hibernate will use the batch fetch 
            optimization to lazy fetching (this optimization may also be enabled at a more granular level).
        </p><p>
            However, there is one problem to be aware of. Access to a lazy association 
            outside of the context of an open Hibernate session will result in an exception.
            For example:
        </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
	.setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
            Since the permissions collection was not
            initialized when the <tt class="literal">Session</tt> was closed, the collection
            will not be able to load its state. <span class="emphasis"><em>Hibernate does not support lazy
            initialization for detached objects</em></span>. The fix is to move the
            code that reads from the collection to just before the commit. (There are
            other more advanced ways to solve this problem, some are discussed later.)
        </p><p>
            It is also possible to use a non-lazy collection or join fetching, which is
            non-lazy by nature. However, it is intended that lazy initialization be used 
            for almost all collections, especially for collections of entity references. 
            If you define too many non-lazy associations in your object model, Hibernate 
            will end up needing to fetch the entire database into memory in every 
            transaction!
        </p><p>
            On the other hand, we often want to choose join fetching (which is non-lazy by 
            nature) instead of select fetching in a particular transaction. We'll now see
            how to customize the fetching strategy. In Hibernate3, the mechanisms for
            choosing a fetch strategy are identical for single-valued associations and
            collections.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>19.1.1.&nbsp;Tuning fetch strategies</h3></div></div><div></div></div><p>
				Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
				so we might want to enable join fetching in the mapping document:
			</p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>
                The fetch strategy defined in the mapping document affects:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                    retrieval via <tt class="literal">get()</tt> or <tt class="literal">load()</tt>
                </p></li><li><p>
                    retrieval that happens implicitly when an association is navigated
                    (lazy fetching)
                </p></li><li><p>
                    <tt class="literal">Criteria</tt> queries
                </p></li></ul></div><p>
        		<span class="emphasis"><em>Specifying <tt class="literal">join</tt> as the fetch strategy in the mapping 
        		document does not affect HQL queries.</em></span>
        	</p><p>
                Usually, we don't use the mapping document to customize fetching. Instead, we
                keep the default behavior, and override it for a particular transaction, using 
                the HQL <tt class="literal">LEFT JOIN FETCH</tt> clause. This tells Hibernate to fetch 
                the association eagerly in the first select, using an outer join. In the
                <tt class="literal">Criteria</tt> query API, you would use
                <tt class="literal">setFetchMode(FetchMode.JOIN)</tt>.
            </p><p>
            	If you ever feel like you wish you could change the fetching strategy used by
            	<tt class="literal">get()</tt> or <tt class="literal">load()</tt>, simply use a 
            	<tt class="literal">Criteria</tt> query, for example:
            </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
            	.setFetchMode("permissions", FetchMode.JOIN)
            	.add( Restrictions.idEq(userId) )
            	.uniqueResult();</pre><p>
                (This is Hibernate's equivalent of what some ORM solutions call a "fetch plan".)
            </p><p>
                Join fetching for collections has one limitation: you may only set one collection 
                role per persistent class or query to be fetched per outer join. Hibernate forbids
                Cartesian products when possible, <tt class="literal">SELECT</tt>ing two collections per
                outer join would create one. This would almost always be slower than two (lazy or
                non-deferred) <tt class="literal">SELECT</tt>s. The restriction to a single outer-joined
                collection applies to both the mapping fetching strategies and to HQL/Criteria 
                queries.
            </p><p>
                If you run into this limitation, you should use subselect or batch fetching to
                achieve acceptable performance. This is common when retrieving a tree of
                collection-valued associations.
            </p><p>
                There are no restrictions to join fetching of single-ended associations.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>19.1.2.&nbsp;Single-ended association proxies</h3></div></div><div></div></div><p>
                Lazy fetching for collections is implemented using Hibernate's own implementation
                of persistent collections. However, a different mechanism is needed for lazy
                behavior in single-ended associations. The target entity of the association must
                be proxied. Hibernate implements lazy initializing proxies for persistent objects
                using runtime bytecode enhancement (via the excellent CGLIB library).
            </p><p>
                By default, Hibernate3 generates proxies (at startup) for all persistent classes
                and uses them to enable lazy fetching of <tt class="literal">many-to-one</tt> and
                <tt class="literal">one-to-one</tt> associations.
            </p><p>
                The mapping file may declare an interface to use as the proxy interface for that
                class, with the <tt class="literal">proxy</tt> attribute. By default, Hibernate uses a subclass
                of the class. <span class="emphasis"><em>Note that the proxied class must implement a default constructor
                with at least package visibility. We recommend this constructor for all persistent classes!</em></span>
            </p><p>
                There are some gotchas to be aware of when extending this approach to polymorphic
                classes, eg.
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Firstly, instances of <tt class="literal">Cat</tt> will never be castable to
                <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
                instance of <tt class="literal">DomesticCat</tt>:
            </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
                Secondly, it is possible to break proxy <tt class="literal">==</tt>.
            </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
                However, the situation is not quite as bad as it looks. Even though we now have two references
                to different proxy objects, the underlying instance will still be the same object:
            </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
                Third, you may not use a CGLIB proxy for a <tt class="literal">final</tt> class or a class
                with any <tt class="literal">final</tt> methods.
            </p><p>
                Finally, if your persistent object acquires any resources upon instantiation (eg. in
                initializers or default constructor), then those resources will also be acquired by
                the proxy. The proxy class is an actual subclass of the persistent class.
            </p><p>
                These problems are all due to fundamental limitations in Java's single inheritance model.
                If you wish to avoid these problems your persistent classes must each implement an interface
                that declares its business methods. You should specify these interfaces in the mapping file. eg.
            </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                where <tt class="literal">CatImpl</tt> implements the interface <tt class="literal">Cat</tt> and
                <tt class="literal">DomesticCatImpl</tt> implements the interface <tt class="literal">DomesticCat</tt>. Then
                proxies for instances of <tt class="literal">Cat</tt> and <tt class="literal">DomesticCat</tt> may be returned
                by <tt class="literal">load()</tt> or <tt class="literal">iterate()</tt>. (Note that <tt class="literal">list()</tt>
                does not usually return proxies.)
            </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.iterate("from CatImpl as cat where cat.name='fritz'");
Cat fritz = (Cat) iter.next();</pre><p>
                Relationships are also lazily initialized. This means you must declare any properties to be of
                type <tt class="literal">Cat</tt>, not <tt class="literal">CatImpl</tt>.
            </p><p>
                Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">equals()</tt>, if the persistent class does not override
                        <tt class="literal">equals()</tt>
                    </p></li><li><p>
                        <tt class="literal">hashCode()</tt>, if the persistent class does not override
                        <tt class="literal">hashCode()</tt>
                    </p></li><li><p>
                        The identifier getter method
                    </p></li></ul></div><p>
                Hibernate will detect persistent classes that override <tt class="literal">equals()</tt> or
                <tt class="literal">hashCode()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>19.1.3.&nbsp;Initializing collections and proxies</h3></div></div><div></div></div><p>
                A <tt class="literal">LazyInitializationException</tt> will be thrown by Hibernate if an uninitialized 
                collection or proxy is accessed outside of the scope of the <tt class="literal">Session</tt>, ie. when 
                the entity owning the collection or having the reference to the proxy is in the detached state.
            </p><p>
                Sometimes we need to ensure that a proxy or collection is initialized before closing the
                <tt class="literal">Session</tt>. Of course, we can alway force initialization by calling
                <tt class="literal">cat.getSex()</tt> or <tt class="literal">cat.getKittens().size()</tt>, for example.
                But that is confusing to readers of the code and is not convenient for generic code.
            </p><p>
                The static methods <tt class="literal">Hibernate.initialize()</tt> and <tt class="literal">Hibernate.isInitialized()</tt>
                provide the application with a convenient way of working with lazily initialized collections or
                proxies. <tt class="literal">Hibernate.initialize(cat)</tt> will force the initialization of a proxy,
                <tt class="literal">cat</tt>, as long as its <tt class="literal">Session</tt> is still open.
                <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> has a similar effect for the collection
                of kittens.
            </p><p>
                Another option is to keep the <tt class="literal">Session</tt> open until all needed
                collections and proxies have been loaded. In some application architectures,
                particularly where the code that accesses data using Hibernate, and the code that
                uses it are in different application layers or different physical processes, it 
                can be a problem to ensure that the <tt class="literal">Session</tt> is open when a 
                collection is initialized. There are two basic ways to deal with this issue:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        In a web-based application, a servlet filter can be used to close the
                        <tt class="literal">Session</tt> only at the very end of a user request, once
                        the rendering of the view is complete (the <span class="emphasis"><em>Open Session in
                        View</em></span> pattern).  Of course, this places heavy demands on the 
                        correctness of the exception handling of your application infrastructure. 
                        It is vitally important that the <tt class="literal">Session</tt> is closed and the 
                        transaction ended before returning to the user, even when an exception occurs 
                        during rendering of the view. The servlet filter has to be able to access the 
                        <tt class="literal">Session</tt> for this approach. We recommend that a 
                        <tt class="literal">ThreadLocal</tt> variable be used to hold the current 
                        <tt class="literal">Session</tt> (see chapter 1, 
                        <a href="#quickstart-playingwithcats" title="1.4.&nbsp;Playing with cats">Section&nbsp;1.4, &#8220;Playing with cats&#8221;</a>, for an example implementation).
                    </p></li><li><p>
                        In an application with a separate business tier, the business logic must
                        "prepare" all collections that will be needed by the web tier before
                        returning. This means that the business tier should load all the data and
                        return all the data already initialized to the presentation/web tier that
                        is required for a particular use case. Usually, the application calls
                        <tt class="literal">Hibernate.initialize()</tt> for each collection that will
                        be needed in the web tier (this call must occur before the session is closed)
                        or retrieves the collection eagerly using a Hibernate query with a
                        <tt class="literal">FETCH</tt> clause or a <tt class="literal">FetchMode.JOIN</tt> in
                        <tt class="literal">Criteria</tt>. This is usually easier if you adopt the
                        <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        You may also attach a previously loaded object to a new <tt class="literal">Session</tt>
                        with <tt class="literal">merge()</tt> or <tt class="literal">lock()</tt> before
                        accessing uninitialized collections (or other proxies). No, Hibernate does not,
                        and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                        would introduce ad hoc transaction semantics!
                    </p></li></ul></div><p>
                Sometimes you don't want to initialize a large collection, but still need some
                information about it (like its size) or a subset of the data.
            </p><p>
                You can use a collection filter to get the size of a collection without initializing it:
            </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>
                The <tt class="literal">createFilter()</tt> method is also used to efficiently retrieve subsets
                of a collection without needing to initialize the whole collection:
            </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>19.1.4.&nbsp;Using batch fetching</h3></div></div><div></div></div><p>
                Hibernate can make efficient use of batch fetching, that is, Hibernate can load several uninitialized
                proxies if one proxy is accessed (or collections. Batch fetching is an optimization of the lazy select
                fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
            </p><p>
                Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                at runtime: You have 25 <tt class="literal">Cat</tt> instances loaded in a <tt class="literal">Session</tt>, each
                <tt class="literal">Cat</tt> has a reference to its <tt class="literal">owner</tt>, a <tt class="literal">Person</tt>.
                The <tt class="literal">Person</tt> class is mapped with a proxy, <tt class="literal">lazy="true"</tt>. If you now
                iterate through all cats and call <tt class="literal">getOwner()</tt> on each, Hibernate will by default
                execute 25 <tt class="literal">SELECT</tt> statements, to retrieve the proxied owners. You can tune this
                behavior by specifying a <tt class="literal">batch-size</tt> in the mapping of <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                Hibernate will now execute only three queries, the pattern is 10, 10, 5.
            </p><p>
                You may also enable batch fetching of collections. For example, if each <tt class="literal">Person</tt> has
                a lazy collection of <tt class="literal">Cat</tt>s, and 10 persons are currently loaded in the
                <tt class="literal">Sesssion</tt>, iterating through all persons will generate 10 <tt class="literal">SELECT</tt>s,
                one for every call to <tt class="literal">getCats()</tt>. If you enable batch fetching for the
                <tt class="literal">cats</tt> collection in the mapping of <tt class="literal">Person</tt>, Hibernate can pre-fetch
                collections:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                With a <tt class="literal">batch-size</tt> of 8, Hibernate will load 3, 3, 3, 1 collections in four
                <tt class="literal">SELECT</tt>s. Again, the value of the attribute depends on the expected number of
                uninitialized collections in a particular <tt class="literal">Session</tt>.
            </p><p>
                Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazyproperties"></a>19.1.5.&nbsp;Using lazy property fetching</h3></div></div><div></div></div><p>
                Hibernate3 supports the lazy fetching of individual properties. This optimization technique
                is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a
                marketing feature, as in practice, optimizing row reads is much more important than
                optimization of column reads. However, only loading some properties of a class might
                be useful in extreme cases, when legacy tables have hundreds of columns and the data model
                can not be improved.
            </p><p>
                To enable lazy property loading, set the <tt class="literal">lazy</tt> attribute on your
                particular property mappings:
            </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>
                Lazy property loading requires buildtime bytecode instrumentation! If your persistent
                classes are not enhanced, Hibernate will silently ignore lazy property settings and
                fall back to immediate fetching.
            </p><p>
                For bytecode instrumentation, use the following Ant task:
            </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>
                A different (better?) way to avoid unnecessary column reads, at least for
                read-only transactions is to use the projection features of HQL or Criteria
                queries. This avoids the need for buildtime bytecode processing and is
                certainly a prefered solution.
            </p></div><p>
            A completely different way to avoid problems with N+1 selects is to use the second-level
            cache.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>19.2.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A Hibernate <tt class="literal">Session</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or JVM-level (<tt class="literal">SessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
        </p><p>
            By default, Hibernate uses EHCache for JVM-level caching. (JCS support is now deprecated and will 
            be removed in a future version of Hibernate.) You may choose a different implementation by 
            specifying the name of a class that implements <tt class="literal">org.hibernate.cache.CacheProvider</tt>
            using the property <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">org.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">org.hibernate.cache.EhCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">org.hibernate.cache.OSCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">org.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">org.hibernate.cache.TreeCacheProvider</tt></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>19.2.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> specifies the caching strategy:
                            <tt class="literal">transactional</tt>,
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr></table></div></div><p>
                Alternatively (preferrably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>19.2.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. It's even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>19.2.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required. 
                If the cache is used in a JTA environment, you must specify the property 
                <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, naming a strategy for obtaining the 
                JTA <tt class="literal">TransactionManager</tt>. In other environments, you should ensure that the transaction 
                is completed when <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called. 
                If you wish to use this strategy in a cluster, you should ensure that the underlying cache implementation 
                supports locking. The built-in cache providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>19.2.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate. If the cache is 
                used in a JTA environment, you must specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
                In other environments, you should ensure that the transaction is completed when 
                <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>19.2.5.&nbsp;Strategy: transactional</h3></div></div><div></div></div><p>
                The <tt class="literal">transactional</tt> cache strategy provides support for fully transactional cache
                providers such as JBoss TreeCache. Such a cache may only be used in a JTA environment and you must 
                specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            None of the cache providers support all of the cache concurrency strategies. The following table shows
            which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e11622"></a><p class="title"><b>Table&nbsp;19.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>19.3.&nbsp;Managing the caches</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">save()</tt>, <tt class="literal">update()</tt>
            or <tt class="literal">saveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">load()</tt>, <tt class="literal">get()</tt>, <tt class="literal">list()</tt>, 
            <tt class="literal">iterate()</tt> or <tt class="literal">scroll()</tt>, that object is added 
            to the internal cache of the <tt class="literal">Session</tt>. 
        </p><p>
            When <tt class="literal">flush()</tt> is subsequently called, the state of that object will 
            be synchronized with the database. If you do not want this synchronization to occur or 
            if you are processing a huge number of objects and need to manage memory efficiently, 
            the <tt class="literal">evict()</tt> method may be used to remove the object and its collections 
            from the first-level cache.
        </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
            The <tt class="literal">Session</tt> also provides a <tt class="literal">contains()</tt> method to determine 
            if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">Session.clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">SessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>
            The <tt class="literal">CacheMode</tt> controls how a particular session interacts with the second-level
            cache.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">CacheMode.NORMAL</tt> - read items from and write items to the second-level cache
        </p></li><li><p>
            <tt class="literal">CacheMode.GET</tt> - read items from the second-level cache, but don't write to
            the second-level cache except when updating data
        </p></li><li><p>
            <tt class="literal">CacheMode.PUT</tt> - write items to the second-level cache, but don't read from
            the second-level cache
        </p></li><li><p>
            <tt class="literal">CacheMode.REFRESH</tt> - write items to the second-level cache, but don't read from
            the second-level cache, bypass the effect of <tt class="literal">hibernate.cache.use_minimal_puts</tt>, forcing
            a refresh of the second-level cache for all items read from the database
        </p></li></ul></div><p>
            To browse the contents of a second-level or query cache region, use the <tt class="literal">Statistics</tt>
            API:
        </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>
            You'll need to enable statistics, and, optionally, force Hibernate to keep the cache entries in a
            more human-understandable format:
        </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>19.4.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>
            This setting causes the creation of two new cache regions - one holding cached query 
            result sets (<tt class="literal">org.hibernate.cache.StandardQueryCache</tt>), the other 
            holding timestamps of the most recent updates to queryable tables 
            (<tt class="literal">org.hibernate.cache.UpdateTimestampsCache</tt>). Note that the query
            cache does not cache the state of the actual entities in the result set; it caches 
            only identifier values and results of value type. So the query cache should always be
            used in conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">Query.setCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>
            If the query should force a refresh of its query cache region, you should call
            <tt class="literal">Query.setCacheMode(CacheMode.REFRESH)</tt>. This is particularly useful 
            in cases where underlying data may have been updated via a separate process (i.e., 
            not modified through Hibernate) and allows the application to selectively refresh 
            particular query result sets. This is a more efficient alternative to eviction of 
            a query cache region via <tt class="literal">SessionFactory.evictQueries()</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>19.5.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>19.5.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>Hibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by Hibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when Hibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                <tt class="literal">&lt;idbag&gt;</tt> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. Hibernate has no way of distinguishing
                between duplicate rows. Hibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how Hibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>19.5.2.&nbsp;Lists, maps, idbags and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of a
                <tt class="literal">Set</tt>, Hibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to a <tt class="literal">Set</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and 
                idbags are the most performant (non-inverse) collection types, with sets not far 
                behind. Sets are expected to be the most common kind of collection in Hibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </p><p>
                However, in well-designed Hibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <tt class="literal">inverse="true"</tt>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>19.5.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">Collection.add()</tt> or <tt class="literal">Collection.addAll()</tt> must always
                return true for a bag or <tt class="literal">List</tt> (unlike a <tt class="literal">Set</tt>). This can
                make the following common code much faster.
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //no need to fetch the collection!
    sess.flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>19.5.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. Hibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.clear()</tt>, for example). In this case, Hibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                Hibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed
            </p><div class="itemizedlist"><ul type="disc"><li><p>delete eighteen rows one by one and then insert three rows</p></li><li><p>remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                Hibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for Hibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p><p>
                Of course, one-shot-delete does not apply to collections mapped <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-monitoring"></a>19.6.&nbsp;Monitoring performance</h2></div></div><div></div></div><p>
            Optimization is not much use without monitoring and access to performance numbers.
            Hibernate provides a full range of figures about its internal operations.
            Statistics in Hibernate are available per <tt class="literal">SessionFactory</tt>.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-sf"></a>19.6.1.&nbsp;Monitoring a SessionFactory</h3></div></div><div></div></div><p>
                You can access <tt class="literal">SessionFactory</tt> metrics in two ways.
                Your first option is to call <tt class="literal">sessionFactory.getStatistics()</tt> and
                read or display the <tt class="literal">Statistics</tt> yourself.
            </p><p>
                Hibernate can also use JMX to publish metrics if you enable the
                <tt class="literal">StatisticsService</tt> MBean. You may enable a single MBean for all your
                <tt class="literal">SessionFactory</tt> or one per factory. See the following code for
                minimalistic configuration examples:
            </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>
                TODO: This doesn't make sense: In the first case, we retrieve and use the MBean directly. In the second one, we must give
                the JNDI name in which the session factory is held before using it. Use
                <tt class="literal">hibernateStatsBean.setSessionFactoryJNDIName("my/JNDI/Name")</tt>
            </p><p>
                You can (de)activate the monitoring for a <tt class="literal">SessionFactory</tt>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        at configuration time, set <tt class="literal">hibernate.generate_statistics</tt> to <tt class="literal">false</tt>
                    </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                        at runtime: <tt class="literal">sf.getStatistics().setStatisticsEnabled(true)</tt>
                        or <tt class="literal">hibernateStatsBean.setStatisticsEnabled(true)</tt>
                    </p></li></ul></div><p>
                Statistics can be reset programatically using the <tt class="literal">clear()</tt> method.
                A summary can be sent to a logger (info level) using the <tt class="literal">logSummary()</tt>
                method.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-metrics"></a>19.6.2.&nbsp;Metrics</h3></div></div><div></div></div><p>
                Hibernate provides a number of metrics, from very basic to the specialized information
                only relevant in certain scenarios. All available counters are described in the
                <tt class="literal">Statistics</tt> interface API, in three categories:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Metrics related to the general <tt class="literal">Session</tt> usage, such as
                        number of open sessions, retrieved JDBC connections, etc.
                    </p></li><li><p>
                        Metrics related to he entities, collections, queries, and caches as a
                        whole (aka global metrics),
                    </p></li><li><p>
                        Detailed metrics related to a particular entity, collection, query or
                        cache region.
                    </p></li></ul></div><p>
                For exampl,e you can check the cache hit, miss, and put ratio of entities, collections
                and queries, and the average time a query needs. Beware that the number of milliseconds
                is subject to approximation in Java. Hibernate is tied to the JVM precision, on some
                platforms this might even only be accurate to 10 seconds.
            </p><p>
                Simple getters are used to access the global metrics (i.e. not tied to a particular entity,
                collection, cache region, etc.). You can access the metrics of a particular entity, collection
                or cache region through its name, and through its HQL or SQL representation for queries. Please
                refer to the <tt class="literal">Statistics</tt>, <tt class="literal">EntityStatistics</tt>,
                <tt class="literal">CollectionStatistics</tt>, <tt class="literal">SecondLevelCacheStatistics</tt>,
                and <tt class="literal">QueryStatistics</tt> API Javadoc for more information. The following
                code shows a simple example:
            </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>
                To work on all entities, collections, queries and region caches, you can retrieve
                the list of names of entities, collections, queries and region caches with the
                following methods: <tt class="literal">getQueries()</tt>, <tt class="literal">getEntityNames()</tt>,
                <tt class="literal">getCollectionRoleNames()</tt>, and
                <tt class="literal">getSecondLevelCacheRegionNames()</tt>.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapter&nbsp;20.&nbsp;Toolset Guide</h2></div></div><div></div></div><p>
        Roundtrip engineering with Hibernate is possible using a set of Eclipse plugins,
        commandline tools, as well as Ant tasks.
    </p><p>
        The <span class="emphasis"><em>Hibernate Tools</em></span> currently include plugins for the Eclipse
        IDE as well as Ant tasks for reverse engineering of existing databases:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            <span class="emphasis"><em>Mapping Editor:</em></span> An editor for Hibernate XML mapping files,
            supporting auto-completion and syntax highlighting. It also supports semantic
            auto-completion for class names and property/field names, making it much more versatile than a normal XML editor.
        </p></li><li><p>
            <span class="emphasis"><em>Console:</em></span> The console is a new view in Eclipse. In addition to
            a tree overview of your console configurations, you also get an interactive view
            of your persistent classes and their relationships. The console allows you to
            execute HQL queries against your database and browse the result directly in
            Eclipse.
        </p></li><li><p>
            <span class="emphasis"><em>Development Wizards:</em></span> Several wizards are provided with the
            Hibernate Eclipse tools; you can use a wizard to quickly generate Hibernate configuration
            (cfg.xml) files, or you may even completely reverse engineer an existing database schema
            into POJO source files and Hibernate mapping files. The reverse engineering wizard
            supports customizable templates.
        </p></li><li><p>
            <span class="emphasis"><em>Ant Tasks:</em></span>
        </p></li></ul></div><p>
        Please refer to the <span class="emphasis"><em>Hibernate Tools</em></span> package and it's documentation
        for more information.
    </p><p>
        However, the Hibernate main package comes bundled with an integrated tool (it can even
        be used from "inside" Hibernate on-the-fly): <span class="emphasis"><em>SchemaExport</em></span> aka
        <tt class="literal">hbm2ddl</tt>.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>20.1.&nbsp;Automatic schema generation</h2></div></div><div></div></div><p>
            DDL may be generated from your mapping files by a Hibernate utility. The generated
            schema includes referential integrity constraints (primary and foreign keys) for
            entity and collection tables. Tables and sequences are also created for mapped
            identifier generators.
        </p><p>
            You <span class="emphasis"><em>must</em></span> specify a SQL <tt class="literal">Dialect</tt> via the 
            <tt class="literal">hibernate.dialect</tt> property when using this tool, as DDL
            is highly vendor specific.
        </p><p>
            First, customize your mapping files to improve the generated schema.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>20.1.1.&nbsp;Customizing the schema</h3></div></div><div></div></div><p>
                Many Hibernate mapping elements define an optional attribute named <tt class="literal">length</tt>. You may set 
                the length of a column with this attribute. (Or, for numeric/decimal data types, the precision.)
            </p><p>
                Some tags also accept a <tt class="literal">not-null</tt> attribute (for generating a <tt class="literal">NOT NULL</tt>
                constraint on table columns) and a <tt class="literal">unique</tt> attribute (for generating <tt class="literal">UNIQUE</tt>
                constraint on table columns).
            </p><p>
                Some tags accept an <tt class="literal">index</tt> attribute for specifying the
                name of an index for that column. A <tt class="literal">unique-key</tt> attribute
                can be used to group columns in a single unit key constraint. Currently, the
                specified value of the <tt class="literal">unique-key</tt> attribute is
                <span class="emphasis"><em>not</em></span> used to name the constraint, only to group the
                columns in the mapping file.
            </p><p>
                Examples:
            </p><pre class="programlisting">&lt;property name="foo" type="string" length="64" not-null="true"/&gt;

&lt;many-to-one name="bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="long" not-null="true" unique="true"/&gt;</pre><p>
                Alternatively, these elements also accept a child <tt class="literal">&lt;column&gt;</tt> element. This is
                particularly useful for multi-column types:
            </p><pre class="programlisting">&lt;property name="foo" type="string"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="bar" type="my.customtypes.MultiColumnType"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">sql-type</tt> attribute allows the user to override the default mapping
                of Hibernate type to SQL datatype.
            </p><p>
                The <tt class="literal">check</tt> attribute allows you to specify a check constraint.
            </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Values</th><th>Interpretation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>number</td><td>column length/decimal precision</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>specfies that the column should be non-nullable</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>specifies that the column should have a unique constraint</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>specifies the name of a (multi-column) index</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>specifies the name of a multi-column unique constraint</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                specifies the name of the foreign key constraint generated
                                for an association, use it on &lt;one-to-one&gt;, &lt;many-to-one&gt;,
                                &lt;key&gt;, and &lt;many-to-many&gt; mapping elements. Note that
                                <tt class="literal">inverse="true"</tt> sides will not be considered
                                by <tt class="literal">SchemaExport</tt>.
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">column_type</tt></td><td>
                                overrides the default column type (attribute of 
                                <tt class="literal">&lt;column&gt;</tt> element only)
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                create an SQL check constraint on either column or table
                            </td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>20.1.2.&nbsp;Running the tool</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaExport</tt> tool writes a DDL script to standard out and/or
                executes the DDL statements.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">org.hibernate.tool.hbm2ddl.SchemaExport</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e12359"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;<tt class="literal">SchemaExport</tt> Command Line Options</b></p><table summary="SchemaExport Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the script to stdout</td></tr><tr><td><tt class="literal">--drop</tt></td><td>only drop the tables</td></tr><tr><td><tt class="literal">--text</tt></td><td>don't export to the database</td></tr><tr><td><tt class="literal">--output=my_schema.ddl</tt></td><td>output the ddl script to a file</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>read Hibernate configuration from an XML file</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr><tr><td><tt class="literal">--format</tt></td><td>format the generated SQL nicely in the script</td></tr><tr><td><tt class="literal">--delimiter=x</tt></td><td>set an end of line delimiter for the script</td></tr></tbody></table></div><p>
                You may even embed <tt class="literal">SchemaExport</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>20.1.3.&nbsp;Properties</h3></div></div><div></div></div><p>
                Database properties may be specified
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>as system properties with <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>in <tt class="literal">hibernate.properties</tt></p></li><li><p>in a named properties file with <tt class="literal">--properties</tt></p></li></ul></div><p>
                The needed properties are:
            </p><div class="table"><a name="d0e12454"></a><p class="title"><b>Table&nbsp;20.3.&nbsp;SchemaExport Connection Properties</b></p><table summary="SchemaExport Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>jdbc driver class</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>jdbc url</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>database user</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>user password</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialect</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>20.1.4.&nbsp;Using Ant</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaExport</tt> from your Ant build script:
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-6"></a>20.1.5.&nbsp;Incremental schema updates</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaUpdate</tt> tool will update an existing schema with "incremental" changes.
                Note that <tt class="literal">SchemaUpdate</tt> depends heavily upon the JDBC metadata API, so it will
                not work with all JDBC drivers.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">org.hibernate.tool.hbm2ddl.SchemaUpdate</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e12531"></a><p class="title"><b>Table&nbsp;20.4.&nbsp;<tt class="literal">SchemaUpdate</tt> Command Line Options</b></p><table summary="SchemaUpdate Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the script to stdout</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr></tbody></table></div><p>
                You may embed <tt class="literal">SchemaUpdate</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-7"></a>20.1.6.&nbsp;Using Ant for incremental schema updates</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaUpdate</tt> from the Ant script:
            </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapter&nbsp;21.&nbsp;Example: Parent/Child</h2></div></div><div></div></div><p>
        One of the very first things that new users try to do with Hibernate is to model a parent / child type 
        relationship. There are two different approaches to this. For various reasons the most convenient 
        approach, especially for new users, is to model both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> 
        as entity classes with a <tt class="literal">&lt;one-to-many&gt;</tt> association from <tt class="literal">Parent</tt> 
        to <tt class="literal">Child</tt>. (The alternative approach is to declare the <tt class="literal">Child</tt> as a 
        <tt class="literal">&lt;composite-element&gt;</tt>.) Now, it turns out that default semantics of a one to many 
        association (in Hibernate) are much less close to the usual semantics of a parent / child relationship than 
        those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one to many 
        association with cascades</em></span> to model a parent / child relationship efficiently and elegantly. 
        It's not at all difficult!
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>21.1.&nbsp;A note about collections</h2></div></div><div></div></div><p>
            Hibernate collections are considered to be a logical part of their owning entity; never of the
            contained entities. This is a crucial distinction! It has the following consequences:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                When we remove / add an object from / to a collection, the version number of the collection owner
                is incremented.
            </p></li><li><p>
                If an object that was removed from a collection is an instance of a value type (eg, a composite
                element), that object will cease to be persistent and its state will be completely removed from
                the database. Likewise, adding a value type instance to the collection will cause its state to be
                immediately persistent.
            </p></li><li><p>
                On the other hand, if an entity is removed from a collection (a one-to-many or many-to-many
                association), it will not be deleted, by default. This behaviour is completely consistent - a
                change to the internal state of another entity should not cause the associated entity to vanish!
                Likewise, adding an entity to a collection does not cause that entity to become persistent, by
                default.
            </p></li></ul></div><p>
            Instead, the default behaviour is that adding an entity to a collection merely creates a link between
            the two entities, while removing it removes the link. This is very appropriate for all sorts of cases.
            Where it is not appropriate at all is the case of a parent / child relationship, where the life of the
            child is bound to the lifecycle of the parent.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>21.2.&nbsp;Bidirectional one-to-many</h2></div></div><div></div></div><p>
            Suppose we start with a simple <tt class="literal">&lt;one-to-many&gt;</tt> association from
            <tt class="literal">Parent</tt> to <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            If we were to execute the following code
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Hibernate would issue two SQL statements:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an <tt class="literal">INSERT</tt> to create the record for <tt class="literal">c</tt></p></li><li><p>
                an <tt class="literal">UPDATE</tt> to create the link from <tt class="literal">p</tt> to
                <tt class="literal">c</tt>
            </p></li></ul></div><p>
            This is not only inefficient, but also violates any <tt class="literal">NOT NULL</tt> constraint on the
            <tt class="literal">parent_id</tt> column. We can fix the nullability constraint violation by specifying
            <tt class="literal">not-null="true"</tt> in the collection mapping:
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
        	However, this is not the recommended solution.
       	</p><p>
            The underlying cause of this behaviour is that the link (the foreign key <tt class="literal">parent_id</tt>) 
            from <tt class="literal">p</tt> to <tt class="literal">c</tt> is not considered part of the state of the 
            <tt class="literal">Child</tt> object and is therefore not created in the <tt class="literal">INSERT</tt>. So the 
            solution is to make the link part of the <tt class="literal">Child</tt> mapping.
        </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (We also need to add the <tt class="literal">parent</tt> property to the <tt class="literal">Child</tt> class.)
        </p><p>
            Now that the <tt class="literal">Child</tt> entity is managing the state of the link, we tell the collection 
            not to update the link. We use the <tt class="literal">inverse</tt> attribute.
        </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            The following code would be used to add a new <tt class="literal">Child</tt>
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            And now, only one SQL <tt class="literal">INSERT</tt> would be issued!
        </p><p>
            To tighten things up a bit, we could create an <tt class="literal">addChild()</tt> method of
            <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>
            Now, the code to add a <tt class="literal">Child</tt> looks like
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>21.3.&nbsp;Cascading lifecycle</h2></div></div><div></div></div><p>
             The explicit call to <tt class="literal">save()</tt> is still annoying. We will address this by
             using cascades.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             This simplifies the code above to
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>
             Similarly, we don't need to iterate over the children when saving or deleting a <tt class="literal">Parent</tt>.
             The following removes <tt class="literal">p</tt> and all its children from the database.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>
             However, this code
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>
             will not remove <tt class="literal">c</tt> from the database; it will ony remove the link to <tt class="literal">p</tt>
             (and cause a <tt class="literal">NOT NULL</tt> constraint violation, in this case). You need to explicitly
             <tt class="literal">delete()</tt> the <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>
             Now, in our case, a <tt class="literal">Child</tt> can't really exist without its parent. So if we remove
             a <tt class="literal">Child</tt> from the collection, we really do want it to be deleted. For this, we must
             use <tt class="literal">cascade="all-delete-orphan"</tt>.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Note: even though the collection mapping specifies <tt class="literal">inverse="true"</tt>, cascades are 
             still processed by iterating the collection elements. So if you require that an object be saved, 
             deleted or updated by cascade, you must add it to the collection. It is not enough to simply call
             <tt class="literal">setParent()</tt>.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>21.4.&nbsp;Cascades and <tt class="literal">unsaved-value</tt></h2></div></div><div></div></div><p>
             Suppose we loaded up a <tt class="literal">Parent</tt> in one <tt class="literal">Session</tt>, made some changes 
             in a UI action and wish to persist these changes in a new session by calling <tt class="literal">update()</tt>. 
             The <tt class="literal">Parent</tt> will contain a collection of childen and, since cascading update is enabled, 
             Hibernate needs to know which children are newly instantiated and which represent existing rows in the 
             database. Lets assume that both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> have genenerated
             identifier properties of type <tt class="literal">Long</tt>. Hibernate will use the identifier and 
             version/timestamp property value to determine which of the children are new. (See
             <a href="#objectstate-saveorupdate" title="10.7.&nbsp;Automatic state detection">Section&nbsp;10.7, &#8220;Automatic state detection&#8221;</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify
             an <tt class="literal">unsaved-value</tt> explicitly.</em></span>
         </p><p>
             The following code will update <tt class="literal">parent</tt> and <tt class="literal">child</tt> and insert 
             <tt class="literal">newChild</tt>.
         </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>
             Well, that's all very well for the case of a generated identifier, but what about assigned identifiers
             and composite identifiers? This is more difficult, since Hibernate can't use the identifier property to
             distinguish between a newly instantiated object (with an identifier assigned by the user) and an 
             object loaded in a previous session. In this case, Hibernate will either use the timestamp or version 
             property, or will actually query the second-level cache or, worst case, the database, to see if the 
             row exists.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>21.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
             There is quite a bit to digest here and it might look confusing first time around. However, in practice, 
             it all works out very nicely. Most Hibernate applications use the parent / child pattern in many places.
         </p><p>
             We mentioned an alternative in the first paragraph. None of the above issues exist in the case of
             <tt class="literal">&lt;composite-element&gt;</tt> mappings, which have exactly the semantics of a parent / child
             relationship. Unfortunately, there are two big limitations to composite element classes: composite elements 
             may not own collections, and they should not be the child of any entity other than the unique parent.
         </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapter&nbsp;22.&nbsp;Example: Weblog Application</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>22.1.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
            The persistent classes represent a weblog, and an item posted
            in a weblog. They are to be modelled as a standard parent/child
            relationship, but we will use an ordered bag, instead of a set.
        </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>22.2.&nbsp;Hibernate Mappings</h2></div></div><div></div></div><p>
            The XML mappings should now be quite straightforward.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>22.3.&nbsp;Hibernate Code</h2></div></div><div></div></div><p>
            The following class demonstrates some of the kinds of things
            we can do with these classes, using Hibernate.
        </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapter&nbsp;23.&nbsp;Example: Various Mappings</h2></div></div><div></div></div><p>
        This chapters shows off some more complex association mappings.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>23.1.&nbsp;Employer/Employee</h2></div></div><div></div></div><p>
            The following model of the relationship between <tt class="literal">Employer</tt> and 
            <tt class="literal">Employee</tt> uses an actual entity class (<tt class="literal">Employment</tt>) 
            to represent the association. This is done because there might be more than one
            period of employment for the same two parties. Components are used to model monetary 
            values and employee names.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.gif" align="middle"></div><p>
            Heres a possible mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        And heres the table schema generated by <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>23.2.&nbsp;Author/Work</h2></div></div><div></div></div><p>
            Consider the following model of the relationships between <tt class="literal">Work</tt>,
            <tt class="literal">Author</tt> and <tt class="literal">Person</tt>. We represent the relationship
            between <tt class="literal">Work</tt> and <tt class="literal">Author</tt> as a many-to-many
            association. We choose to represent the relationship between <tt class="literal">Author</tt> 
            and <tt class="literal">Person</tt> as one-to-one association. Another possibility would be to 
            have <tt class="literal">Author</tt> extend <tt class="literal">Person</tt>.  
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.gif" align="middle"></div><p>
            The following mapping document correctly represents these relationships:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        There are four tables in this mapping. <tt class="literal">works</tt>, 
        <tt class="literal">authors</tt> and <tt class="literal">persons</tt> hold work, author
        and person data respectively. <tt class="literal">author_work</tt> is an association
        table linking authors to works. Heres the table schema, as generated by
        <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>23.3.&nbsp;Customer/Order/Product</h2></div></div><div></div></div><p>
            Now consider a model of the relationships between <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt> and <tt class="literal">LineItem</tt> and <tt class="literal">Product</tt>.
            There is a one-to-many association between <tt class="literal">Customer</tt> and
            <tt class="literal">Order</tt>, but how should we represent <tt class="literal">Order</tt> / 
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? I've chosen to map
            <tt class="literal">LineItem</tt> as an association class representing the many-to-many
            association between <tt class="literal">Order</tt> and <tt class="literal">Product</tt>. In
            Hibernate, this is called a composite element.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.gif" align="middle"></div><p>
            The mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> and 
        <tt class="literal">products</tt> hold customer, order, order line item and product data
        respectively. <tt class="literal">line_items</tt> also acts as an association table linking
        orders with products.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="misc"></a>23.4.&nbsp;Miscellaneous example mappings</h2></div></div><div></div></div><p>
            These examples are all taken from the Hibernate test suite. You
            will find many other useful example mappings there. Have a look at the
            <tt class="literal">src</tt> folder of the Hibernate distribution.
        </p><p>TODO: put words around this stuff</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-typed-onetone"></a>23.4.1.&nbsp;"Typed" one-to-one association</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2" 
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person" 
                column="personName"/&gt;
        &lt;key-property name="type" 
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-composite-key"></a>23.4.2.&nbsp;Composite key example</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;
    
    &lt;composite-id name="id" 
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="orderDate" 
            type="calendar_date"
            not-null="true"/&gt;
    
    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price) 
            from LineItem li, Product p 
            where li.productId = p.productId 
                and li.customerId = customerId 
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;
    
    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false" 
            not-null="true"/&gt;
        
    &lt;bag name="lineItems"
            fetch="join" 
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
    
&lt;/class&gt;
    
&lt;class name="LineItem"&gt;
    
    &lt;composite-id name="id" 
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="quantity"/&gt;
    
    &lt;many-to-one name="order"
            insert="false"
            update="false" 
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;
    
    &lt;many-to-one name="product"
            insert="false"
            update="false" 
            not-null="true"
            column="productId"/&gt;
        
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    
    &lt;property name="description" 
        not-null="true" 
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;
    
    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity) 
            from LineItem li 
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-content-discrimination"></a>23.4.3.&nbsp;Content based discrimination</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;
    
    &lt;id name="id" 
        column="person_id" 
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    
            
    &lt;discriminator 
        type="character"&gt;
        &lt;formula&gt;
            case 
                when title is not null then 'E' 
                when salesperson is not null then 'C' 
                else 'P' 
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name" 
        not-null="true"
        length="80"/&gt;
        
    &lt;property name="sex" 
        not-null="true"
        update="false"/&gt;
    
    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;
    
    &lt;subclass name="Employee" 
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;
    
    &lt;subclass name="Customer" 
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-association-alternatekeys"></a>23.4.4.&nbsp;Associations on alternate keys</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    
    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;
    
    &lt;property name="name" length="100"/&gt;
    
    &lt;one-to-one name="address" 
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;
    
    &lt;set name="accounts" 
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;
    
    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    
    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;
    
    &lt;property name="type" not-null="true"/&gt;
    
&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapter&nbsp;24.&nbsp;Best Practices</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Use an <tt class="literal">Address</tt> class to encapsulate <tt class="literal">street</tt>,
                    <tt class="literal">suburb</tt>, <tt class="literal">state</tt>, <tt class="literal">postcode</tt>.
                    This encourages code reuse and simplifies refactoring.
                </p></dd><dt><span class="term">Declare identifier properties on persistent classes.</span></dt><dd><p>
                    Hibernate makes identifier properties optional. There are all sorts of reasons why
                    you should use them. We recommend that identifiers be 'synthetic' (generated, with
                    no business meaning). It doesn't make a difference if you use <tt class="literal">long</tt>
                    or <tt class="literal">java.lang.Long</tt>; primitives might be syntactically easier to handle
                    though.
                </p></dd><dt><span class="term">Place each class mapping in its own file.</span></dt><dd><p>
                     Don't use a single monolithic mapping document. Map <tt class="literal">com.eg.Foo</tt> in 
                     the file <tt class="literal">com/eg/Foo.hbm.xml</tt>. This makes particularly good sense in 
                     a team environment.
                </p></dd><dt><span class="term">Load mappings as resources.</span></dt><dd><p>
                    Deploy the mappings along with the classes they map.
                </p></dd><dt><span class="term">Consider externalising query strings.</span></dt><dd><p>
                    This is a good practice if your queries call non-ANSI-standard SQL functions. 
                    Externalising the query strings to mapping files will make the application more portable.
                </p></dd><dt><span class="term">Use bind variables.</span></dt><dd><p>
                     As in JDBC, always replace non-constant values by "?". Never use string manipulation to 
                     bind a non-constant value in a query! Even better, consider using named parameters in
                     queries.
                </p></dd><dt><span class="term">Don't manage your own JDBC connections.</span></dt><dd><p>
                    Hibernate lets the application manage JDBC connections. This approach should be considered 
                    a last-resort. If you can't use the built-in connections providers, consider providing your 
                    own implementation of <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>.
                </p></dd><dt><span class="term">Consider using a custom type.</span></dt><dd><p>
                    Suppose you have a Java type, say from some library, that needs to be persisted but doesn't 
                    provide the accessors needed to map it as a component. You should consider implementing
                    <tt class="literal">org.hibernate.UserType</tt>. This approach frees the application
                    code from implementing transformations to / from a Hibernate type.
                </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks.</span></dt><dd><p>
                    In performance-critical areas of the system, some kinds of operations (eg. mass update /
                    delete) might benefit from direct JDBC. But please, wait until you <span class="emphasis"><em>know</em></span> 
                    something is a bottleneck. And don't assume that direct JDBC is necessarily faster. If need to 
                    use direct JDBC, it might be worth opening a Hibernate <tt class="literal">Session</tt> and using that SQL 
                    connection. That way you can still use the same transaction strategy and underlying connection 
                    provider.
                </p></dd><dt><span class="term">Understand <tt class="literal">Session</tt> flushing.</span></dt><dd><p>
                    From time to time the Session synchronizes its persistent state with the database. Performance will
                    be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by 
                    disabling automatic flushing or even by changing the order of queries and other operations within a 
                    particular transaction.      
                </p></dd><dt><span class="term">In a three tiered architecture, consider using <tt class="literal">saveOrUpdate()</tt>.</span></dt><dd><p>
                    When using a servlet / session bean architecture, you could pass persistent objects loaded in
                    the session bean to and from the servlet / JSP layer. Use a new session to service each request. 
                    Use <tt class="literal">Session.update()</tt> or <tt class="literal">Session.saveOrUpdate()</tt> to update the 
                    persistent state of an object.
                </p></dd><dt><span class="term">In a two tiered architecture, consider using session disconnection.</span></dt><dd><p>
                    Database Transactions have to be as short as possible for best scalability. However, it is often
                    neccessary to implement long running Application Transactions, a single unit-of-work from the
                    point of view of a user. This Application Transaction might span several client requests and
                    response cycles. Either use Detached Objects or, in two tiered architectures, simply disconnect
                    the Hibernate Session from the JDBC connection and reconnect it for each subsequent request. Never
                    use a single Session for more than one Application Transaction usecase, otherwise, you will run
                    into stale data.
                </p></dd><dt><span class="term">Don't treat exceptions as recoverable.</span></dt><dd><p>
                    This is more of a necessary practice than a "best" practice. When an exception occurs, roll back
                    the <tt class="literal">Transaction</tt> and close the <tt class="literal">Session</tt>. If you don't, Hibernate
                    can't guarantee that in-memory state accurately represents persistent state. As a special case of this,
                    do not use <tt class="literal">Session.load()</tt> to determine if an instance with the given identifier 
                    exists on the database; use <tt class="literal">find()</tt> instead.
                </p></dd><dt><span class="term">Prefer lazy fetching for associations.</span></dt><dd><p>
                    Use eager (outer-join) fetching sparingly. Use proxies and/or lazy collections for most associations
                    to classes that are not cached at the JVM-level. For associations to cached classes, where there is
                    a high probability of a cache hit, explicitly disable eager fetching using 
                    <tt class="literal">outer-join="false"</tt>. When an outer-join fetch is appropriate to a particular use
                    case, use a query with a <tt class="literal">left join</tt>.
                </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate.</span></dt><dd><p>
                    Hide (Hibernate) data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and 
                    <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by
                    handcoded JDBC, associated to Hibernate via a <tt class="literal">UserType</tt>. (This advice is 
                    intended for "sufficiently large" applications; it is not appropriate for an application with
                    five tables!)
                </p></dd><dt><span class="term">Implement <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> using a unique business key.</span></dt><dd><p>
                    If you compare objects outside of the Session scope, you have to implement <tt class="literal">equals()</tt>
                    and <tt class="literal">hashCode()</tt>. Inside the Session scope, Java object identity is guaranteed. If
                    you implement these methods, never ever use the database identifier! A transient object doesn't have
                    an identifier value and Hibernate would assign a value when the object is saved. If the object
                    is in a Set while being saved, the hash code changes, breaking the contract. To implement
                    <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>, use a unique business key, that is,
                    compare a unique combination of class properties. Remember that this key has to be stable and unique
                    only while the object is in a Set, not for the whole lifetime (not as stable as a database primary
                    key). Never use collections in the <tt class="literal">equals()</tt> comparison (lazy loading) and be careful
                    with other associated classes that might be proxied.
                </p></dd><dt><span class="term">Don't use exotic association mappings.</span></dt><dd><p>
                    Good usecases for a real many-to-many associations are rare. Most of the time you need
                    additional information stored in the "link table". In this case, it is much better to
                    use two one-to-many associations to an intermediate link class. In fact, we think that
                    most associations are one-to-many and many-to-one, you should be careful when using any
                    other association style and ask yourself if it is really neccessary.
                </p></dd></dl></div></div></div></body></html>